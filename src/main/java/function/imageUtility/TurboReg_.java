/*====================================================================	| Version: June 19, 2008\===================================================================*//*==================================================================== | Philippe Thevenaz | EPFL/STI/IOA/LIB | Station 17 | CH-1015 Lausanne VD | Switzerland | | phone (CET): +41(21)693.51.61 | fax: +41(21)693.37.01 | RFC-822: philippe.thevenaz@epfl.ch | X-400: /C=ch/A=400net/P=switch/O=epfl/S=thevenaz/G=philippe/ | URL: http://bigwww.epfl.ch/ \===================================================================*//*==================================================================== | This work is based on the following paper: | | P. Thevenaz, U.E. Ruttimann, M. Unser | A Pyramid Approach to Subpixel Registration Based on Intensity | IEEE Transactions on Image Processing | vol. 7, no. 1, pp. 27-41, January 1998. | | This paper is available on-line at | http://bigwww.epfl.ch/publications/thevenaz9801.html | | Other relevant on-line publications are available at | http://bigwww.epfl.ch/publications/ \===================================================================*//*==================================================================== | Additional help available at http://bigwww.epfl.ch/thevenaz/turboreg/ | | You'll be free to use this software for research purposes, but you | should not redistribute it without our consent. In addition, we expect | you to include a citation or acknowledgment whenever you present or | publish results that are based on it. \===================================================================*/// ImageJpackage function.imageUtility;import java.awt.BorderLayout;import java.awt.Button;import java.awt.Canvas;import java.awt.Checkbox;import java.awt.CheckboxGroup;import java.awt.Choice;import java.awt.Color;import java.awt.Component;import java.awt.Container;import java.awt.Dialog;import java.awt.Event;import java.awt.FileDialog;import java.awt.FlowLayout;import java.awt.Frame;import java.awt.Graphics;import java.awt.GridLayout;import java.awt.Insets;import java.awt.Label;import java.awt.Panel;import java.awt.Point;import java.awt.Scrollbar;import java.awt.TextArea;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.AdjustmentEvent;import java.awt.event.AdjustmentListener;import java.awt.event.FocusEvent;import java.awt.event.FocusListener;import java.awt.event.ItemEvent;import java.awt.event.ItemListener;import java.awt.event.KeyEvent;import java.awt.event.KeyListener;import java.awt.event.MouseEvent;import java.awt.event.MouseListener;import java.awt.event.MouseMotionListener;import java.io.BufferedReader;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.io.StreamTokenizer;import java.io.StringReader;import java.util.Stack;import java.util.Vector;import ij.IJ;import ij.ImagePlus;import ij.ImageStack;import ij.Macro;import ij.WindowManager;import ij.gui.GUI;import ij.gui.ImageCanvas;import ij.gui.ImageWindow;import ij.gui.Roi;import ij.gui.StackWindow;import ij.gui.Toolbar;import ij.measure.Calibration;import ij.measure.ResultsTable;import ij.plugin.PlugIn;import ij.plugin.filter.Analyzer;import ij.process.FloatProcessor;import ij.process.ImageConverter;import ij.process.StackConverter;/********************************************************************* * This class is the only one that is accessed directly by imageJ; it launches a modeless dialog and dies. Note that it implements <code>PlugIn</code> rather than <code>PlugInFilter</code>. ********************************************************************/public class TurboReg_ implements PlugIn {		public static int TRANSLATION = turboRegDialog.TRANSLATION, RIGID_BODY = turboRegDialog.RIGID_BODY, AFFINE = turboRegDialog.AFFINE, GENERIC = turboRegDialog.GENERIC_TRANSFORMATION, SCALED_ROTATION = turboRegDialog.SCALED_ROTATION;		// Private variables		public double[][] sourcePoints = new double[turboRegPointHandler.NUM_POINTS][2];	public double[][] targetPoints = new double[turboRegPointHandler.NUM_POINTS][2];	private ImagePlus transformedImage = null;		/*	 * .................................................................... Public methods ....................................................................	 */		/*********************************************************************	 * Accessor method for the <code>(double[][])sourcePoints</code> variable. This variable is valid only after a call to <code>run</code> with the option <code>-align</code> has been issued. What is returned is a two-dimensional array of type	 * <code>double[][]</code> that contains coordinates from the image <code>sourceFilename</code>. These coordinates are given relative to the original image, before that the cropping described by the <code>sourceCropLeft</code>,	 * <code>sourceCropTop</code>, <code>sourceCropRight</code>, and <code>sourceCropBottom</code> has been applied. These coordinates match those available from <code>targetPoints</code>. The total number of coordinates, equal to	 * <code>sourcePoints[*].length</code>, is given by the constant <code>turboRegPointHandler.NUM_POINTS</code> which corresponds to four coordinates in the present version. The second index gives the horizontal component for <code>[0]</code> and	 * the vertical component for <code>[1]</code>. The number of <i>useful</i> coordinates depends on the specific transformation for which the alignment has been performed: translation (1), scaled rotation (2), rotation (3), affine transformation	 * (3), and bilinear transformation (4).	 * 	 * @see TurboReg_#run	 * @see TurboReg_#getTargetPoints	 ********************************************************************/	public double[][] getSourcePoints()	{		return (this.sourcePoints);	} /* end getSourcePoints */		/*********************************************************************	 * Accessor method for the <code>(double[][])targetPoints</code> variable. This variable is valid only after a call to <code>run</code> with the option <code>-align</code> has been issued. What is returned is a two-dimensional array of type	 * <code>double[][]</code> that contains coordinates from the image <code>targetFilename</code>. These coordinates are given relative to the original image, before that the cropping described by the <code>targetCropLeft</code>,	 * <code>targetCropTop</code>, <code>targetCropRight</code>, and <code>targetCropBottom</code> has been applied. These coordinates match those available from <code>sourcePoints</code>. The total number of coordinates, equal to	 * <code>targetPoints[*].length</code>, is given by the constant <code>turboRegPointHandler.NUM_POINTS</code> which corresponds to four coordinates in the present version. The second index gives the horizontal component for <code>[0]</code> and	 * the vertical component for <code>[1]</code>. The number of <i>useful</i> coordinates depends on the specific transformation for which the alignment has been performed: translation (1), scaled rotation (2), rotation (3), affine transformation	 * (3), and bilinear transformation (4).	 * 	 * @see TurboReg_#run	 * @see TurboReg_#getSourcePoints	 ********************************************************************/	public double[][] getTargetPoints()	{		return (this.targetPoints);	} /* end getTargetPoints */		/*********************************************************************	 * Accessor method for the <code>(ImagePlus)transformedImage</code> variable. This variable is valid only after a call to <code>run</code> with the option <code>-transform</code> has been issued. What is returned is an <code>ImagePlus</code>	 * object of the size described by the <code>outputWidth</code> and <code>outputHeight</code> parameters of the call to the <code>run</code> method of <code>TurboReg_</code>.	 * 	 * @see TurboReg_#run	 ********************************************************************/	public ImagePlus getTransformedImage()	{		return (this.transformedImage);	} /* end getTransformedImage */		/*********************************************************************	 * This method is the only one called by ImageJ. It checks that there are at least two grayscale images to register. If the command line is empty, then the plugin is executed in interactive mode. Else, the command line has the following syntax: <br>	 * <br>	 * <table border="1">	 * <tr>	 * <th>command</th>	 * <th>parameter</th>	 * <th>index</th>	 * <th>comment</th>	 * </tr>	 * <tr>	 * <td>&#8722;help</td>	 * <td></td>	 * <td>00</td>	 * <td>prints out the syntax</td>	 * </tr>	 * <tr>	 * <td>&#8722;align</td>	 * <td></td>	 * <td>00</td>	 * <td>do refine the landmarks</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>&#8722;file<br>	 * &#8722;window</td>	 * <td>01</td>	 * <td>reference type</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>sourceFilename<br>	 * sourceWindowTitle</td>	 * <td>02</td>	 * <td>string with optional quotes</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>sourceCropLeft</td>	 * <td>03</td>	 * <td>integer</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>sourceCropTop</td>	 * <td>04</td>	 * <td>integer</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>sourceCropRight</td>	 * <td>05</td>	 * <td>integer</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>sourceCropBottom</td>	 * <td>06</td>	 * <td>integer</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>&#8722;file<br>	 * &#8722;window</td>	 * <td>07</td>	 * <td>reference type</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>targetFilename<br>	 * targetWindowTitle</td>	 * <td>08</td>	 * <td>string with optional quotes</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>targetCropLeft</td>	 * <td>09</td>	 * <td>integer</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>targetCropTop</td>	 * <td>10</td>	 * <td>integer</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>targetCropRight</td>	 * <td>11</td>	 * <td>integer</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>targetCropBottom</td>	 * <td>12</td>	 * <td>integer</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>&#8722;translation<br>	 * &#8722;rigidBody<br>	 * &#8722;scaledRotation<br>	 * &#8722;affine<br>	 * &#8722;bilinear</td>	 * <td>13</td>	 * <td>transformation (TRSAB)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>sourcePoints[0][0]</td>	 * <td>14</td>	 * <td>floating-point (TRSAB)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>sourcePoints[0][1]</td>	 * <td>15</td>	 * <td>floating-point (TRSAB)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>targetPoints[0][0]</td>	 * <td>16</td>	 * <td>floating-point (TRSAB)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>targetPoints[0][1]</td>	 * <td>17</td>	 * <td>floating-point (TRSAB)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>sourcePoints[1][0]</td>	 * <td>18</td>	 * <td>floating-point (RSAB)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>sourcePoints[1][1]</td>	 * <td>19</td>	 * <td>floating-point (RSAB)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>targetPoints[1][0]</td>	 * <td>20</td>	 * <td>floating-point (RSAB)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>targetPoints[1][1]</td>	 * <td>21</td>	 * <td>floating-point (RSAB)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>sourcePoints[2][0]</td>	 * <td>22</td>	 * <td>floating-point (RAB)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>sourcePoints[2][1]</td>	 * <td>23</td>	 * <td>floating-point (RAB)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>targetPoints[2][0]</td>	 * <td>24</td>	 * <td>floating-point (RAB)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>targetPoints[2][1]</td>	 * <td>25</td>	 * <td>floating-point (RAB)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>sourcePoints[3][0]</td>	 * <td>26</td>	 * <td>floating-point (B)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>sourcePoints[3][1]</td>	 * <td>27</td>	 * <td>floating-point (B)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>targetPoints[3][0]</td>	 * <td>28</td>	 * <td>floating-point (B)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>targetPoints[3][1]</td>	 * <td>29</td>	 * <td>floating-point (B)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>&#8722;hideOutput<br>	 * &#8722;showOutput</td>	 * <td>18 (T)<br>	 * 22 (S)<br>	 * 26 (RA)<br>	 * 30 (B)</td>	 * <td></td>	 * </tr>	 * <tr>	 * <td>&#8722;transform</td>	 * <td></td>	 * <td>00</td>	 * <td>do not refine the landmarks</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>&#8722;file<br>	 * &#8722;window</td>	 * <td>01</td>	 * <td>reference type</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>sourceFilename<br>	 * sourceWindowTitle</td>	 * <td>02</td>	 * <td>string with optional quotes</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>outputWidth</td>	 * <td>03</td>	 * <td>integer</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>outputHeight</td>	 * <td>04</td>	 * <td>integer</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>&#8722;translation<br>	 * &#8722;rigidBody<br>	 * &#8722;scaledRotation<br>	 * &#8722;affine<br>	 * &#8722;bilinear</td>	 * <td>05</td>	 * <td>transformation (TRSAB)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>sourcePoints[0][0]</td>	 * <td>06</td>	 * <td>floating-point (TRSAB)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>sourcePoints[0][1]</td>	 * <td>07</td>	 * <td>floating-point (TRSAB)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>targetPoints[0][0]</td>	 * <td>08</td>	 * <td>floating-point (TRSAB)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>targetPoints[0][1]</td>	 * <td>09</td>	 * <td>floating-point (TRSAB)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>sourcePoints[1][0]</td>	 * <td>10</td>	 * <td>floating-point (RSAB)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>sourcePoints[1][1]</td>	 * <td>11</td>	 * <td>floating-point (RSAB)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>targetPoints[1][0]</td>	 * <td>12</td>	 * <td>floating-point (RSAB)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>targetPoints[1][1]</td>	 * <td>13</td>	 * <td>floating-point (RSAB)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>sourcePoints[2][0]</td>	 * <td>14</td>	 * <td>floating-point (RAB)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>sourcePoints[2][1]</td>	 * <td>15</td>	 * <td>floating-point (RAB)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>targetPoints[2][0]</td>	 * <td>16</td>	 * <td>floating-point (RAB)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>targetPoints[2][1]</td>	 * <td>17</td>	 * <td>floating-point (RAB)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>sourcePoints[3][0]</td>	 * <td>18</td>	 * <td>floating-point (B)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>sourcePoints[3][1]</td>	 * <td>19</td>	 * <td>floating-point (B)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>targetPoints[3][0]</td>	 * <td>20</td>	 * <td>floating-point (B)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>targetPoints[3][1]</td>	 * <td>21</td>	 * <td>floating-point (B)</td>	 * </tr>	 * <tr>	 * <td></td>	 * <td>&#8722;hideOutput<br>	 * &#8722;showOutput</td>	 * <td>10 (T)<br>	 * 14 (S)<br>	 * 18 (RA)<br>	 * 22 (B)</td>	 * <td></td>	 * </tr>	 * </table>	 * <br>	 * Example: The command line <br>	 * <code>&#8722;align &#8722;file path/source.tif 40 80 639 479 &#8722;file path/target.tif 0 0 639 479 &#8722;translation 320 240 331.7 210 &#8722;showOutput</code> <br>	 * aligns 'source.tif' to 'target.tif' by translation, by refining an initial horizontal offset <br>	 * <i>dx</i> = (331.7 &#8722; 320) = 11.7 <br>	 * and an initial vertical offset <br>	 * <i>dy</i> = (210 &#8722; 240) = &#8722;30 <br>	 * The effective size of 'source.tif' is 600 x 400. The effective size of 'target.tif' is 640 x 480. The source and target points are given in relation to the original (uncropped) system of coordinates. The resulting output will be displayed. <br>	 * <div style="color:red">IMPORTANT: You MUST use a pair of double quotes to enclose paths and filenames that contain white characters. Example: <code>"my path/my file"</code>. Escape characters (<i>e.g.</i>, a backslash) are not	 * interpreted.</div>	 * 	 * @param commandLine	 *            <code>String</code> optional list of parameters.	 ********************************************************************/	@Override	public void run(final String commandLine)	{		String options = Macro.getOptions();		if(!commandLine.equals(""))		{			options = commandLine;		}		if(options == null)		{			Runtime.getRuntime().gc();			final ImagePlus[] admissibleImageList = this.createAdmissibleImageList();			if(admissibleImageList.length < 2)			{				IJ.error("At least two grayscale or RGB-stack images are required");				return;			}			final turboRegDialog dialog = new turboRegDialog(IJ.getInstance(), admissibleImageList);			GUI.center(dialog);			dialog.setVisible(true);		}		else		{			final String[] token = this.getTokens(options);			if(token.length < 1)			{				this.dumpSyntax(options);				IJ.error("Invalid syntax");				return;			}			if(token[0].equals("-help"))			{				this.dumpSyntax(options);				return;			}			else if(token[0].equals("-align"))			{				switch (token.length)				{					case 19:					case 23:					case 27:					case 31:					{						break;					}					default:					{						this.dumpSyntax(options);						IJ.error("Invalid syntax");						return;					}				}				ImagePlus source = null;				final int[] sourceCrop = new int[4];				ImagePlus target = null;				final int[] targetCrop = new int[4];				int transformation = turboRegDialog.GENERIC_TRANSFORMATION;				Boolean interactive = null;				try				{					if(token[1].equals("-file"))					{						source = new ImagePlus(token[2]);					}					else if(token[1].equals("-window"))					{						final int[] IDlist = WindowManager.getIDList();						if(IDlist == null)						{							source = null;						}						else						{							for (int k = 0; (k < IDlist.length); k++)							{								source = WindowManager.getImage(IDlist[k]);								if(source.getTitle().equals(token[2]))								{									break;								}								else								{									source = null;								}							}						}					}					else					{						this.dumpSyntax(options);						IJ.error("Invalid reference type: " + token[1]);						return;					}					if(source == null)					{						this.dumpSyntax(options);						IJ.error("Invalid source: " + token[2]);						return;					}					for (int i = 0; (i < 4); i++)					{						sourceCrop[i] = new Integer(token[i + 3]).intValue();					}					if(token[7].equals("-file"))					{						target = new ImagePlus(token[8]);					}					else if(token[7].equals("-window"))					{						final int[] IDlist = WindowManager.getIDList();						if(IDlist == null)						{							target = null;						}						else						{							for (int k = 0; (k < IDlist.length); k++)							{								target = WindowManager.getImage(IDlist[k]);								if(target.getTitle().equals(token[8]))								{									break;								}								else								{									target = null;								}							}						}					}					else					{						this.dumpSyntax(options);						IJ.error("Invalid reference type: " + token[7]);						return;					}					if(target == null)					{						this.dumpSyntax(options);						IJ.error("Invalid target: " + token[8]);						return;					}					for (int i = 0; (i < 4); i++)					{						targetCrop[i] = new Integer(token[i + 9]).intValue();					}					transformation = this.getTransformation(token[13]);					switch (transformation)					{						case turboRegDialog.TRANSLATION:						{							if(token.length != 19)							{								this.dumpSyntax(options);								IJ.error("Invalid number of source and target points");								return;							}							this.sourcePoints[0][0] = new Double(token[14]).doubleValue();							this.sourcePoints[0][1] = new Double(token[15]).doubleValue();							this.targetPoints[0][0] = new Double(token[16]).doubleValue();							this.targetPoints[0][1] = new Double(token[17]).doubleValue();							interactive = this.getInteractive(token[18]);							break;						}						case turboRegDialog.SCALED_ROTATION:						{							if(token.length != 23)							{								this.dumpSyntax(options);								IJ.error("Invalid number of source and target points");								return;							}							this.sourcePoints[0][0] = new Double(token[14]).doubleValue();							this.sourcePoints[0][1] = new Double(token[15]).doubleValue();							this.targetPoints[0][0] = new Double(token[16]).doubleValue();							this.targetPoints[0][1] = new Double(token[17]).doubleValue();							this.sourcePoints[1][0] = new Double(token[18]).doubleValue();							this.sourcePoints[1][1] = new Double(token[19]).doubleValue();							this.targetPoints[1][0] = new Double(token[20]).doubleValue();							this.targetPoints[1][1] = new Double(token[21]).doubleValue();							interactive = this.getInteractive(token[22]);							break;						}						case turboRegDialog.RIGID_BODY:						case turboRegDialog.AFFINE:						{							if(token.length != 27)							{								this.dumpSyntax(options);								IJ.error("Invalid number of source and target points");								return;							}							this.sourcePoints[0][0] = new Double(token[14]).doubleValue();							this.sourcePoints[0][1] = new Double(token[15]).doubleValue();							this.targetPoints[0][0] = new Double(token[16]).doubleValue();							this.targetPoints[0][1] = new Double(token[17]).doubleValue();							this.sourcePoints[1][0] = new Double(token[18]).doubleValue();							this.sourcePoints[1][1] = new Double(token[19]).doubleValue();							this.targetPoints[1][0] = new Double(token[20]).doubleValue();							this.targetPoints[1][1] = new Double(token[21]).doubleValue();							this.sourcePoints[2][0] = new Double(token[22]).doubleValue();							this.sourcePoints[2][1] = new Double(token[23]).doubleValue();							this.targetPoints[2][0] = new Double(token[24]).doubleValue();							this.targetPoints[2][1] = new Double(token[25]).doubleValue();							interactive = this.getInteractive(token[26]);							break;						}						case turboRegDialog.BILINEAR:						{							if(token.length != 31)							{								this.dumpSyntax(options);								IJ.error("Invalid number of source and target points");								return;							}							this.sourcePoints[0][0] = new Double(token[14]).doubleValue();							this.sourcePoints[0][1] = new Double(token[15]).doubleValue();							this.targetPoints[0][0] = new Double(token[16]).doubleValue();							this.targetPoints[0][1] = new Double(token[17]).doubleValue();							this.sourcePoints[1][0] = new Double(token[18]).doubleValue();							this.sourcePoints[1][1] = new Double(token[19]).doubleValue();							this.targetPoints[1][0] = new Double(token[20]).doubleValue();							this.targetPoints[1][1] = new Double(token[21]).doubleValue();							this.sourcePoints[2][0] = new Double(token[22]).doubleValue();							this.sourcePoints[2][1] = new Double(token[23]).doubleValue();							this.targetPoints[2][0] = new Double(token[24]).doubleValue();							this.targetPoints[2][1] = new Double(token[25]).doubleValue();							this.sourcePoints[3][0] = new Double(token[26]).doubleValue();							this.sourcePoints[3][1] = new Double(token[27]).doubleValue();							this.targetPoints[3][0] = new Double(token[28]).doubleValue();							this.targetPoints[3][1] = new Double(token[29]).doubleValue();							interactive = this.getInteractive(token[30]);							break;						}						default:						{							this.dumpSyntax(options);							IJ.error("Invalid transformation");							return;						}					}				}				catch (NumberFormatException e)				{					this.dumpSyntax(options);					IJ.log("Number format exception " + e.getMessage());					IJ.error("Invalid syntax");					return;				}				if(interactive == null)				{					this.dumpSyntax(options);					IJ.error("Invalid directive for interactivity");					return;				}				this.transformedImage = this.alignImages(source, sourceCrop, target, targetCrop, transformation, interactive.booleanValue(), null);			}			else if(token[0].equals("-transform"))			{				switch (token.length)				{					case 11:					case 15:					case 19:					case 23:					{						break;					}					default:					{						this.dumpSyntax(options);						IJ.error("Invalid syntax");						return;					}				}				ImagePlus source = null;				int outputWidth = -1;				int outputHeight = -1;				int transformation = turboRegDialog.GENERIC_TRANSFORMATION;				Boolean interactive = null;				try				{					if(token[1].equals("-file"))					{						source = new ImagePlus(token[2]);					}					else if(token[1].equals("-window"))					{						final int[] IDlist = WindowManager.getIDList();						for (int k = 0; (k < IDlist.length); k++)						{							source = WindowManager.getImage(IDlist[k]);							if(source.getTitle().equals(token[2]))							{								break;							}							else							{								source = null;							}						}					}					else					{						this.dumpSyntax(options);						IJ.error("Invalid reference type: " + token[1]);						return;					}					if(source == null)					{						this.dumpSyntax(options);						IJ.error("Invalid source: " + token[2]);						return;					}					outputWidth = new Integer(token[3]).intValue();					if(outputWidth <= 0)					{						this.dumpSyntax(options);						IJ.error("Invalid output width: " + token[3]);						return;					}					outputHeight = new Integer(token[4]).intValue();					if(outputHeight <= 0)					{						this.dumpSyntax(options);						IJ.error("Invalid output height: " + token[4]);						return;					}					transformation = this.getTransformation(token[5]);					switch (transformation)					{						case turboRegDialog.TRANSLATION:						{							if(token.length != 11)							{								this.dumpSyntax(options);								IJ.error("Invalid number of source and target points");								return;							}							this.sourcePoints[0][0] = new Double(token[6]).doubleValue();							this.sourcePoints[0][1] = new Double(token[7]).doubleValue();							this.targetPoints[0][0] = new Double(token[8]).doubleValue();							this.targetPoints[0][1] = new Double(token[9]).doubleValue();							interactive = this.getInteractive(token[10]);							break;						}						case turboRegDialog.SCALED_ROTATION:						{							if(token.length != 15)							{								this.dumpSyntax(options);								IJ.error("Invalid number of source and target points");								return;							}							this.sourcePoints[0][0] = new Double(token[6]).doubleValue();							this.sourcePoints[0][1] = new Double(token[7]).doubleValue();							this.targetPoints[0][0] = new Double(token[8]).doubleValue();							this.targetPoints[0][1] = new Double(token[9]).doubleValue();							this.sourcePoints[1][0] = new Double(token[10]).doubleValue();							this.sourcePoints[1][1] = new Double(token[11]).doubleValue();							this.targetPoints[1][0] = new Double(token[12]).doubleValue();							this.targetPoints[1][1] = new Double(token[13]).doubleValue();							interactive = this.getInteractive(token[14]);							break;						}						case turboRegDialog.RIGID_BODY:						case turboRegDialog.AFFINE:						{							if(token.length != 19)							{								this.dumpSyntax(options);								IJ.error("Invalid number of source and target points");								return;							}							this.sourcePoints[0][0] = new Double(token[6]).doubleValue();							this.sourcePoints[0][1] = new Double(token[7]).doubleValue();							this.targetPoints[0][0] = new Double(token[8]).doubleValue();							this.targetPoints[0][1] = new Double(token[9]).doubleValue();							this.sourcePoints[1][0] = new Double(token[10]).doubleValue();							this.sourcePoints[1][1] = new Double(token[11]).doubleValue();							this.targetPoints[1][0] = new Double(token[12]).doubleValue();							this.targetPoints[1][1] = new Double(token[13]).doubleValue();							this.sourcePoints[2][0] = new Double(token[14]).doubleValue();							this.sourcePoints[2][1] = new Double(token[15]).doubleValue();							this.targetPoints[2][0] = new Double(token[16]).doubleValue();							this.targetPoints[2][1] = new Double(token[17]).doubleValue();							interactive = this.getInteractive(token[18]);							break;						}						case turboRegDialog.BILINEAR:						{							if(token.length != 23)							{								this.dumpSyntax(options);								IJ.error("Invalid number of source and target points");								return;							}							this.sourcePoints[0][0] = new Double(token[6]).doubleValue();							this.sourcePoints[0][1] = new Double(token[7]).doubleValue();							this.targetPoints[0][0] = new Double(token[8]).doubleValue();							this.targetPoints[0][1] = new Double(token[9]).doubleValue();							this.sourcePoints[1][0] = new Double(token[10]).doubleValue();							this.sourcePoints[1][1] = new Double(token[11]).doubleValue();							this.targetPoints[1][0] = new Double(token[12]).doubleValue();							this.targetPoints[1][1] = new Double(token[13]).doubleValue();							this.sourcePoints[2][0] = new Double(token[14]).doubleValue();							this.sourcePoints[2][1] = new Double(token[15]).doubleValue();							this.targetPoints[2][0] = new Double(token[16]).doubleValue();							this.targetPoints[2][1] = new Double(token[17]).doubleValue();							this.sourcePoints[3][0] = new Double(token[18]).doubleValue();							this.sourcePoints[3][1] = new Double(token[19]).doubleValue();							this.targetPoints[3][0] = new Double(token[20]).doubleValue();							this.targetPoints[3][1] = new Double(token[21]).doubleValue();							interactive = this.getInteractive(token[22]);							break;						}						default:						{							this.dumpSyntax(options);							IJ.error("Invalid transformation");							return;						}					}				}				catch (NumberFormatException e)				{					this.dumpSyntax(options);					IJ.log("Number format exception " + e.getMessage());					IJ.error("Invalid syntax");					return;				}				if(interactive == null)				{					this.dumpSyntax(options);					IJ.error("Invalid directive for interactivity");					return;				}				this.transformedImage = this.transformImage(source, outputWidth, outputHeight, transformation, interactive.booleanValue(), null);			}			else			{				this.dumpSyntax(options);				IJ.error("Invalid operation");				return;			}		}	} /* end run */		public void start(String[] token)	{				System.out.println("   TurboReg_ ---> Starting turboReg");				// for (int i=0,len=token.length; i<len; i++){		// System.out.println("   TurboReg_ ---> token "+i+" = "+token[i]);		// }				if(token.length < 1)		{						IJ.error("Invalid syntax");			return;		}				if(token[0].equals("-align"))		{			System.out.println("   TurboReg_ ---> Alignment requested");			switch (token.length)			{				case 19:				case 23:				case 27:				case 31:				{					break;				}				default:				{										IJ.error("Invalid syntax");					return;				}			}			ImagePlus source = null;			final int[] sourceCrop = new int[4];			ImagePlus target = null;			final int[] targetCrop = new int[4];			int transformation = turboRegDialog.GENERIC_TRANSFORMATION;			Boolean interactive = null;			try			{				if(token[1].equals("-file"))				{					source = new ImagePlus(token[2]);				}				else				{										IJ.error("Invalid reference type: " + token[1]);					return;				}								// if (source == null) {				//				// IJ.error("Invalid source: " + token[2]);				// return;				// }								for (int i = 0; (i < 4); i++)				{					sourceCrop[i] = new Integer(token[i + 3]).intValue();				}								if(token[7].equals("-file"))				{					target = new ImagePlus(token[8]);				}				else				{										IJ.error("Invalid reference type: " + token[7]);					return;				}				// if (target == null) {				//				// IJ.error("Invalid target: " + token[8]);				// return;				// }								for (int i = 0; (i < 4); i++)				{					targetCrop[i] = new Integer(token[i + 9]).intValue();				}								transformation = this.getTransformation(token[13]);				switch (transformation)				{					case turboRegDialog.TRANSLATION:					{						if(token.length != 19)						{														IJ.error("Invalid number of source and target points");							return;						}						this.sourcePoints[0][0] = new Double(token[14]).doubleValue();						this.sourcePoints[0][1] = new Double(token[15]).doubleValue();						this.targetPoints[0][0] = new Double(token[16]).doubleValue();						this.targetPoints[0][1] = new Double(token[17]).doubleValue();						interactive = this.getInteractive(token[18]);						break;					}					case turboRegDialog.SCALED_ROTATION:					{						if(token.length != 23)						{														IJ.error("Invalid number of source and target points");							return;						}						this.sourcePoints[0][0] = new Double(token[14]).doubleValue();						this.sourcePoints[0][1] = new Double(token[15]).doubleValue();						this.targetPoints[0][0] = new Double(token[16]).doubleValue();						this.targetPoints[0][1] = new Double(token[17]).doubleValue();						this.sourcePoints[1][0] = new Double(token[18]).doubleValue();						this.sourcePoints[1][1] = new Double(token[19]).doubleValue();						this.targetPoints[1][0] = new Double(token[20]).doubleValue();						this.targetPoints[1][1] = new Double(token[21]).doubleValue();						interactive = this.getInteractive(token[22]);						break;					}					case turboRegDialog.RIGID_BODY:					case turboRegDialog.AFFINE:					{						if(token.length != 27)						{														IJ.error("Invalid number of source and target points");							return;						}						this.sourcePoints[0][0] = new Double(token[14]).doubleValue();						this.sourcePoints[0][1] = new Double(token[15]).doubleValue();						this.targetPoints[0][0] = new Double(token[16]).doubleValue();						this.targetPoints[0][1] = new Double(token[17]).doubleValue();						this.sourcePoints[1][0] = new Double(token[18]).doubleValue();						this.sourcePoints[1][1] = new Double(token[19]).doubleValue();						this.targetPoints[1][0] = new Double(token[20]).doubleValue();						this.targetPoints[1][1] = new Double(token[21]).doubleValue();						this.sourcePoints[2][0] = new Double(token[22]).doubleValue();						this.sourcePoints[2][1] = new Double(token[23]).doubleValue();						this.targetPoints[2][0] = new Double(token[24]).doubleValue();						this.targetPoints[2][1] = new Double(token[25]).doubleValue();						interactive = this.getInteractive(token[26]);						break;					}					case turboRegDialog.BILINEAR:					{						if(token.length != 31)						{														IJ.error("Invalid number of source and target points");							return;						}						this.sourcePoints[0][0] = new Double(token[14]).doubleValue();						this.sourcePoints[0][1] = new Double(token[15]).doubleValue();						this.targetPoints[0][0] = new Double(token[16]).doubleValue();						this.targetPoints[0][1] = new Double(token[17]).doubleValue();						this.sourcePoints[1][0] = new Double(token[18]).doubleValue();						this.sourcePoints[1][1] = new Double(token[19]).doubleValue();						this.targetPoints[1][0] = new Double(token[20]).doubleValue();						this.targetPoints[1][1] = new Double(token[21]).doubleValue();						this.sourcePoints[2][0] = new Double(token[22]).doubleValue();						this.sourcePoints[2][1] = new Double(token[23]).doubleValue();						this.targetPoints[2][0] = new Double(token[24]).doubleValue();						this.targetPoints[2][1] = new Double(token[25]).doubleValue();						this.sourcePoints[3][0] = new Double(token[26]).doubleValue();						this.sourcePoints[3][1] = new Double(token[27]).doubleValue();						this.targetPoints[3][0] = new Double(token[28]).doubleValue();						this.targetPoints[3][1] = new Double(token[29]).doubleValue();						interactive = this.getInteractive(token[30]);						break;					}					default:					{												IJ.error("Invalid transformation");						return;					}				}			}			catch (NumberFormatException e)			{								IJ.log("Number format exception " + e.getMessage());				IJ.error("Invalid syntax");				return;			}			if(interactive == null)			{								IJ.error("Invalid directive for interactivity");				return;			}			this.transformedImage = this.alignImages(source, sourceCrop, target, targetCrop, transformation, interactive.booleanValue(), null);		}		else if(token[0].equals("-transform"))		{			System.out.println("   TurboReg_ ---> tranformation requested");			switch (token.length)			{				case 11:				case 15:				case 19:				case 23:				{					break;				}				default:				{										IJ.error("Invalid syntax");					return;				}			}			ImagePlus source = null;			int outputWidth = -1;			int outputHeight = -1;			int transformation = turboRegDialog.GENERIC_TRANSFORMATION;			Boolean interactive = null;			try			{				if(token[1].equals("-file"))				{					System.out.println("   TurboReg_ ---> Source file passed ");					source = new ImagePlus(token[2]);				}				else				{										IJ.error("Invalid reference type: " + token[1]);					return;				}				// if (source == null) {				//				// IJ.error("Invalid source: " + token[2]);				// System.out.println("   TurboReg_ ---> Invalid source ");				// return;				// }				outputWidth = new Integer(token[3]).intValue();				if(outputWidth <= 0)				{										IJ.error("Invalid output width: " + token[3]);					System.out.println("   TurboReg_ ---> Invalid outputwidth ");					return;				}				outputHeight = new Integer(token[4]).intValue();				if(outputHeight <= 0)				{										IJ.error("Invalid output height: " + token[4]);					System.out.println("   TurboReg_ ---> Invalid output height ");					return;				}				transformation = this.getTransformation(token[5]);				System.out.println("   TurboReg_ ---> Transformation requested " + transformation);				switch (transformation)				{					case turboRegDialog.TRANSLATION:					{						if(token.length != 11)						{														IJ.error("Invalid number of source and target points");							return;						}						this.sourcePoints[0][0] = new Double(token[6]).doubleValue();						this.sourcePoints[0][1] = new Double(token[7]).doubleValue();						this.targetPoints[0][0] = new Double(token[8]).doubleValue();						this.targetPoints[0][1] = new Double(token[9]).doubleValue();						interactive = this.getInteractive(token[10]);						break;					}					case turboRegDialog.SCALED_ROTATION:					{						if(token.length != 15)						{														IJ.error("Invalid number of source and target points");							return;						}						this.sourcePoints[0][0] = new Double(token[6]).doubleValue();						this.sourcePoints[0][1] = new Double(token[7]).doubleValue();						this.targetPoints[0][0] = new Double(token[8]).doubleValue();						this.targetPoints[0][1] = new Double(token[9]).doubleValue();						this.sourcePoints[1][0] = new Double(token[10]).doubleValue();						this.sourcePoints[1][1] = new Double(token[11]).doubleValue();						this.targetPoints[1][0] = new Double(token[12]).doubleValue();						this.targetPoints[1][1] = new Double(token[13]).doubleValue();						interactive = this.getInteractive(token[14]);						break;					}					case turboRegDialog.RIGID_BODY:					case turboRegDialog.AFFINE:					{						if(token.length != 19)						{														IJ.error("Invalid number of source and target points");							return;						}						this.sourcePoints[0][0] = new Double(token[6]).doubleValue();						this.sourcePoints[0][1] = new Double(token[7]).doubleValue();						this.targetPoints[0][0] = new Double(token[8]).doubleValue();						this.targetPoints[0][1] = new Double(token[9]).doubleValue();						this.sourcePoints[1][0] = new Double(token[10]).doubleValue();						this.sourcePoints[1][1] = new Double(token[11]).doubleValue();						this.targetPoints[1][0] = new Double(token[12]).doubleValue();						this.targetPoints[1][1] = new Double(token[13]).doubleValue();						this.sourcePoints[2][0] = new Double(token[14]).doubleValue();						this.sourcePoints[2][1] = new Double(token[15]).doubleValue();						this.targetPoints[2][0] = new Double(token[16]).doubleValue();						this.targetPoints[2][1] = new Double(token[17]).doubleValue();						interactive = this.getInteractive(token[18]);						break;					}					case turboRegDialog.BILINEAR:					{						if(token.length != 23)						{														IJ.error("Invalid number of source and target points");							return;						}						this.sourcePoints[0][0] = new Double(token[6]).doubleValue();						this.sourcePoints[0][1] = new Double(token[7]).doubleValue();						this.targetPoints[0][0] = new Double(token[8]).doubleValue();						this.targetPoints[0][1] = new Double(token[9]).doubleValue();						this.sourcePoints[1][0] = new Double(token[10]).doubleValue();						this.sourcePoints[1][1] = new Double(token[11]).doubleValue();						this.targetPoints[1][0] = new Double(token[12]).doubleValue();						this.targetPoints[1][1] = new Double(token[13]).doubleValue();						this.sourcePoints[2][0] = new Double(token[14]).doubleValue();						this.sourcePoints[2][1] = new Double(token[15]).doubleValue();						this.targetPoints[2][0] = new Double(token[16]).doubleValue();						this.targetPoints[2][1] = new Double(token[17]).doubleValue();						this.sourcePoints[3][0] = new Double(token[18]).doubleValue();						this.sourcePoints[3][1] = new Double(token[19]).doubleValue();						this.targetPoints[3][0] = new Double(token[20]).doubleValue();						this.targetPoints[3][1] = new Double(token[21]).doubleValue();						interactive = this.getInteractive(token[22]);						break;					}					default:					{												IJ.error("Invalid transformation");						return;					}				}			}			catch (NumberFormatException e)			{								IJ.log("Number format exception " + e.getMessage());				IJ.error("Invalid syntax");				System.out.println("   TurboReg_ ---> Invalid syntax ");				return;			}			if(interactive == null)			{								IJ.error("Invalid directive for interactivity");				System.out.println("   TurboReg_ ---> Invalid interactivity parameter ");				return;			}			this.transformedImage = this.transformImage(source, outputWidth, outputHeight, transformation, interactive.booleanValue(), null);			// transformedImage.show();		}		else		{						IJ.error("Invalid operation");			return;		}	} /* end run */		/*	 * .................................................................... Private methods ....................................................................	 */		/*------------------------------------------------------------------*/	public ImagePlus alignImages(final ImagePlus source, final int[] sourceCrop, final ImagePlus target, final int[] targetCrop, final int transformation, final boolean interactive, final String filename)	{		if((source.getType() != ImagePlus.GRAY16) && (source.getType() != ImagePlus.GRAY32) && ((source.getType() != ImagePlus.GRAY8) || source.getStack().isRGB() || source.getStack().isHSB()))		{			IJ.error(source.getTitle() + " should be grayscale (8, 16, or 32 bit)");			return (null);		}		if((target.getType() != ImagePlus.GRAY16) && (target.getType() != ImagePlus.GRAY32) && ((target.getType() != ImagePlus.GRAY8) || target.getStack().isRGB() || target.getStack().isHSB()))		{			IJ.error(target.getTitle() + " should be grayscale (8, 16, or 32 bit)");			return (null);		}		source.setRoi(sourceCrop[0], sourceCrop[1], sourceCrop[2], sourceCrop[3]);		target.setRoi(targetCrop[0], targetCrop[1], targetCrop[2], targetCrop[3]);		source.setSlice(1);		target.setSlice(1);		final ImagePlus sourceImp = new ImagePlus("source", source.getProcessor().crop());		final ImagePlus targetImp = new ImagePlus("target", target.getProcessor().crop());		final turboRegImage sourceImg = new turboRegImage(sourceImp, transformation, false);		final turboRegImage targetImg = new turboRegImage(targetImp, transformation, true);		final int pyramidDepth = this.getPyramidDepth(sourceImp.getWidth(), sourceImp.getHeight(), targetImp.getWidth(), targetImp.getHeight());		sourceImg.setPyramidDepth(pyramidDepth);		targetImg.setPyramidDepth(pyramidDepth);		sourceImg.getThread().start();		targetImg.getThread().start();		if(2 <= source.getStackSize())		{			source.setSlice(2);		}		if(2 <= target.getStackSize())		{			target.setSlice(2);		}		final ImagePlus sourceMskImp = new ImagePlus("source mask", source.getProcessor().crop());		final ImagePlus targetMskImp = new ImagePlus("target mask", target.getProcessor().crop());		final turboRegMask sourceMsk = new turboRegMask(sourceMskImp);		final turboRegMask targetMsk = new turboRegMask(targetMskImp);		source.setSlice(1);		target.setSlice(1);		if(source.getStackSize() < 2)		{			sourceMsk.clearMask();		}		if(target.getStackSize() < 2)		{			targetMsk.clearMask();		}		sourceMsk.setPyramidDepth(pyramidDepth);		targetMsk.setPyramidDepth(pyramidDepth);		sourceMsk.getThread().start();		targetMsk.getThread().start();		switch (transformation)		{			case turboRegDialog.TRANSLATION:			{				this.sourcePoints[0][0] -= sourceCrop[0];				this.sourcePoints[0][1] -= sourceCrop[1];				this.targetPoints[0][0] -= targetCrop[0];				this.targetPoints[0][1] -= targetCrop[1];				break;			}			case turboRegDialog.SCALED_ROTATION:			{				for (int k = 0; (k < 2); k++)				{					this.sourcePoints[k][0] -= sourceCrop[0];					this.sourcePoints[k][1] -= sourceCrop[1];					this.targetPoints[k][0] -= targetCrop[0];					this.targetPoints[k][1] -= targetCrop[1];				}				break;			}			case turboRegDialog.RIGID_BODY:			case turboRegDialog.AFFINE:			{				for (int k = 0; (k < 3); k++)				{					this.sourcePoints[k][0] -= sourceCrop[0];					this.sourcePoints[k][1] -= sourceCrop[1];					this.targetPoints[k][0] -= targetCrop[0];					this.targetPoints[k][1] -= targetCrop[1];				}				break;			}			case turboRegDialog.BILINEAR:			{				for (int k = 0; (k < 4); k++)				{					this.sourcePoints[k][0] -= sourceCrop[0];					this.sourcePoints[k][1] -= sourceCrop[1];					this.targetPoints[k][0] -= targetCrop[0];					this.targetPoints[k][1] -= targetCrop[1];				}				break;			}		}		final turboRegPointHandler sourcePh = new turboRegPointHandler(sourceImp, transformation);		final turboRegPointHandler targetPh = new turboRegPointHandler(targetImp, transformation);		sourcePh.setPoints(this.sourcePoints);		targetPh.setPoints(this.targetPoints);		try		{			sourceMsk.getThread().join();			targetMsk.getThread().join();			sourceImg.getThread().join();			targetImg.getThread().join();		}		catch (InterruptedException e)		{			IJ.log("Unexpected interruption exception " + e.getMessage());		}		final turboRegFinalAction finalAction = new turboRegFinalAction(sourceImg, sourceMsk, sourcePh, targetImg, targetMsk, targetPh, transformation);		finalAction.getThread().start();		try		{			finalAction.getThread().join();		}		catch (InterruptedException e)		{			IJ.log("Unexpected interruption exception " + e.getMessage());		}		this.sourcePoints = sourcePh.getPoints();		this.targetPoints = targetPh.getPoints();		final ResultsTable table = Analyzer.getResultsTable();		table.reset();		switch (transformation)		{			case turboRegDialog.TRANSLATION:			{				table.incrementCounter();				this.sourcePoints[0][0] += sourceCrop[0];				table.addValue("sourceX", this.sourcePoints[0][0]);				this.sourcePoints[0][1] += sourceCrop[1];				table.addValue("sourceY", this.sourcePoints[0][1]);				this.targetPoints[0][0] += targetCrop[0];				table.addValue("targetX", this.targetPoints[0][0]);				this.targetPoints[0][1] += targetCrop[1];				table.addValue("targetY", this.targetPoints[0][1]);				break;			}			case turboRegDialog.SCALED_ROTATION:			{				for (int k = 0; (k < 2); k++)				{					table.incrementCounter();					this.sourcePoints[k][0] += sourceCrop[0];					table.addValue("sourceX", this.sourcePoints[k][0]);					this.sourcePoints[k][1] += sourceCrop[1];					table.addValue("sourceY", this.sourcePoints[k][1]);					this.targetPoints[k][0] += targetCrop[0];					table.addValue("targetX", this.targetPoints[k][0]);					this.targetPoints[k][1] += targetCrop[1];					table.addValue("targetY", this.targetPoints[k][1]);				}				break;			}			case turboRegDialog.RIGID_BODY:			case turboRegDialog.AFFINE:			{				for (int k = 0; (k < 3); k++)				{					table.incrementCounter();					this.sourcePoints[k][0] += sourceCrop[0];					table.addValue("sourceX", this.sourcePoints[k][0]);					this.sourcePoints[k][1] += sourceCrop[1];					table.addValue("sourceY", this.sourcePoints[k][1]);					this.targetPoints[k][0] += targetCrop[0];					table.addValue("targetX", this.targetPoints[k][0]);					this.targetPoints[k][1] += targetCrop[1];					table.addValue("targetY", this.targetPoints[k][1]);				}				break;			}			case turboRegDialog.BILINEAR:			{				for (int k = 0; (k < 4); k++)				{					table.incrementCounter();					this.sourcePoints[k][0] += sourceCrop[0];					table.addValue("sourceX", this.sourcePoints[k][0]);					this.sourcePoints[k][1] += sourceCrop[1];					table.addValue("sourceY", this.sourcePoints[k][1]);					this.targetPoints[k][0] += targetCrop[0];					table.addValue("targetX", this.targetPoints[k][0]);					this.targetPoints[k][1] += targetCrop[1];					table.addValue("targetY", this.targetPoints[k][1]);				}				break;			}		}		if(interactive)		{			table.show("Refined Landmarks");		}		source.killRoi();		target.killRoi();		return (this.transformImage(source, target.getWidth(), target.getHeight(), transformation, interactive, filename));	} /* end alignImages */		/*------------------------------------------------------------------*/	private ImagePlus[] createAdmissibleImageList()	{		final int[] windowList = WindowManager.getIDList();		final Stack<ImagePlus> stack = new Stack<ImagePlus>();		for (int k = 0; ((windowList != null) && (k < windowList.length)); k++)		{			final ImagePlus imp = WindowManager.getImage(windowList[k]);			if((imp != null) && ((imp.getType() == ImagePlus.GRAY16) || (imp.getType() == ImagePlus.GRAY32) || ((imp.getType() == ImagePlus.GRAY8) && !imp.getStack().isHSB())))			{				stack.push(imp);			}		}		final ImagePlus[] admissibleImageList = new ImagePlus[stack.size()];		int k = 0;		while (!stack.isEmpty())		{			admissibleImageList[k++] = stack.pop();		}		return (admissibleImageList);	} /* end createAdmissibleImageList */		/*------------------------------------------------------------------*/	private void dumpSyntax(final String options)	{		IJ.log(options);		IJ.log("");		IJ.log("___");		IJ.log("");		IJ.log("ARGUMENTS: { -help | -align | -transform }");		IJ.log("");		IJ.log("-help SHOWS THIS MESSAGE");		IJ.log("");		IJ.log("-align");		IJ.log("{ -file | -window }");		IJ.log("  sourceFilename STRING WITH OPTIONAL QUOTES");		IJ.log("  sourceWindowTitle STRING WITH OPTIONAL QUOTES");		IJ.log("sourceCropLeft INTEGER");		IJ.log("sourceCropTop INTEGER");		IJ.log("sourceCropRight INTEGER");		IJ.log("sourceCropBottom INTEGER");		IJ.log("{ -file | -window }");		IJ.log("  targetFilename STRING WITH OPTIONAL QUOTES");		IJ.log("  targetWindowTitle STRING WITH OPTIONAL QUOTES");		IJ.log("targetCropLeft INTEGER");		IJ.log("targetCropTop INTEGER");		IJ.log("targetCropRight INTEGER");		IJ.log("targetCropBottom INTEGER");		IJ.log("{ -translation | -rigidBody | -scaledRotation | -affine | -bilinear }");		IJ.log("sourcePointsX[<*>] FLOATING-POINT");		IJ.log("sourcePointsY[<*>] FLOATING-POINT");		IJ.log("targetPointsX[<*>] FLOATING-POINT");		IJ.log("targetPointsY[<*>] FLOATING-POINT");		IJ.log("{ -hideOutput | -showOutput }");		IJ.log("");		IJ.log("-transform");		IJ.log("{ -file | -window }");		IJ.log("  sourceFilename STRING WITH OPTIONAL QUOTES");		IJ.log("  sourceWindowTitle STRING WITH OPTIONAL QUOTES");		IJ.log("outputWidth INTEGER");		IJ.log("outputHeight INTEGER");		IJ.log("{ -translation | -rigidBody | -scaledRotation | -affine | -bilinear }");		IJ.log("sourcePointsX[<*>] FLOATING-POINT");		IJ.log("sourcePointsY[<*>] FLOATING-POINT");		IJ.log("targetPointsX[<*>] FLOATING-POINT");		IJ.log("targetPointsY[<*>] FLOATING-POINT");		IJ.log("{ -hideOutput | -showOutput }");		IJ.log("");		IJ.log("<*> FOR TRANSLATION: 1 BLOCK OF FOUR COORDINATES");		IJ.log("<*> FOR RIGID-BODY: 3 BLOCKS OF FOUR COORDINATES");		IJ.log("<*> FOR SCALED-ROTATION: 2 BLOCKS OF FOUR COORDINATES");		IJ.log("<*> FOR AFFINE: 3 BLOCKS OF FOUR COORDINATES");		IJ.log("<*> FOR BILINEAR: 4 BLOCKS OF FOUR COORDINATES");		IJ.log("");		IJ.log("~~~");	} /* end dumpSyntax */		/*------------------------------------------------------------------*/	private Boolean getInteractive(final String token)	{		if(token.equals("-hideOutput"))		{			return (new Boolean(false));		}		else if(token.equals("-showOutput"))		{			return (new Boolean(true));		}		else		{			return (null);		}	} /* end getInteractive */		/*------------------------------------------------------------------*/	private int getPyramidDepth(int sw, int sh, int tw, int th)	{		int pyramidDepth = 1;		while (((2 * turboRegDialog.MIN_SIZE) <= sw) && ((2 * turboRegDialog.MIN_SIZE) <= sh) && ((2 * turboRegDialog.MIN_SIZE) <= tw) && ((2 * turboRegDialog.MIN_SIZE) <= th))		{			sw /= 2;			sh /= 2;			tw /= 2;			th /= 2;			pyramidDepth++;		}		return (pyramidDepth);	} /* end getPyramidDepth */		/*------------------------------------------------------------------*/	private String[] getTokens(String options)	{		final String fileSeparator = System.getProperty("file.separator");		if(fileSeparator.equals("\\"))		{			options = options.replaceAll("\\\\", "/");		}		else		{			options = options.replaceAll(fileSeparator, "/");		}		String[] token = new String[0];		final StringReader sr = new StringReader(options);		final StreamTokenizer st = new StreamTokenizer(sr);		st.resetSyntax();		st.whitespaceChars(0, ' ');		st.wordChars('!', 255);		st.quoteChar('\"');		final Vector<String> v = new Vector<String>();		try		{			while (st.nextToken() != StreamTokenizer.TT_EOF)			{				v.add(new String(st.sval));			}		}		catch (IOException e)		{			IJ.log("IOException exception " + e.getMessage());			return (token);		}		token = v.toArray(token);		return (token);	} /* end getTokens */		/*------------------------------------------------------------------*/	private int getTransformation(final String token)	{		if(token.equals("-translation"))		{			return (turboRegDialog.TRANSLATION);		}		else if(token.equals("-rigidBody"))		{			return (turboRegDialog.RIGID_BODY);		}		else if(token.equals("-scaledRotation"))		{			return (turboRegDialog.SCALED_ROTATION);		}		else if(token.equals("-affine"))		{			return (turboRegDialog.AFFINE);		}		else if(token.equals("-bilinear"))		{			return (turboRegDialog.BILINEAR);		}		else		{			return (turboRegDialog.GENERIC_TRANSFORMATION);		}	} /* end getTransformation */		/*------------------------------------------------------------------*/	public ImagePlus transformImage(final ImagePlus source, final int width, final int height, final int transformation, final boolean interactive, final String filename)	{		if((source.getType() != ImagePlus.GRAY16) && (source.getType() != ImagePlus.GRAY32) && ((source.getType() != ImagePlus.GRAY8) || source.getStack().isRGB() || source.getStack().isHSB()))		{			IJ.error(source.getTitle() + " should be grayscale (8, 16, or 32 bit)");			return (null);		}		source.setSlice(1);		final turboRegImage sourceImg = new turboRegImage(source, turboRegDialog.GENERIC_TRANSFORMATION, false);		sourceImg.getThread().start();		if(2 <= source.getStackSize())		{			source.setSlice(2);		}		final turboRegMask sourceMsk = new turboRegMask(source);		source.setSlice(1);		if(source.getStackSize() < 2)		{			sourceMsk.clearMask();		}		final turboRegPointHandler sourcePh = new turboRegPointHandler(this.sourcePoints, transformation);		final turboRegPointHandler targetPh = new turboRegPointHandler(this.targetPoints, transformation);		try		{			sourceImg.getThread().join();		}		catch (InterruptedException e)		{			IJ.log("Unexpected interruption exception " + e.getMessage());		}		final turboRegTransform regTransform = new turboRegTransform(sourceImg, sourceMsk, sourcePh, null, null, targetPh, transformation, false, false);		final ImagePlus transformedImage = regTransform.doFinalTransform(width, height, filename);		if(interactive)		{			transformedImage.setSlice(1);			transformedImage.getProcessor().resetMinAndMax();			transformedImage.show();			transformedImage.updateAndDraw();		}		return (transformedImage);	} /* end transformImage */	} /* end class TurboReg_ *//* * ==================================================================== | turboRegCredits \=================================================================== *//********************************************************************* * This class creates the credits dialog. ********************************************************************/class turboRegCredits extends Dialog{ /* begin class turboRegCredits */		private static final long serialVersionUID = 1L;		/*	 * .................................................................... Public methods ....................................................................	 */		/*********************************************************************	 * Return some additional margin to the dialog, for aesthetic purposes. Necessary for the current MacOS X Java version, lest the first item disappears from the frame.	 ********************************************************************/	@Override	public Insets getInsets()	{		return (new Insets(0, 20, 20, 20));	} /* end getInsets */		/*********************************************************************	 * This constructor prepares the dialog box.	 * 	 * @param parentWindow	 *            Parent window.	 ********************************************************************/	public turboRegCredits(final Frame parentWindow)	{		super(parentWindow, "TurboReg", true);		this.setLayout(new BorderLayout(0, 20));		final Label separation = new Label("");		final Panel buttonPanel = new Panel();		buttonPanel.setLayout(new FlowLayout(FlowLayout.CENTER));		final Button doneButton = new Button("Done");		doneButton.addActionListener(new ActionListener() {						@Override			public void actionPerformed(final ActionEvent ae)			{				if(ae.getActionCommand().equals("Done"))				{					turboRegCredits.this.dispose();				}			}		});		buttonPanel.add(doneButton);		final TextArea text = new TextArea(26, 72);		text.setEditable(false);		text.append(" \n");		text.append(" This TurboReg version is dated June 19, 2008\n");		text.append(" \n");		text.append(" ###\n");		text.append(" \n");		text.append(" This work is based on the following paper:\n");		text.append("\n");		text.append(" P. Th\u00E9venaz, U.E. Ruttimann, M. Unser\n");		text.append(" A Pyramid Approach to Subpixel Registration Based on Intensity\n");		text.append(" IEEE Transactions on Image Processing\n");		text.append(" vol. 7, no. 1, pp. 27-41, January 1998.\n");		text.append("\n");		text.append(" This paper is available on-line at\n");		text.append(" http://bigwww.epfl.ch/publications/thevenaz9801.html\n");		text.append("\n");		text.append(" Other relevant on-line publications are available at\n");		text.append(" http://bigwww.epfl.ch/publications/\n");		text.append("\n");		text.append(" Additional help available at\n");		text.append(" http://bigwww.epfl.ch/thevenaz/turboreg/\n");		text.append("\n");		text.append(" You'll be free to use this software for research purposes, but\n");		text.append(" you should not redistribute it without our consent. In addition,\n");		text.append(" we expect you to include a citation or acknowledgment whenever\n");		text.append(" you present or publish results that are based on it.\n");		this.add("North", separation);		this.add("Center", text);		this.add("South", buttonPanel);		this.pack();	} /* end turboRegCredits */	} /* end class turboRegCredits *//* * ==================================================================== | turboRegDialog \=================================================================== *//********************************************************************* * This class creates the main dialog. ********************************************************************/class turboRegDialog extends Dialog implements ActionListener {		private static final long serialVersionUID = 1L;		/* begin class turboRegDialog */		/*	 * .................................................................... Public variables ....................................................................	 */		/*********************************************************************	 * Three points generate an affine transformation, which is any combination of translation, rotation, isotropic scaling, anisotropic scaling, shearing, and skewing. An affine transformation maps parallel lines onto parallel lines and is	 * determined by 6 parameters.	 ********************************************************************/	public static final int AFFINE = 6;		/*********************************************************************	 * Generic geometric transformation.	 ********************************************************************/	public static final int GENERIC_TRANSFORMATION = -1;		/*********************************************************************	 * Four points describe a bilinear transformation, where a point of coordinates (x, y) is mapped on a point of coordinates (u, v) such that u = p0 + p1 x + p2 y + p3 x y and v = q0 + q1 x + q2 y + q3 x y. Thus, u and v are both linear in x, and	 * in y as well. The bilinear transformation is determined by 8 parameters.	 ********************************************************************/	public static final int BILINEAR = 8;		/*********************************************************************	 * Blue slice.	 ********************************************************************/	public static final int BLUE = 3;		/*********************************************************************	 * Graylevel slice.	 ********************************************************************/	public static final int BLACK = 0;		/*********************************************************************	 * Green slice.	 ********************************************************************/	public static final int GREEN = 2;		/*********************************************************************	 * Minimal linear dimension of an image in the multiresolution pyramid.	 ********************************************************************/	public static final int MIN_SIZE = 12;		/*********************************************************************	 * Red slice.	 ********************************************************************/	public static final int RED = 1;		/*********************************************************************	 * A single points determines the translation component of a rigid-body transformation. As the rotation is given by a scalar number, it is not natural to represent this number by coordinates of a point. The rigid-body transformation is determined	 * by 3 parameters.	 ********************************************************************/	public static final int RIGID_BODY = 3;		/*********************************************************************	 * A pair of points determines the combination of a translation, of a rotation, and of an isotropic scaling. Angles are conserved. A scaled rotation is determined by 4 parameters.	 ********************************************************************/	public static final int SCALED_ROTATION = 4;		/*********************************************************************	 * A translation is described by a single point. It keeps area, angle, and orientation. A translation is determined by 2 parameters.	 ********************************************************************/	public static final int TRANSLATION = 2;		/*	 * .................................................................... Private variables ....................................................................	 */		/*********************************************************************	 * Admissible values are {<code>TRANSLATION</code>, <code>RIGID_BODY</code>, <code>SCALED_ROTATION</code>, <code>AFFINE</code>, <code>BILINEAR<code>}.	 ********************************************************************/	private static int transformation = RIGID_BODY;	private static int sourceColorPlane = BLACK;	private static int targetColorPlane = BLACK;	private static boolean saveOnExit = false;	private static boolean accelerated = true;	private final turboRegFinalAction finalAction = new turboRegFinalAction(this);	private final turboRegPointToolbar tb = new turboRegPointToolbar(Toolbar.getInstance());	private final Button automaticButton = new Button("Automatic");	private final Button batchButton = new Button("Batch");	private final CheckboxGroup sourceKrgbGroup = new CheckboxGroup();	private final Checkbox sourceBlack = new Checkbox("K", this.sourceKrgbGroup, sourceColorPlane == BLACK);	private final Checkbox sourceRed = new Checkbox("R", this.sourceKrgbGroup, sourceColorPlane == RED);	private final Checkbox sourceGreen = new Checkbox("G", this.sourceKrgbGroup, sourceColorPlane == GREEN);	private final Checkbox sourceBlue = new Checkbox("B", this.sourceKrgbGroup, sourceColorPlane == BLUE);	private final CheckboxGroup targetKrgbGroup = new CheckboxGroup();	private final Checkbox targetBlack = new Checkbox("K", this.targetKrgbGroup, targetColorPlane == BLACK);	private final Checkbox targetRed = new Checkbox("R", this.targetKrgbGroup, targetColorPlane == RED);	private final Checkbox targetGreen = new Checkbox("G", this.targetKrgbGroup, targetColorPlane == GREEN);	private final Checkbox targetBlue = new Checkbox("B", this.targetKrgbGroup, targetColorPlane == BLUE);	private final CheckboxGroup transformationGroup = new CheckboxGroup();	private final Checkbox translation = new Checkbox("Translation", this.transformationGroup, transformation == TRANSLATION);	private final Checkbox rigidBody = new Checkbox("Rigid Body", this.transformationGroup, transformation == RIGID_BODY);	private final Checkbox scaledRotation = new Checkbox("Scaled Rotation", this.transformationGroup, transformation == SCALED_ROTATION);	private final Checkbox affine = new Checkbox("Affine", this.transformationGroup, transformation == AFFINE);	private final Checkbox bilinear = new Checkbox("Bilinear", this.transformationGroup, transformation == BILINEAR);	private ImagePlus[] admissibleImageList;	private ImageCanvas sourceIc;	private ImageCanvas targetIc;	private ImagePlus sourceImp;	private ImagePlus targetImp;	private Scrollbar sourceScrollbar;	private Scrollbar targetScrollbar;	private turboRegImage sourceImg;	private turboRegImage targetImg;	private turboRegMask sourceMsk;	private turboRegMask targetMsk;	private turboRegPointAction sourcePa;	private turboRegPointAction targetPa;	private turboRegPointHandler sourcePh;	private turboRegPointHandler targetPh;	private int sourceChoiceIndex = 0;	private int targetChoiceIndex = 1;	private int pyramidDepth;		/*	 * .................................................................... Public methods ....................................................................	 */		/*********************************************************************	 * This method processes the button actions.	 * 	 * @param ae	 *            The expected actions are as follows:	 *            <ul>	 *            <li><code>Load...</code>: Load landmarks from a file;</li>	 *            <li><code>Save Now...</code>: Save landmarks into a file;</li>	 *            <li><code>Cancel</code>: Restore the progress bar and the toolbar, reset the ROI's, and then quit;</li>	 *            <li><code>Manual</code>: Create an output image that is distorted in such a way that the landmarks of the source are made to coincide with those of the target;</li>	 *            <li><code>Automatic</code>: Refine the landmarks of the source image in such a way that the least-squares error between the transformed source image and the target is minimized.</li>	 *            </ul>	 ********************************************************************/	@Override	public void actionPerformed(final ActionEvent ae)	{		if(ae.getActionCommand().equals("Load..."))		{			if(!this.loadLandmarks())			{				IJ.error("Invalid Landmarks");			}		}		else if(ae.getActionCommand().equals("Save Now..."))		{			final turboRegTransform tt = new turboRegTransform(this.sourceImg, this.sourceMsk, this.sourcePh, this.targetImg, this.targetMsk, this.targetPh, transformation, accelerated, true);			tt.saveTransformation(null);		}		else if(ae.getActionCommand().equals("Cancel"))		{			this.dispose();			this.restoreAll();		}		else if(ae.getActionCommand().equals("Manual"))		{			this.dispose();			if(this.sourceImp.getStack().isRGB())			{				this.finalAction.setup(this.sourceImp, this.sourceImg, this.sourceMsk, this.sourcePh, sourceColorPlane, this.targetImg, this.targetMsk, this.targetPh, transformation, accelerated, saveOnExit, turboRegFinalAction.MANUAL);			}			else			{				this.finalAction.setup(this.sourceImg, this.sourceMsk, this.sourcePh, this.targetImg, this.targetMsk, this.targetPh, transformation, accelerated, saveOnExit, turboRegFinalAction.MANUAL);			}			this.finalAction.getThread().start();		}		else if(ae.getActionCommand().equals("Automatic"))		{			this.dispose();			if(this.sourceImp.getStack().isRGB())			{				this.finalAction.setup(this.sourceImp, this.sourceImg, this.sourceMsk, this.sourcePh, sourceColorPlane, this.targetImg, this.targetMsk, this.targetPh, transformation, accelerated, saveOnExit, turboRegFinalAction.AUTOMATIC);			}			else			{				this.finalAction.setup(this.sourceImg, this.sourceMsk, this.sourcePh, this.targetImg, this.targetMsk, this.targetPh, transformation, accelerated, saveOnExit, turboRegFinalAction.AUTOMATIC);			}			this.finalAction.getThread().start();		}		else if(ae.getActionCommand().equals("Batch"))		{			this.dispose();			this.finalAction.setup(this.sourceImp, this.sourceImg, this.sourcePh, this.targetImp, this.targetImg, this.targetMsk, this.targetPh, transformation, accelerated, saveOnExit, this.pyramidDepth);			this.finalAction.getThread().start();		}		else if(ae.getActionCommand().equals("Credits..."))		{			final turboRegCredits dialog = new turboRegCredits(IJ.getInstance());			GUI.center(dialog);			dialog.setVisible(true);		}	} /* end actionPerformed */		/*********************************************************************	 * Return some additional margin to the dialog, for aesthetic purposes. Necessary for the current MacOS X Java version, lest the first item disappears from the frame.	 ********************************************************************/	@Override	public Insets getInsets()	{		return (new Insets(0, 20, 20, 20));	} /* end getInsets */		/*********************************************************************	 * Wait until the threads that compute spline coefficients, image and mask pyramids are done.	 ********************************************************************/	public void joinThreads()	{		try		{			this.sourceImg.getThread().join();			this.sourceMsk.getThread().join();			this.targetImg.getThread().join();			this.targetMsk.getThread().join();		}		catch (InterruptedException e)		{			IJ.log("Unexpected interruption exception " + e.getMessage());		}	} /* end joinThreads */		/*********************************************************************	 * Restore the regular listener interfaces, restore the regular ImageJ toolbar, stop the progress bar, and ask for garbage collection.	 * 	 * @see turboRegDialog#cancelImages()	 ********************************************************************/	public void restoreAll()	{		this.cancelImages();		this.tb.restorePreviousToolbar();		Toolbar.getInstance().repaint();		turboRegProgressBar.resetProgressBar();		Runtime.getRuntime().gc();	} /* end restoreAll */		/*********************************************************************	 * Interrupt the two preprocessing threads.	 ********************************************************************/	public void stopThreads()	{		this.stopSourceThreads();		this.stopTargetThreads();	} /* end stopThreads */		/*********************************************************************	 * This constructor prepares the dialog box and starts the first computational threads. The threads will need to be killed and restarted upon need. This constructor must be called when at least two images are available.	 * 	 * @param parentWindow	 *            Parent window.	 * @param admissibleImageList	 *            Array of <code>ImagePlus</code> images that are candidate to registration.	 ********************************************************************/	public turboRegDialog(final Frame parentWindow, final ImagePlus[] admissibleImageList)	{		super(parentWindow, "TurboReg", false);		this.admissibleImageList = admissibleImageList;		this.defaultSourceColorPlane();		this.defaultTargetColorPlane();		this.createImages();		this.startThreads();		this.setLayout(new GridLayout(0, 1));		final Choice sourceChoice = new Choice();		for (int k = 0; (k < admissibleImageList.length); k++)		{			sourceChoice.add(admissibleImageList[k].getTitle());		}		sourceChoice.select(this.sourceChoiceIndex);		final Choice targetChoice = new Choice();		for (int k = 0; (k < admissibleImageList.length); k++)		{			targetChoice.add(admissibleImageList[k].getTitle());		}		targetChoice.select(this.targetChoiceIndex);		final Panel sourcePanel = new Panel();		sourcePanel.setLayout(new FlowLayout(FlowLayout.CENTER));		sourceChoice.addItemListener(new ItemListener() {						@Override			public void itemStateChanged(final ItemEvent ie)			{				final int newChoiceIndex = sourceChoice.getSelectedIndex();				if(turboRegDialog.this.sourceChoiceIndex != newChoiceIndex)				{					if(turboRegDialog.this.targetChoiceIndex != newChoiceIndex)					{						turboRegDialog.this.sourceChoiceIndex = newChoiceIndex;						turboRegDialog.this.cancelSource();						turboRegDialog.this.defaultSourceColorPlane();						turboRegDialog.this.createSourceImages();						turboRegDialog.this.startSourceThreads();					}					else					{						turboRegDialog.this.targetChoiceIndex = turboRegDialog.this.sourceChoiceIndex;						turboRegDialog.this.sourceChoiceIndex = newChoiceIndex;						targetChoice.select(turboRegDialog.this.targetChoiceIndex);						turboRegDialog.this.permuteImages();						turboRegDialog.this.startThreads();					}					turboRegDialog.this.sourcePa.setSecondaryPointHandler(turboRegDialog.this.targetImp, turboRegDialog.this.targetPh);					turboRegDialog.this.targetPa.setSecondaryPointHandler(turboRegDialog.this.sourceImp, turboRegDialog.this.sourcePh);					turboRegDialog.this.batchButton.setEnabled((1 < turboRegDialog.this.sourceImp.getStackSize()) && !(turboRegDialog.this.sourceImp.getStack().isRGB() || turboRegDialog.this.targetImp.getStack().isRGB()));				}				turboRegDialog.this.repaint();			}		});		this.sourceRed.addItemListener(new ItemListener() {						@Override			public void itemStateChanged(final ItemEvent ie)			{				if(turboRegDialog.this.sourceKrgbGroup.getSelectedCheckbox().getLabel().equals("R") && (sourceColorPlane != RED))				{					turboRegDialog.this.sourceKrgbGroup.setSelectedCheckbox(turboRegDialog.this.sourceRed);					turboRegDialog.this.stopSourceThreads();					turboRegDialog.this.setSourceColorPlane(RED);					turboRegDialog.this.startSourceThreads();				}				turboRegDialog.this.repaint();			}		});		this.sourceGreen.addItemListener(new ItemListener() {						@Override			public void itemStateChanged(final ItemEvent ie)			{				if(turboRegDialog.this.sourceKrgbGroup.getSelectedCheckbox().getLabel().equals("G") && (sourceColorPlane != GREEN))				{					turboRegDialog.this.sourceKrgbGroup.setSelectedCheckbox(turboRegDialog.this.sourceGreen);					turboRegDialog.this.stopSourceThreads();					turboRegDialog.this.setSourceColorPlane(GREEN);					turboRegDialog.this.startSourceThreads();				}				turboRegDialog.this.repaint();			}		});		this.sourceBlue.addItemListener(new ItemListener() {						@Override			public void itemStateChanged(final ItemEvent ie)			{				if(turboRegDialog.this.sourceKrgbGroup.getSelectedCheckbox().getLabel().equals("B") && (sourceColorPlane != BLUE))				{					turboRegDialog.this.sourceKrgbGroup.setSelectedCheckbox(turboRegDialog.this.sourceBlue);					turboRegDialog.this.stopSourceThreads();					turboRegDialog.this.setSourceColorPlane(BLUE);					turboRegDialog.this.startSourceThreads();				}				turboRegDialog.this.repaint();			}		});		final Label sourceLabel = new Label("Source: ");		sourcePanel.add(sourceLabel);		sourcePanel.add(sourceChoice);		sourcePanel.add(this.sourceRed);		sourcePanel.add(this.sourceGreen);		sourcePanel.add(this.sourceBlue);		sourcePanel.add(this.sourceBlack);		final Panel targetPanel = new Panel();		targetPanel.setLayout(new FlowLayout(FlowLayout.CENTER));		targetChoice.addItemListener(new ItemListener() {						@Override			public void itemStateChanged(final ItemEvent ie)			{				final int newChoiceIndex = targetChoice.getSelectedIndex();				if(turboRegDialog.this.targetChoiceIndex != newChoiceIndex)				{					if(turboRegDialog.this.sourceChoiceIndex != newChoiceIndex)					{						turboRegDialog.this.targetChoiceIndex = newChoiceIndex;						turboRegDialog.this.cancelTarget();						turboRegDialog.this.defaultTargetColorPlane();						turboRegDialog.this.createTargetImages();						turboRegDialog.this.startTargetThreads();					}					else					{						turboRegDialog.this.sourceChoiceIndex = turboRegDialog.this.targetChoiceIndex;						turboRegDialog.this.targetChoiceIndex = newChoiceIndex;						sourceChoice.select(turboRegDialog.this.sourceChoiceIndex);						turboRegDialog.this.permuteImages();						turboRegDialog.this.startThreads();					}					turboRegDialog.this.sourcePa.setSecondaryPointHandler(turboRegDialog.this.targetImp, turboRegDialog.this.targetPh);					turboRegDialog.this.targetPa.setSecondaryPointHandler(turboRegDialog.this.sourceImp, turboRegDialog.this.sourcePh);					turboRegDialog.this.batchButton.setEnabled((1 < turboRegDialog.this.sourceImp.getStackSize()) && !(turboRegDialog.this.sourceImp.getStack().isRGB() || turboRegDialog.this.targetImp.getStack().isRGB()));				}				turboRegDialog.this.repaint();			}		});		this.targetRed.addItemListener(new ItemListener() {						@Override			public void itemStateChanged(final ItemEvent ie)			{				if(turboRegDialog.this.targetKrgbGroup.getSelectedCheckbox().getLabel().equals("R") && (targetColorPlane != RED))				{					turboRegDialog.this.targetKrgbGroup.setSelectedCheckbox(turboRegDialog.this.targetRed);					turboRegDialog.this.stopTargetThreads();					turboRegDialog.this.setTargetColorPlane(RED);					turboRegDialog.this.startTargetThreads();				}				turboRegDialog.this.repaint();			}		});		this.targetGreen.addItemListener(new ItemListener() {						@Override			public void itemStateChanged(final ItemEvent ie)			{				if(turboRegDialog.this.targetKrgbGroup.getSelectedCheckbox().getLabel().equals("G") && (targetColorPlane != GREEN))				{					turboRegDialog.this.targetKrgbGroup.setSelectedCheckbox(turboRegDialog.this.targetGreen);					turboRegDialog.this.stopTargetThreads();					turboRegDialog.this.setTargetColorPlane(GREEN);					turboRegDialog.this.startTargetThreads();				}				turboRegDialog.this.repaint();			}		});		this.targetBlue.addItemListener(new ItemListener() {						@Override			public void itemStateChanged(final ItemEvent ie)			{				if(turboRegDialog.this.targetKrgbGroup.getSelectedCheckbox().getLabel().equals("B") && (targetColorPlane != BLUE))				{					turboRegDialog.this.targetKrgbGroup.setSelectedCheckbox(turboRegDialog.this.targetBlue);					turboRegDialog.this.stopTargetThreads();					turboRegDialog.this.setTargetColorPlane(BLUE);					turboRegDialog.this.startTargetThreads();				}				turboRegDialog.this.repaint();			}		});		final Label targetLabel = new Label("Target: ");		targetPanel.add(targetLabel);		targetPanel.add(targetChoice);		targetPanel.add(this.targetRed);		targetPanel.add(this.targetGreen);		targetPanel.add(this.targetBlue);		targetPanel.add(this.targetBlack);		final Panel transformationPanel = new Panel();		transformationPanel.setLayout(new FlowLayout(FlowLayout.CENTER));		this.translation.addItemListener(new ItemListener() {						@Override			public void itemStateChanged(final ItemEvent ie)			{				if(turboRegDialog.this.transformationGroup.getSelectedCheckbox().getLabel().equals("Translation") && (transformation != TRANSLATION))				{					if(transformation == BILINEAR)					{						transformation = TRANSLATION;						turboRegDialog.this.cancelImages();						turboRegDialog.this.createImages();						turboRegDialog.this.startThreads();					}					else					{						transformation = TRANSLATION;						turboRegDialog.this.setTransformation();					}				}				turboRegDialog.this.repaint();			}		});		this.rigidBody.addItemListener(new ItemListener() {						@Override			public void itemStateChanged(final ItemEvent ie)			{				if(turboRegDialog.this.transformationGroup.getSelectedCheckbox().getLabel().equals("Rigid Body") && (transformation != RIGID_BODY))				{					if(transformation == BILINEAR)					{						transformation = RIGID_BODY;						turboRegDialog.this.cancelImages();						turboRegDialog.this.createImages();						turboRegDialog.this.startThreads();					}					else					{						transformation = RIGID_BODY;						turboRegDialog.this.setTransformation();					}				}				turboRegDialog.this.repaint();			}		});		this.scaledRotation.addItemListener(new ItemListener() {						@Override			public void itemStateChanged(final ItemEvent ie)			{				if(turboRegDialog.this.transformationGroup.getSelectedCheckbox().getLabel().equals("Scaled Rotation") && (transformation != SCALED_ROTATION))				{					if(transformation == BILINEAR)					{						transformation = SCALED_ROTATION;						turboRegDialog.this.cancelImages();						turboRegDialog.this.createImages();						turboRegDialog.this.startThreads();					}					else					{						transformation = SCALED_ROTATION;						turboRegDialog.this.setTransformation();					}				}				turboRegDialog.this.repaint();			}		});		this.affine.addItemListener(new ItemListener() {						@Override			public void itemStateChanged(final ItemEvent ie)			{				if(turboRegDialog.this.transformationGroup.getSelectedCheckbox().getLabel().equals("Affine") && (transformation != AFFINE))				{					if(transformation == BILINEAR)					{						transformation = AFFINE;						turboRegDialog.this.cancelImages();						turboRegDialog.this.createImages();						turboRegDialog.this.startThreads();					}					else					{						transformation = AFFINE;						turboRegDialog.this.setTransformation();					}				}				turboRegDialog.this.repaint();			}		});		this.bilinear.addItemListener(new ItemListener() {						@Override			public void itemStateChanged(final ItemEvent ie)			{				if(turboRegDialog.this.transformationGroup.getSelectedCheckbox().getLabel().equals("Bilinear") && (transformation != BILINEAR))				{					transformation = BILINEAR;					turboRegDialog.this.cancelImages();					turboRegDialog.this.createImages();					turboRegDialog.this.startThreads();				}				turboRegDialog.this.repaint();			}		});		transformationPanel.add(this.translation);		transformationPanel.add(this.rigidBody);		transformationPanel.add(this.scaledRotation);		transformationPanel.add(this.affine);		transformationPanel.add(this.bilinear);		final Panel pointPanel = new Panel();		pointPanel.setLayout(new FlowLayout(FlowLayout.CENTER));		final Label pointLabel = new Label("Landmarks: ");		final Button loadButton = new Button("Load...");		loadButton.addActionListener(this);		final Button saveButton = new Button("Save Now...");		saveButton.addActionListener(this);		final Checkbox saveCheck = new Checkbox("Save on Exit", saveOnExit);		saveCheck.addItemListener(new ItemListener() {						@Override			public void itemStateChanged(final ItemEvent ie)			{				saveOnExit = saveCheck.getState();				turboRegDialog.this.repaint();			}		});		pointPanel.add(pointLabel);		pointPanel.add(loadButton);		pointPanel.add(saveButton);		pointPanel.add(saveCheck);		final Panel accelerationPanel = new Panel();		accelerationPanel.setLayout(new FlowLayout(FlowLayout.CENTER));		final Label acceleratedLabel = new Label("Quality: ");		final CheckboxGroup accelerationGroup = new CheckboxGroup();		final Checkbox fast = new Checkbox("Fast", accelerationGroup, accelerated);		final Checkbox accurate = new Checkbox("Accurate", accelerationGroup, !accelerated);		fast.addItemListener(new ItemListener() {						@Override			public void itemStateChanged(final ItemEvent ie)			{				if(accelerationGroup.getSelectedCheckbox().getLabel().equals("Fast"))				{					accelerated = true;				}				turboRegDialog.this.automaticButton.setEnabled((!accelerated) || (1 < turboRegDialog.this.pyramidDepth));				turboRegDialog.this.repaint();			}		});		accurate.addItemListener(new ItemListener() {						@Override			public void itemStateChanged(final ItemEvent ie)			{				if(accelerationGroup.getSelectedCheckbox().getLabel().equals("Accurate"))				{					accelerated = false;				}				turboRegDialog.this.automaticButton.setEnabled((!accelerated) || (1 < turboRegDialog.this.pyramidDepth));				turboRegDialog.this.repaint();			}		});		accelerationPanel.add(acceleratedLabel);		accelerationPanel.add(fast);		accelerationPanel.add(accurate);		final Panel creditsPanel = new Panel();		creditsPanel.setLayout(new FlowLayout(FlowLayout.CENTER));		final Button creditsButton = new Button("Credits...");		creditsButton.addActionListener(this);		creditsPanel.add(creditsButton);		final Panel buttonPanel = new Panel();		buttonPanel.setLayout(new FlowLayout(FlowLayout.CENTER));		final Button cancelButton = new Button("Cancel");		cancelButton.addActionListener(this);		final Button manualButton = new Button("Manual");		manualButton.addActionListener(this);		this.automaticButton.addActionListener(this);		this.batchButton.setEnabled((1 < this.sourceImp.getStackSize()) && !(this.sourceImp.getStack().isRGB() || this.targetImp.getStack().isRGB()));		this.batchButton.addActionListener(this);		buttonPanel.add(cancelButton);		buttonPanel.add(manualButton);		buttonPanel.add(this.automaticButton);		buttonPanel.add(this.batchButton);		final Label separation1 = new Label("");		final Label separation2 = new Label("");		this.add(separation1);		this.add(sourcePanel);		this.add(targetPanel);		this.add(transformationPanel);		this.add(pointPanel);		this.add(accelerationPanel);		this.add(separation2);		this.add(buttonPanel);		this.add(creditsPanel);		this.pack();	} /* end turboRegDialog */		/*	 * .................................................................... Private methods ....................................................................	 */		/*------------------------------------------------------------------*/	private void cancelImages()	{		this.cancelSource();		this.cancelTarget();	} /* end cancelImages */		/*------------------------------------------------------------------*/	private void cancelSource()	{		this.cancelSource(this.sourcePh);		this.sourcePh = null;		Runtime.getRuntime().gc();	} /* end cancelSource */		/*------------------------------------------------------------------*/	private double[][] cancelSource(final turboRegPointHandler sourcePh)	{		this.stopSourceThreads();		if(this.sourceScrollbar != null)		{			this.sourceScrollbar.removeAdjustmentListener(this.sourcePa);			this.sourceScrollbar = null;		}		final ImageWindow iw = this.sourceImp.getWindow();		iw.removeKeyListener(this.sourcePa);		this.sourceIc.removeKeyListener(this.sourcePa);		this.sourceIc.removeMouseMotionListener(this.sourcePa);		this.sourceIc.removeMouseListener(this.sourcePa);		this.sourceIc.addMouseListener(this.sourceIc);		this.sourceIc.addMouseMotionListener(this.sourceIc);		this.sourceIc.addKeyListener(IJ.getInstance());		iw.addKeyListener(IJ.getInstance());		this.sourceIc = null;		this.sourceImp.killRoi();		this.sourceImp.updateAndDraw();		this.sourceImp = null;		this.sourceImg = null;		this.sourceMsk = null;		this.sourcePa = null;		this.sourceScrollbar = null;		return (sourcePh.getPoints());	} /* end cancelSource */		/*------------------------------------------------------------------*/	private void cancelTarget()	{		this.cancelTarget(this.targetPh);		this.targetPh = null;		Runtime.getRuntime().gc();	} /* end cancelTarget */		/*------------------------------------------------------------------*/	private double[][] cancelTarget(final turboRegPointHandler targetPh)	{		this.stopTargetThreads();		if(this.targetScrollbar != null)		{			this.targetScrollbar.removeAdjustmentListener(this.targetPa);			this.targetScrollbar = null;		}		final ImageWindow iw = this.targetImp.getWindow();		iw.removeKeyListener(this.targetPa);		this.targetIc.removeKeyListener(this.targetPa);		this.targetIc.removeMouseMotionListener(this.targetPa);		this.targetIc.removeMouseListener(this.targetPa);		this.targetIc.addMouseListener(this.targetIc);		this.targetIc.addMouseMotionListener(this.targetIc);		this.targetIc.addKeyListener(IJ.getInstance());		iw.addKeyListener(IJ.getInstance());		this.targetIc = null;		this.targetImp.killRoi();		this.targetImp.updateAndDraw();		this.targetImp = null;		this.targetImg = null;		this.targetMsk = null;		this.targetPa = null;		this.targetScrollbar = null;		return (targetPh.getPoints());	} /* end cancelTarget */		/*------------------------------------------------------------------*/	private void createImages()	{		this.createSourceImages();		this.createTargetImages();		this.sourcePa.setSecondaryPointHandler(this.targetImp, this.targetPh);		this.targetPa.setSecondaryPointHandler(this.sourceImp, this.sourcePh);		this.getPyramidDepth();		this.sourceImg.setPyramidDepth(this.pyramidDepth);		this.sourceMsk.setPyramidDepth(this.pyramidDepth);		this.targetImg.setPyramidDepth(this.pyramidDepth);		this.targetMsk.setPyramidDepth(this.pyramidDepth);	} /* end createImages */		/*------------------------------------------------------------------*/	private void createSourceImages()	{		this.sourceImp = this.admissibleImageList[this.sourceChoiceIndex];		if(this.sourceImp.getStack().isRGB())		{			this.sourceBlack.setEnabled(false);			this.sourceRed.setEnabled(true);			this.sourceGreen.setEnabled(true);			this.sourceBlue.setEnabled(true);			switch (sourceColorPlane)			{				case RED:				{					this.sourceKrgbGroup.setSelectedCheckbox(this.sourceRed);					break;				}				case GREEN:				{					this.sourceKrgbGroup.setSelectedCheckbox(this.sourceGreen);					break;				}				case BLUE:				{					this.sourceKrgbGroup.setSelectedCheckbox(this.sourceBlue);					break;				}			}			this.sourceImp.setSlice(sourceColorPlane);			this.sourceImg = new turboRegImage(this.sourceImp, transformation, false);			this.sourceMsk = new turboRegMask(this.sourceImp);			this.sourceMsk.clearMask();		}		else		{			this.sourceBlack.setEnabled(true);			this.sourceRed.setEnabled(false);			this.sourceGreen.setEnabled(false);			this.sourceBlue.setEnabled(false);			this.sourceKrgbGroup.setSelectedCheckbox(this.sourceBlack);			sourceColorPlane = 0;			this.sourceImp.setSlice(1);			this.sourceImg = new turboRegImage(this.sourceImp, transformation, false);			if(2 <= this.sourceImp.getStackSize())			{				this.sourceImp.setSlice(2);			}			this.sourceMsk = new turboRegMask(this.sourceImp);			this.sourceImp.setSlice(1);			if(this.sourceImp.getStackSize() < 2)			{				this.sourceMsk.clearMask();			}		}		final ImageWindow iw = this.sourceImp.getWindow();		this.sourceIc = iw.getCanvas();		iw.removeKeyListener(IJ.getInstance());		this.sourceIc.removeKeyListener(IJ.getInstance());		this.sourceIc.removeMouseMotionListener(this.sourceIc);		this.sourceIc.removeMouseListener(this.sourceIc);		this.sourcePh = new turboRegPointHandler(this.sourceImp, transformation);		this.sourcePa = new turboRegPointAction(this.sourceImp, this.sourcePh, this.tb);		this.sourceIc.addMouseListener(this.sourcePa);		this.sourceIc.addMouseMotionListener(this.sourcePa);		this.sourceIc.addKeyListener(this.sourcePa);		iw.addKeyListener(this.sourcePa);		if(this.sourceImp.getWindow() instanceof StackWindow)		{			StackWindow sw = (StackWindow) this.sourceImp.getWindow();			final Component component[] = sw.getComponents();			for (int i = 0; (i < component.length); i++)			{				if(component[i] instanceof Scrollbar)				{					this.sourceScrollbar = (Scrollbar) component[i];					this.sourceScrollbar.addAdjustmentListener(this.sourcePa);				}			}		}		else		{			this.sourceScrollbar = null;		}		this.sourceImp.updateAndDraw();	} /* end createSourceImages */		/*------------------------------------------------------------------*/	private void createTargetImages()	{		this.targetImp = this.admissibleImageList[this.targetChoiceIndex];		if(this.targetImp.getStack().isRGB())		{			this.targetBlack.setEnabled(false);			this.targetRed.setEnabled(true);			this.targetGreen.setEnabled(true);			this.targetBlue.setEnabled(true);			switch (targetColorPlane)			{				case RED:				{					this.targetKrgbGroup.setSelectedCheckbox(this.targetRed);					break;				}				case GREEN:				{					this.targetKrgbGroup.setSelectedCheckbox(this.targetGreen);					break;				}				case BLUE:				{					this.targetKrgbGroup.setSelectedCheckbox(this.targetBlue);					break;				}			}			this.targetImp.setSlice(targetColorPlane);			this.targetImg = new turboRegImage(this.targetImp, transformation, true);			this.targetMsk = new turboRegMask(this.targetImp);			this.targetMsk.clearMask();		}		else		{			this.targetBlack.setEnabled(true);			this.targetRed.setEnabled(false);			this.targetGreen.setEnabled(false);			this.targetBlue.setEnabled(false);			this.targetKrgbGroup.setSelectedCheckbox(this.targetBlack);			targetColorPlane = 0;			this.targetImp.setSlice(1);			this.targetImg = new turboRegImage(this.targetImp, transformation, true);			if(2 <= this.targetImp.getStackSize())			{				this.targetImp.setSlice(2);			}			this.targetMsk = new turboRegMask(this.targetImp);			this.targetImp.setSlice(1);			if(this.targetImp.getStackSize() < 2)			{				this.targetMsk.clearMask();			}		}		final ImageWindow iw = this.targetImp.getWindow();		this.targetIc = iw.getCanvas();		iw.removeKeyListener(IJ.getInstance());		this.targetIc.removeKeyListener(IJ.getInstance());		this.targetIc.removeMouseMotionListener(this.targetIc);		this.targetIc.removeMouseListener(this.targetIc);		this.targetPh = new turboRegPointHandler(this.targetImp, transformation);		this.targetPa = new turboRegPointAction(this.targetImp, this.targetPh, this.tb);		this.targetIc.addMouseListener(this.targetPa);		this.targetIc.addMouseMotionListener(this.targetPa);		this.targetIc.addKeyListener(this.targetPa);		iw.addKeyListener(this.targetPa);		if(this.targetImp.getWindow() instanceof StackWindow)		{			StackWindow sw = (StackWindow) this.targetImp.getWindow();			final Component component[] = sw.getComponents();			for (int i = 0; (i < component.length); i++)			{				if(component[i] instanceof Scrollbar)				{					this.targetScrollbar = (Scrollbar) component[i];					this.targetScrollbar.addAdjustmentListener(this.targetPa);				}			}		}		else		{			this.targetScrollbar = null;		}		this.targetImp.updateAndDraw();	} /* end createTargetImages */		/*------------------------------------------------------------------*/	private void defaultSourceColorPlane()	{		this.sourceImp = this.admissibleImageList[this.sourceChoiceIndex];		if(this.sourceImp.getStack().isRGB())		{			sourceColorPlane = this.sourceImp.getCurrentSlice();		}		else		{			sourceColorPlane = 0;		}	} /* end defaultSourceColorPlane */		/*------------------------------------------------------------------*/	private void defaultTargetColorPlane()	{		this.targetImp = this.admissibleImageList[this.targetChoiceIndex];		if(this.targetImp.getStack().isRGB())		{			targetColorPlane = this.targetImp.getCurrentSlice();		}		else		{			targetColorPlane = 0;		}	} /* end defaultTargetColorPlane */		/*------------------------------------------------------------------*/	private void getPyramidDepth()	{		int sw = this.sourceImp.getWidth();		int sh = this.sourceImp.getHeight();		int tw = this.targetImp.getWidth();		int th = this.targetImp.getHeight();		this.pyramidDepth = 1;		while (((2 * MIN_SIZE) <= sw) && ((2 * MIN_SIZE) <= sh) && ((2 * MIN_SIZE) <= tw) && ((2 * MIN_SIZE) <= th))		{			sw /= 2;			sh /= 2;			tw /= 2;			th /= 2;			this.pyramidDepth++;		}		this.automaticButton.setEnabled((!accelerated) || (1 < this.pyramidDepth));	} /* end getPyramidDepth */		/*------------------------------------------------------------------*/	private boolean loadLandmarks()	{		final Frame f = new Frame();		final FileDialog fd = new FileDialog(f, "Landmarks", FileDialog.LOAD);		fd.setVisible(true);		String path = fd.getDirectory();		String filename = fd.getFile();		if((path == null) || (filename == null))		{			return (true);		}		final double[][] targetPoint = new double[turboRegPointHandler.NUM_POINTS][2];		final double[][] sourcePoint = new double[turboRegPointHandler.NUM_POINTS][2];		int transformation;		try		{			final FileReader fr = new FileReader(path + filename);			final BufferedReader br = new BufferedReader(fr);			String line;			String xString;			String yString;			int separatorIndex;			int k = 1;			if(!(line = br.readLine()).equals("Transformation"))			{				fr.close();				IJ.log("Line " + k + ": 'Transformation'");				return (false);			}			++k;			line = br.readLine();			if(line.equals("TRANSLATION"))			{				transformation = TRANSLATION;			}			else if(line.equals("RIGID_BODY"))			{				transformation = RIGID_BODY;			}			else if(line.equals("SCALED_ROTATION"))			{				transformation = SCALED_ROTATION;			}			else if(line.equals("AFFINE"))			{				transformation = AFFINE;			}			else if(line.equals("BILINEAR"))			{				transformation = BILINEAR;			}			else			{				fr.close();				IJ.log("Line " + k + ": 'TRANSLATION' " + "| 'RIGID_BODY' " + "| 'SCALED_ROTATION' " + "| 'AFFINE' " + "| 'BILINEAR'");				return (false);			}			++k;			if(!(line = br.readLine()).equals(""))			{				fr.close();				IJ.log("Line " + k + ": ''");				return (false);			}			++k;			if(!(line = br.readLine()).equals("Source size"))			{				fr.close();				IJ.log("Line " + k + ": 'Source size'");				return (false);			}			++k;			if((line = br.readLine()) == null)			{				fr.close();				IJ.log("Line " + k + ": #sourceWidth# <tab> #sourceHeight#");				return (false);			}			line = line.trim();			separatorIndex = line.indexOf('\t');			if(separatorIndex == -1)			{				fr.close();				IJ.log("Line " + k + ": #sourceWidth# <tab> #sourceHeight#");				return (false);			}			xString = line.substring(0, separatorIndex);			yString = line.substring(separatorIndex);			xString = xString.trim();			yString = yString.trim();			if(Integer.parseInt(xString) != this.sourceImp.getWidth())			{				fr.close();				IJ.log("Line " + k + ": The source width" + " should not differ from that in the landmarks file");				return (false);			}			if(Integer.parseInt(yString) != this.sourceImp.getHeight())			{				fr.close();				IJ.log("Line " + k + ": The source height" + " should not differ from that in the landmarks file");				return (false);			}			++k;			if(!(line = br.readLine()).equals(""))			{				fr.close();				IJ.log("Line " + k + ": ''");				return (false);			}			++k;			if(!(line = br.readLine()).equals("Target size"))			{				fr.close();				IJ.log("Line " + k + ": 'Target size'");				return (false);			}			++k;			if((line = br.readLine()) == null)			{				fr.close();				IJ.log("Line " + k + ": #targetWidth# <tab> #targetHeight#");				return (false);			}			line = line.trim();			separatorIndex = line.indexOf('\t');			if(separatorIndex == -1)			{				fr.close();				IJ.log("Line " + k + ": #targetWidth# <tab> #targetHeight#");				return (false);			}			xString = line.substring(0, separatorIndex);			yString = line.substring(separatorIndex);			xString = xString.trim();			yString = yString.trim();			if(Integer.parseInt(xString) != this.targetImp.getWidth())			{				fr.close();				IJ.log("Line " + k + ": The target width" + " should not differ from that in the landmarks file");				return (false);			}			if(Integer.parseInt(yString) != this.targetImp.getHeight())			{				fr.close();				IJ.log("Line " + k + ": The target height" + " should not differ from that in the landmarks file");				return (false);			}			++k;			if(!(line = br.readLine()).equals(""))			{				fr.close();				IJ.log("Line " + k + ": ''");				return (false);			}			++k;			if(!(line = br.readLine()).equals("Refined source landmarks"))			{				fr.close();				IJ.log("Line " + k + ": 'Refined source landmarks'");				return (false);			}			if(transformation == RIGID_BODY)			{				for (int i = 0; (i < transformation); i++)				{					++k;					if((line = br.readLine()) == null)					{						fr.close();						IJ.log("Line " + k + ": #xSourcePoint# <tab> #ySourcePoint#");						br.close();						return (false);					}					line = line.trim();					separatorIndex = line.indexOf('\t');					if(separatorIndex == -1)					{						fr.close();						IJ.log("Line " + k + ": #xSourcePoint# <tab> #ySourcePoint#");						br.close();						return (false);					}					xString = line.substring(0, separatorIndex);					yString = line.substring(separatorIndex);					xString = xString.trim();					yString = yString.trim();					sourcePoint[i][0] = (new Double(xString)).doubleValue();					sourcePoint[i][1] = (new Double(yString)).doubleValue();				}			}			else			{				for (int i = 0; (i < (transformation / 2)); i++)				{					++k;					if((line = br.readLine()) == null)					{						fr.close();						IJ.log("Line " + k + ": #xSourcePoint# <tab> #ySourcePoint#");						br.close();						return (false);					}					line = line.trim();					separatorIndex = line.indexOf('\t');					if(separatorIndex == -1)					{						fr.close();						IJ.log("Line " + k + ": #xSourcePoint# <tab> #ySourcePoint#");						br.close();						return (false);					}					xString = line.substring(0, separatorIndex);					yString = line.substring(separatorIndex);					xString = xString.trim();					yString = yString.trim();					sourcePoint[i][0] = (new Double(xString)).doubleValue();					sourcePoint[i][1] = (new Double(yString)).doubleValue();				}			}			++k;			if(!(line = br.readLine()).equals(""))			{				fr.close();				IJ.log("Line " + k + ": ''");				return (false);			}			++k;			if(!(line = br.readLine()).equals("Target landmarks"))			{				fr.close();				IJ.log("Line " + k + ": 'Target landmarks'");				return (false);			}			if(transformation == RIGID_BODY)			{				for (int i = 0; (i < transformation); i++)				{					++k;					if((line = br.readLine()) == null)					{						fr.close();						IJ.log("Line " + k + ": #xTargetPoint# <tab> #yTargetPoint#");						br.close();						return (false);					}					line = line.trim();					separatorIndex = line.indexOf('\t');					if(separatorIndex == -1)					{						fr.close();						IJ.log("Line " + k + ": #xTargetPoint# <tab> #yTargetPoint#");						br.close();						return (false);					}					xString = line.substring(0, separatorIndex);					yString = line.substring(separatorIndex);					xString = xString.trim();					yString = yString.trim();					targetPoint[i][0] = (new Double(xString)).doubleValue();					targetPoint[i][1] = (new Double(yString)).doubleValue();				}			}			else			{				for (int i = 0; (i < (transformation / 2)); i++)				{					++k;					if((line = br.readLine()) == null)					{						fr.close();						IJ.log("Line " + k + ": #xTargetPoint# <tab> #yTargetPoint#");						br.close();						return (false);					}					line = line.trim();					separatorIndex = line.indexOf('\t');					if(separatorIndex == -1)					{						fr.close();						IJ.log("Line " + k + ": #xTargetPoint# <tab> #yTargetPoint#");						br.close();						return (false);					}					xString = line.substring(0, separatorIndex);					yString = line.substring(separatorIndex);					xString = xString.trim();					yString = yString.trim();					targetPoint[i][0] = (new Double(xString)).doubleValue();					targetPoint[i][1] = (new Double(yString)).doubleValue();				}			}			fr.close();		}		catch (FileNotFoundException e)		{			IJ.log("File not found exception " + e.getMessage());			return (false);		}		catch (IOException e)		{			IJ.log("IOException exception " + e.getMessage());			return (false);		}		catch (NumberFormatException e)		{			IJ.log("Number format exception " + e.getMessage());			return (false);		}		if(transformation != turboRegDialog.transformation)		{			if((transformation == BILINEAR) || (turboRegDialog.transformation == BILINEAR))			{				this.cancelImages();				this.createImages();				this.startThreads();			}			turboRegDialog.transformation = transformation;			this.setTransformation();		}		this.sourcePh.setPoints(sourcePoint);		this.targetPh.setPoints(targetPoint);		switch (transformation)		{			case TRANSLATION:			{				this.transformationGroup.setSelectedCheckbox(this.translation);				break;			}			case RIGID_BODY:			{				this.transformationGroup.setSelectedCheckbox(this.rigidBody);				break;			}			case AFFINE:			{				this.transformationGroup.setSelectedCheckbox(this.affine);				break;			}			case SCALED_ROTATION:			{				this.transformationGroup.setSelectedCheckbox(this.scaledRotation);				break;			}			case BILINEAR:			{				this.transformationGroup.setSelectedCheckbox(this.bilinear);				break;			}		}		this.sourceImp.updateAndDraw();		this.targetImp.updateAndDraw();		return (true);	} /* end loadLandmarks */		/*------------------------------------------------------------------*/	private void permuteImages()	{		final int rescuedSourceColorPlane = sourceColorPlane;		final int rescuedTargetColorPlane = targetColorPlane;		final double[][] rescuedSourcePoints = this.cancelSource(this.sourcePh);		final double[][] rescuedTargetPoints = this.cancelTarget(this.targetPh);		sourceColorPlane = rescuedTargetColorPlane;		targetColorPlane = rescuedSourceColorPlane;		this.createSourceImages();		this.sourcePh.setPoints(rescuedTargetPoints);		this.createTargetImages();		this.targetPh.setPoints(rescuedSourcePoints);		this.sourceImp.updateAndDraw();		this.targetImp.updateAndDraw();	} /* end permuteImages */		/*------------------------------------------------------------------*/	private void setSourceColorPlane(final int colorPlane)	{		sourceColorPlane = colorPlane;		switch (sourceColorPlane)		{			case RED:			{				this.sourceKrgbGroup.setSelectedCheckbox(this.sourceRed);				break;			}			case GREEN:			{				this.sourceKrgbGroup.setSelectedCheckbox(this.sourceGreen);				break;			}			case BLUE:			{				this.sourceKrgbGroup.setSelectedCheckbox(this.sourceBlue);				break;			}		}		this.sourceImp.setSlice(sourceColorPlane);		this.sourceImg = new turboRegImage(this.sourceImp, transformation, false);		this.sourceMsk = new turboRegMask(this.sourceImp);		this.sourceMsk.clearMask();	} /* end setSourceColorPlane */		/*------------------------------------------------------------------*/	private void setTargetColorPlane(final int colorPlane)	{		targetColorPlane = colorPlane;		switch (targetColorPlane)		{			case RED:			{				this.targetKrgbGroup.setSelectedCheckbox(this.targetRed);				break;			}			case GREEN:			{				this.targetKrgbGroup.setSelectedCheckbox(this.targetGreen);				break;			}			case BLUE:			{				this.targetKrgbGroup.setSelectedCheckbox(this.targetBlue);				break;			}		}		this.targetImp.setSlice(targetColorPlane);		this.targetImg = new turboRegImage(this.targetImp, transformation, true);		this.targetMsk = new turboRegMask(this.targetImp);		this.targetMsk.clearMask();	} /* end setTargetColorPlane */		/*------------------------------------------------------------------*/	private void setTransformation()	{		this.sourceImg.setTransformation(transformation);		this.sourcePh.setTransformation(transformation);		this.targetImg.setTransformation(transformation);		this.targetPh.setTransformation(transformation);	} /* end setTransformation */		/*------------------------------------------------------------------*/	private void startSourceThreads()	{		this.getPyramidDepth();		this.sourceImg.setPyramidDepth(this.pyramidDepth);		this.sourceMsk.setPyramidDepth(this.pyramidDepth);		if(this.pyramidDepth != this.targetImg.getPyramidDepth())		{			ImagePlus imp = this.targetImp;			double[][] points = this.cancelTarget(this.targetPh);			this.targetImp = imp;			this.createTargetImages();			this.targetPh.setPoints(points);			this.targetImp.updateAndDraw();			this.targetImg.setPyramidDepth(this.pyramidDepth);			this.targetMsk.setPyramidDepth(this.pyramidDepth);			this.startTargetThreads();		}		this.sourceImg.getThread().start();		this.sourceMsk.getThread().start();	} /* end startSourceThreads */		/*------------------------------------------------------------------*/	private void startTargetThreads()	{		this.getPyramidDepth();		this.targetImg.setPyramidDepth(this.pyramidDepth);		this.targetMsk.setPyramidDepth(this.pyramidDepth);		if(this.pyramidDepth != this.sourceImg.getPyramidDepth())		{			ImagePlus imp = this.sourceImp;			double points[][] = this.cancelSource(this.sourcePh);			this.sourceImp = imp;			this.createSourceImages();			this.sourcePh.setPoints(points);			this.sourceImp.updateAndDraw();			this.sourceImg.setPyramidDepth(this.pyramidDepth);			this.sourceMsk.setPyramidDepth(this.pyramidDepth);			this.startSourceThreads();		}		this.targetImg.getThread().start();		this.targetMsk.getThread().start();	} /* end startTargetThreads */		/*------------------------------------------------------------------*/	private void startThreads()	{		this.getPyramidDepth();		this.sourceImg.setPyramidDepth(this.pyramidDepth);		this.sourceMsk.setPyramidDepth(this.pyramidDepth);		this.sourceImg.getThread().start();		this.sourceMsk.getThread().start();		this.targetImg.setPyramidDepth(this.pyramidDepth);		this.targetMsk.setPyramidDepth(this.pyramidDepth);		this.targetImg.getThread().start();		this.targetMsk.getThread().start();	} /* end startThreads */		/*------------------------------------------------------------------*/	private void stopSourceThreads()	{		while (this.sourceImg.getThread().isAlive())		{			this.sourceImg.getThread().interrupt();		}		// sourceImg.getThread().interrupted();		Thread.interrupted();		while (this.sourceMsk.getThread().isAlive())		{			this.sourceMsk.getThread().interrupt();		}		// sourceMsk.getThread().interrupted();		Thread.interrupted();	} /* end stopSourceThreads */		/*------------------------------------------------------------------*/	private void stopTargetThreads()	{		while (this.targetImg.getThread().isAlive())		{			this.targetImg.getThread().interrupt();		}		// targetImg.getThread().interrupted();		Thread.interrupted();		while (this.targetMsk.getThread().isAlive())		{			this.targetMsk.getThread().interrupt();		}		// targetMsk.getThread().interrupted();		Thread.interrupted();	} /* end stopTargetThreads */	} /* end class turboRegDialog *//* * ==================================================================== | turboRegFinalAction \=================================================================== *//********************************************************************* * The purpose of this class is to allow access to the progress bar, since it is denied to the <code>turboRegDialog</code> class. It proceeds by wrapping <code>turboRegDialog</code> inside a thread that is under the main event loop control. ********************************************************************/class turboRegFinalAction implements Runnable{ /* begin class turboRegFinalAction */		/*	 * .................................................................... Public variables ....................................................................	 */		/*********************************************************************	 * Automatic registration: the initial source landmarks are refined to minimize the mean-square error.	 ********************************************************************/	public static final int AUTOMATIC = 1;		/*********************************************************************	 * Manual registration: the initial source landmarks are used <i>as is</i> to produce the output image.	 ********************************************************************/	public static final int MANUAL = 2;		/*********************************************************************	 * Batch registration: each slice of the source image is registered to the target image.	 ********************************************************************/	public static final int BATCH = 3;		/*	 * .................................................................... Private variables ....................................................................	 */	private Thread t;	private turboRegDialog td;	private volatile ImagePlus sourceImp;	private volatile ImagePlus targetImp;	private volatile turboRegImage sourceImg;	private volatile turboRegImage targetImg;	private volatile turboRegMask sourceMsk;	private volatile turboRegMask targetMsk;	private volatile turboRegPointHandler sourcePh;	private volatile turboRegPointHandler targetPh;	private volatile int operation;	private volatile int pyramidDepth;	private volatile int sourceColorPlane;	private volatile int transformation;	private volatile boolean accelerated;	private volatile boolean saveOnExit;	private volatile boolean colorOutput;		/*	 * .................................................................... Public methods ....................................................................	 */		/*********************************************************************	 * Return the thread associated with this <code>turboRegFinalAction</code> object.	 ********************************************************************/	public Thread getThread()	{		return (this.t);	} /* end getThread */		/*********************************************************************	 * Start under the control of the main event loop, pause as long as the dialog event loop is active, and resume processing when <code>turboRegDialog</code> finally dies.	 ********************************************************************/	@Override	public void run()	{		double[][] sourcePoints = null;		double[][] targetPoints = null;		turboRegTransform tt = null;		ImageStack outputStack = null;		ImagePlus outputImp = null;		switch (this.operation)		{			case AUTOMATIC:			case MANUAL:			{				if(this.td != null)				{					if((this.operation == MANUAL) && this.accelerated)					{						this.td.stopThreads();					}					else					{						this.td.joinThreads();					}				}				tt = new turboRegTransform(this.sourceImg, this.sourceMsk, this.sourcePh, this.targetImg, this.targetMsk, this.targetPh, this.transformation, this.accelerated, (this.td != null));				if(this.operation == AUTOMATIC)				{					tt.doRegistration();				}				if(this.colorOutput)				{					outputStack = new ImageStack(this.targetImg.getWidth(), this.targetImg.getHeight());					FloatProcessor fp;					fp = new FloatProcessor(this.targetImg.getWidth(), this.targetImg.getHeight());					fp.setMinAndMax(0.0, 255.0);					outputStack.addSlice("Red", fp);					fp = new FloatProcessor(this.targetImg.getWidth(), this.targetImg.getHeight());					fp.setMinAndMax(0.0, 255.0);					outputStack.addSlice("Green", fp);					fp = new FloatProcessor(this.targetImg.getWidth(), this.targetImg.getHeight());					fp.setMinAndMax(0.0, 255.0);					outputStack.addSlice("Blue", fp);					outputImp = new ImagePlus("Registered", outputStack);					outputStack.setPixels(tt.doFinalTransform(this.sourceImg, this.sourcePh, this.targetImg, this.targetPh, this.transformation, this.accelerated, null), this.sourceColorPlane);					for (int c = turboRegDialog.RED; (c <= turboRegDialog.BLUE); c++)					{						if(c == this.sourceColorPlane)						{							continue;						}						this.sourceImp.setSlice(c);						this.sourceImg = new turboRegImage(this.sourceImp, turboRegDialog.GENERIC_TRANSFORMATION, false);						this.sourceImg.setPyramidDepth(1);						this.sourceImg.getThread().start();						try						{							this.sourceImg.getThread().join();						}						catch (InterruptedException e)						{							IJ.log("Unexpected interruption exception " + e.getMessage());						}						this.sourceImg.setTransformation(this.transformation);						outputStack.setPixels(tt.doFinalTransform(this.sourceImg, this.sourcePh, this.targetImg, this.targetPh, this.transformation, this.accelerated, null), c);					}					final StackConverter scnv = new StackConverter(outputImp);					scnv.convertToGray8();					final ImageConverter icnv = new ImageConverter(outputImp);					ImageConverter.setDoScaling(false);					icnv.convertRGBStackToRGB();					if(this.td != null)					{						outputImp.show();					}				}				else				{					outputImp = tt.doFinalTransform(this.targetImg.getWidth(), this.targetImg.getHeight(), null);				}				if(this.saveOnExit)				{					tt.saveTransformation(null);				}				if(this.td != null)				{					this.td.restoreAll();				}				break;			}			case BATCH:			{				outputStack = new ImageStack(this.targetImg.getWidth(), this.targetImg.getHeight());				for (int i = 0; (i < this.sourceImp.getStackSize()); i++)				{					outputStack.addSlice("", new FloatProcessor(this.targetImg.getWidth(), this.targetImg.getHeight()));				}				outputImp = new ImagePlus("Registered", outputStack);				if(this.transformation == turboRegDialog.RIGID_BODY)				{					targetPoints = new double[this.transformation][2];					sourcePoints = new double[this.transformation][2];					for (int k = 0; (k < this.transformation); k++)					{						sourcePoints[k][0] = this.sourcePh.getPoints()[k][0];						sourcePoints[k][1] = this.sourcePh.getPoints()[k][1];						targetPoints[k][0] = this.targetPh.getPoints()[k][0];						targetPoints[k][1] = this.targetPh.getPoints()[k][1];					}				}				else				{					targetPoints = new double[this.transformation / 2][2];					sourcePoints = new double[this.transformation / 2][2];					for (int k = 0; (k < (this.transformation / 2)); k++)					{						sourcePoints[k][0] = this.sourcePh.getPoints()[k][0];						sourcePoints[k][1] = this.sourcePh.getPoints()[k][1];						targetPoints[k][0] = this.targetPh.getPoints()[k][0];						targetPoints[k][1] = this.targetPh.getPoints()[k][1];					}				}				if(this.td != null)				{					this.td.joinThreads();				}				tt = new turboRegTransform(this.sourceImg, null, this.sourcePh, this.targetImg, this.targetMsk, this.targetPh, this.transformation, this.accelerated, (this.td != null));				if(2 <= this.sourceImp.getStackSize())				{					this.sourceImp.setSlice(2);					this.sourceImg = new turboRegImage(this.sourceImp, this.transformation, false);					this.sourceImg.setPyramidDepth(this.pyramidDepth);					this.sourceImg.getThread().start();				}				tt.doRegistration();				String pathAndFilename = "";				if(this.saveOnExit)				{					pathAndFilename = tt.saveTransformation(null);				}				tt.doBatchFinalTransform((float[]) outputStack.getProcessor(1).getPixels());				outputImp.setSlice(1);				outputImp.getProcessor().resetMinAndMax();				if(this.td != null)				{					outputImp.show();				}				Runtime.getRuntime().gc();				for (int i = 2; (i <= this.sourceImp.getStackSize()); i++)				{					this.targetPh.setPoints(targetPoints);					this.sourcePh = new turboRegPointHandler(this.sourceImp, this.transformation);					this.sourcePh.setPoints(sourcePoints);					try					{						this.sourceImg.getThread().join();					}					catch (InterruptedException e)					{						IJ.log("Unexpected interruption exception " + e.getMessage());					}					tt = new turboRegTransform(this.sourceImg, null, this.sourcePh, this.targetImg, this.targetMsk, this.targetPh, this.transformation, this.accelerated, (this.td != null));					if(i < this.sourceImp.getStackSize())					{						this.sourceImp.setSlice(i + 1);						this.sourceImg = new turboRegImage(this.sourceImp, this.transformation, false);						this.sourceImg.setPyramidDepth(this.pyramidDepth);						this.sourceImg.getThread().start();					}					tt.doRegistration();					if(this.saveOnExit)					{						tt.appendTransformation(pathAndFilename);					}					tt.doBatchFinalTransform((float[]) outputStack.getProcessor(i).getPixels());					outputImp.setSlice(i);					outputImp.getProcessor().resetMinAndMax();					Runtime.getRuntime().gc();				}				this.sourceImp.killRoi();				this.targetImp.killRoi();				outputImp.setSlice(1);				outputImp.getProcessor().resetMinAndMax();				if(this.td != null)				{					this.td.restoreAll();				}				break;			}		}	} /* end run */		/*********************************************************************	 * Pass parameter from <code>turboRegDialog</code> to <code>turboRegFinalAction</code>.	 ********************************************************************/	public void setup(final turboRegImage sourceImg, final turboRegMask sourceMsk, final turboRegPointHandler sourcePh, final turboRegImage targetImg, final turboRegMask targetMsk, final turboRegPointHandler targetPh, final int transformation, final boolean accelerated, final boolean saveOnExit, final int operation)	{		this.sourceImg = sourceImg;		this.sourceMsk = sourceMsk;		this.sourcePh = sourcePh;		this.targetImg = targetImg;		this.targetMsk = targetMsk;		this.targetPh = targetPh;		this.transformation = transformation;		this.accelerated = accelerated;		this.saveOnExit = saveOnExit;		this.operation = operation;		this.colorOutput = false;	} /* end setup */		/*********************************************************************	 * Pass parameter from <code>turboRegDialog</code> to <code>turboRegFinalAction</code>.	 ********************************************************************/	public void setup(final ImagePlus sourceImp, final turboRegImage sourceImg, final turboRegMask sourceMsk, final turboRegPointHandler sourcePh, final int sourceColorPlane, final turboRegImage targetImg, final turboRegMask targetMsk, final turboRegPointHandler targetPh, final int transformation, final boolean accelerated, final boolean saveOnExit, final int operation)	{		this.sourceImp = sourceImp;		this.sourceImg = sourceImg;		this.sourceMsk = sourceMsk;		this.sourcePh = sourcePh;		this.sourceColorPlane = sourceColorPlane;		this.targetImg = targetImg;		this.targetMsk = targetMsk;		this.targetPh = targetPh;		this.transformation = transformation;		this.accelerated = accelerated;		this.saveOnExit = saveOnExit;		this.operation = operation;		this.colorOutput = true;	} /* end setup */		/*********************************************************************	 * Pass parameter from <code>turboRegDialog</code> to <code>turboRegFinalAction</code>.	 ********************************************************************/	public void setup(final ImagePlus sourceImp, final turboRegImage sourceImg, final turboRegPointHandler sourcePh, final ImagePlus targetImp, final turboRegImage targetImg, final turboRegMask targetMsk, final turboRegPointHandler targetPh, final int transformation, final boolean accelerated, final boolean saveOnExit, final int pyramidDepth)	{		this.sourceImp = sourceImp;		this.sourceImg = sourceImg;		this.sourcePh = sourcePh;		this.targetImp = targetImp;		this.targetImg = targetImg;		this.targetMsk = targetMsk;		this.targetPh = targetPh;		this.transformation = transformation;		this.accelerated = accelerated;		this.saveOnExit = saveOnExit;		this.pyramidDepth = pyramidDepth;		this.operation = BATCH;	} /* end setup */		/*********************************************************************	 * Start a thread under the control of the main event loop. This thread has access to the progress bar, while methods called directly from within <code>turboRegDialog</code> do not because they are under the control of its own event loop.	 * 	 * @param dialog	 *            Gives access to some utility methods within <code>turboRegDialog</code>.	 ********************************************************************/	public turboRegFinalAction(final turboRegDialog dialog)	{		this.td = dialog;		this.t = new Thread(this);	} /* end turboRegFinalAction */		/*********************************************************************	 * Start a thread under the control of the main event loop.	 ********************************************************************/	public turboRegFinalAction(final turboRegImage sourceImg, final turboRegMask sourceMsk, final turboRegPointHandler sourcePh, final turboRegImage targetImg, final turboRegMask targetMsk, final turboRegPointHandler targetPh, final int transformation)	{		this.sourceImg = sourceImg;		this.sourceMsk = sourceMsk;		this.sourcePh = sourcePh;		this.targetImg = targetImg;		this.targetMsk = targetMsk;		this.targetPh = targetPh;		this.transformation = transformation;		this.accelerated = false;		this.saveOnExit = false;		this.operation = AUTOMATIC;		this.colorOutput = false;		this.td = null;		this.t = new Thread(this);	} /* end turboRegFinalAction */	} /* end class turboRegFinalAction *//* * ==================================================================== | turboRegImage \=================================================================== *//********************************************************************* * This class is responsible for the image preprocessing that takes place concurrently with user-interface events. It contains methods to compute B-spline coefficients and their pyramids, image pyramids, gradients, and gradient pyramids. ********************************************************************/class turboRegImage implements Runnable{ /* begin class turboRegImage */		/*	 * .................................................................... Private variables ....................................................................	 */	private final Stack<Object> pyramid = new Stack<Object>();	private Thread t;	private float[] image;	private float[] coefficient;	private float[] xGradient;	private float[] yGradient;	private int width;	private int height;	private int pyramidDepth;	private int transformation;	private boolean isTarget;		/*	 * .................................................................... Public methods ....................................................................	 */		/*********************************************************************	 * Return the B-spline coefficients of the full-size image.	 ********************************************************************/	public float[] getCoefficient()	{		return (this.coefficient);	} /* end getCoefficient */		/*********************************************************************	 * Return the full-size image height.	 ********************************************************************/	public int getHeight()	{		return (this.height);	} /* end getHeight */		/*********************************************************************	 * Return the full-size image array.	 ********************************************************************/	public float[] getImage()	{		return (this.image);	} /* end getImage */		/*********************************************************************	 * Return the image pyramid as a <code>Stack</code> object. The organization of the stack depends on whether the <code>turboRegImage</code> object corresponds to the target or the source image, and on the transformation (ML* = {	 * <code>TRANSLATION</code>,<code>RIGID_BODY</code>, <code>SCALED_ROTATION</code>, <code>AFFINE</code> vs. ML = { <code>BILINEAR<code>}). A single pyramid level consists of <p> <table border="1"> <tr><th><code>isTarget</code> </th> <th>ML*</th>	 * <th>ML</th></tr>	 * <tr>	 * <td>true</td>	 * <td>width<br>	 * height<br>	 * B-spline coefficients</td>	 * <td>width<br>	 * height<br>	 * samples</td>	 * </tr>	 * <tr>	 * <td>false</td>	 * <td>width<br>	 * height<br>	 * samples<br>	 * horizontal gradients<br>	 * vertical gradients</td>	 * <td>width<br>	 * height<br>	 * B-spline coefficients</td>	 * </tr>	 * </table>	 ********************************************************************/	public Stack<Object> getPyramid()	{		return (this.pyramid);	} /* end getPyramid */		/*********************************************************************	 * Return the depth of the image pyramid. A depth <code>1</code> means that one coarse resolution level is present in the stack. The full-size level is not placed on the stack.	 ********************************************************************/	public int getPyramidDepth()	{		return (this.pyramidDepth);	} /* end getPyramidDepth */		/*********************************************************************	 * Return the thread associated with this <code>turboRegImage</code> object.	 ********************************************************************/	public Thread getThread()	{		return (this.t);	} /* end getThread */		/*********************************************************************	 * Return the full-size image width.	 ********************************************************************/	public int getWidth()	{		return (this.width);	} /* end getWidth */		/*********************************************************************	 * Return the full-size horizontal gradient of the image, if available.	 * 	 * @see turboRegImage#getPyramid()	 ********************************************************************/	public float[] getXGradient()	{		return (this.xGradient);	} /* end getXGradient */		/*********************************************************************	 * Return the full-size vertical gradient of the image, if available.	 * 	 * @see turboRegImage#getImage()	 ********************************************************************/	public float[] getYGradient()	{		return (this.yGradient);	} /* end getYGradient */		/*********************************************************************	 * Start the image precomputations. The computation of the B-spline coefficients of the full-size image is not interruptible; all other methods are.	 ********************************************************************/	@Override	public void run()	{		this.coefficient = this.getBasicFromCardinal2D();		switch (this.transformation)		{			case turboRegDialog.GENERIC_TRANSFORMATION:			{				break;			}			case turboRegDialog.TRANSLATION:			case turboRegDialog.RIGID_BODY:			case turboRegDialog.SCALED_ROTATION:			case turboRegDialog.AFFINE:			{				if(this.isTarget)				{					this.buildCoefficientPyramid();				}				else				{					this.imageToXYGradient2D();					this.buildImageAndGradientPyramid();				}				break;			}			case turboRegDialog.BILINEAR:			{				if(this.isTarget)				{					this.buildImagePyramid();				}				else				{					this.buildCoefficientPyramid();				}				break;			}		}	} /* end run */		/*********************************************************************	 * Sets the depth up to which the pyramids should be computed.	 * 	 * @see turboRegImage#getImage()	 ********************************************************************/	public void setPyramidDepth(final int pyramidDepth)	{		this.pyramidDepth = pyramidDepth;	} /* end setPyramidDepth */		/*********************************************************************	 * Set or modify the transformation.	 ********************************************************************/	public void setTransformation(final int transformation)	{		this.transformation = transformation;	} /* end setTransformation */		/*********************************************************************	 * Converts the pixel array of the incoming <code>ImagePlus</code> object into a local <code>float</code> array.	 * 	 * @param imp	 *            <code>ImagePlus</code> object to preprocess.	 * @param transformation	 *            Transformation code.	 * @param isTarget	 *            Tags the current object as a target or source image.	 ********************************************************************/	public turboRegImage(final ImagePlus imp, final int transformation, final boolean isTarget)	{		this.t = new Thread(this);		this.t.setDaemon(true);		this.transformation = transformation;		this.isTarget = isTarget;		this.width = imp.getWidth();		this.height = imp.getHeight();		int k = 0;		turboRegProgressBar.addWorkload(this.height);		if(imp.getType() == ImagePlus.GRAY8)		{			this.image = new float[this.width * this.height];			final byte[] pixels = (byte[]) imp.getProcessor().getPixels();			for (int y = 0; (y < this.height); y++)			{				for (int x = 0; (x < this.width); x++, k++)				{					this.image[k] = pixels[k] & 0xFF;				}				turboRegProgressBar.stepProgressBar();			}		}		else if(imp.getType() == ImagePlus.GRAY16)		{			this.image = new float[this.width * this.height];			final short[] pixels = (short[]) imp.getProcessor().getPixels();			for (int y = 0; (y < this.height); y++)			{				for (int x = 0; (x < this.width); x++, k++)				{					if(pixels[k] < (short) 0)					{						this.image[k] = pixels[k] + 65536.0F;					}					else					{						this.image[k] = pixels[k];					}				}				turboRegProgressBar.stepProgressBar();			}		}		else if(imp.getType() == ImagePlus.GRAY32)		{			this.image = (float[]) imp.getProcessor().getPixels();		}		turboRegProgressBar.workloadDone(this.height);	} /* end turboRegImage */		/*	 * .................................................................... Private methods ....................................................................	 */		/*------------------------------------------------------------------*/	private void antiSymmetricFirMirrorOffBounds1D(final double[] h, final double[] c, final double[] s)	{		if(2 <= c.length)		{			s[0] = h[1] * (c[1] - c[0]);			for (int i = 1; (i < (s.length - 1)); i++)			{				s[i] = h[1] * (c[i + 1] - c[i - 1]);			}			s[s.length - 1] = h[1] * (c[c.length - 1] - c[c.length - 2]);		}		else		{			s[0] = 0.0;		}	} /* end antiSymmetricFirMirrorOffBounds1D */		/*------------------------------------------------------------------*/	private void basicToCardinal2D(final float[] basic, final float[] cardinal, final int width, final int height, final int degree)	{		final double[] hLine = new double[width];		final double[] vLine = new double[height];		final double[] hData = new double[width];		final double[] vData = new double[height];		double[] h = null;		switch (degree)		{			case 3:			{				h = new double[2];				h[0] = 2.0 / 3.0;				h[1] = 1.0 / 6.0;				break;			}			case 7:			{				h = new double[4];				h[0] = 151.0 / 315.0;				h[1] = 397.0 / 1680.0;				h[2] = 1.0 / 42.0;				h[3] = 1.0 / 5040.0;				break;			}			default:			{				h = new double[1];				h[0] = 1.0;			}		}		int workload = width + height;		turboRegProgressBar.addWorkload(workload);		for (int y = 0; ((y < height) && (!this.t.isInterrupted())); y++)		{			this.extractRow(basic, y, hLine);			this.symmetricFirMirrorOffBounds1D(h, hLine, hData);			this.putRow(cardinal, y, hData);			turboRegProgressBar.stepProgressBar();			workload--;		}		for (int x = 0; ((x < width) && (!this.t.isInterrupted())); x++)		{			this.extractColumn(cardinal, width, x, vLine);			this.symmetricFirMirrorOffBounds1D(h, vLine, vData);			this.putColumn(cardinal, width, x, vData);			turboRegProgressBar.stepProgressBar();			workload--;		}		turboRegProgressBar.skipProgressBar(workload);		turboRegProgressBar.workloadDone(width + height);	} /* end basicToCardinal2D */		/*------------------------------------------------------------------*/	private void buildCoefficientPyramid()	{		int fullWidth;		int fullHeight;		float[] fullDual = new float[this.width * this.height];		int halfWidth = this.width;		int halfHeight = this.height;		if(1 < this.pyramidDepth)		{			this.basicToCardinal2D(this.coefficient, fullDual, this.width, this.height, 7);		}		for (int depth = 1; ((depth < this.pyramidDepth) && (!this.t.isInterrupted())); depth++)		{			fullWidth = halfWidth;			fullHeight = halfHeight;			halfWidth /= 2;			halfHeight /= 2;			final float[] halfDual = this.getHalfDual2D(fullDual, fullWidth, fullHeight);			final float[] halfCoefficient = this.getBasicFromCardinal2D(halfDual, halfWidth, halfHeight, 7);			this.pyramid.push(halfCoefficient);			this.pyramid.push(new Integer(halfHeight));			this.pyramid.push(new Integer(halfWidth));			fullDual = halfDual;		}	} /* end buildCoefficientPyramid */		/*------------------------------------------------------------------*/	private void buildImageAndGradientPyramid()	{		int fullWidth;		int fullHeight;		float[] fullDual = new float[this.width * this.height];		int halfWidth = this.width;		int halfHeight = this.height;		if(1 < this.pyramidDepth)		{			this.cardinalToDual2D(this.image, fullDual, this.width, this.height, 3);		}		for (int depth = 1; ((depth < this.pyramidDepth) && (!this.t.isInterrupted())); depth++)		{			fullWidth = halfWidth;			fullHeight = halfHeight;			halfWidth /= 2;			halfHeight /= 2;			final float[] halfDual = this.getHalfDual2D(fullDual, fullWidth, fullHeight);			final float[] halfImage = this.getBasicFromCardinal2D(halfDual, halfWidth, halfHeight, 7);			final float[] halfXGradient = new float[halfWidth * halfHeight];			final float[] halfYGradient = new float[halfWidth * halfHeight];			this.coefficientToXYGradient2D(halfImage, halfXGradient, halfYGradient, halfWidth, halfHeight);			this.basicToCardinal2D(halfImage, halfImage, halfWidth, halfHeight, 3);			this.pyramid.push(halfYGradient);			this.pyramid.push(halfXGradient);			this.pyramid.push(halfImage);			this.pyramid.push(new Integer(halfHeight));			this.pyramid.push(new Integer(halfWidth));			fullDual = halfDual;		}	} /* end buildImageAndGradientPyramid */		/*------------------------------------------------------------------*/	private void buildImagePyramid()	{		int fullWidth;		int fullHeight;		float[] fullDual = new float[this.width * this.height];		int halfWidth = this.width;		int halfHeight = this.height;		if(1 < this.pyramidDepth)		{			this.cardinalToDual2D(this.image, fullDual, this.width, this.height, 3);		}		for (int depth = 1; ((depth < this.pyramidDepth) && (!this.t.isInterrupted())); depth++)		{			fullWidth = halfWidth;			fullHeight = halfHeight;			halfWidth /= 2;			halfHeight /= 2;			final float[] halfDual = this.getHalfDual2D(fullDual, fullWidth, fullHeight);			final float[] halfImage = new float[halfWidth * halfHeight];			this.dualToCardinal2D(halfDual, halfImage, halfWidth, halfHeight, 3);			this.pyramid.push(halfImage);			this.pyramid.push(new Integer(halfHeight));			this.pyramid.push(new Integer(halfWidth));			fullDual = halfDual;		}	} /* end buildImagePyramid */		/*------------------------------------------------------------------*/	private void cardinalToDual2D(final float[] cardinal, final float[] dual, final int width, final int height, final int degree)	{		this.basicToCardinal2D(this.getBasicFromCardinal2D(cardinal, width, height, degree), dual, width, height, 2 * degree + 1);	} /* end cardinalToDual2D */		/*------------------------------------------------------------------*/	private void coefficientToGradient1D(final double[] c)	{		final double[] h = { 0.0, 1.0 / 2.0 };		final double[] s = new double[c.length];		this.antiSymmetricFirMirrorOffBounds1D(h, c, s);		System.arraycopy(s, 0, c, 0, s.length);	} /* end coefficientToGradient1D */		/*------------------------------------------------------------------*/	private void coefficientToSamples1D(final double[] c)	{		final double[] h = { 2.0 / 3.0, 1.0 / 6.0 };		final double[] s = new double[c.length];		this.symmetricFirMirrorOffBounds1D(h, c, s);		System.arraycopy(s, 0, c, 0, s.length);	} /* end coefficientToSamples1D */		/*------------------------------------------------------------------*/	private void coefficientToXYGradient2D(final float[] basic, final float[] xGradient, final float[] yGradient, final int width, final int height)	{		final double[] hLine = new double[width];		final double[] hData = new double[width];		final double[] vLine = new double[height];		int workload = 2 * (width + height);		turboRegProgressBar.addWorkload(workload);		for (int y = 0; ((y < height) && (!this.t.isInterrupted())); y++)		{			this.extractRow(basic, y, hLine);			System.arraycopy(hLine, 0, hData, 0, width);			this.coefficientToGradient1D(hLine);			turboRegProgressBar.stepProgressBar();			workload--;			this.coefficientToSamples1D(hData);			this.putRow(xGradient, y, hLine);			this.putRow(yGradient, y, hData);			turboRegProgressBar.stepProgressBar();			workload--;		}		for (int x = 0; ((x < width) && (!this.t.isInterrupted())); x++)		{			this.extractColumn(xGradient, width, x, vLine);			this.coefficientToSamples1D(vLine);			this.putColumn(xGradient, width, x, vLine);			turboRegProgressBar.stepProgressBar();			workload--;			this.extractColumn(yGradient, width, x, vLine);			this.coefficientToGradient1D(vLine);			this.putColumn(yGradient, width, x, vLine);			turboRegProgressBar.stepProgressBar();			workload--;		}		turboRegProgressBar.skipProgressBar(workload);		turboRegProgressBar.workloadDone(2 * (width + height));	} /* end coefficientToXYGradient2D */		/*------------------------------------------------------------------*/	private void dualToCardinal2D(final float[] dual, final float[] cardinal, final int width, final int height, final int degree)	{		this.basicToCardinal2D(this.getBasicFromCardinal2D(dual, width, height, 2 * degree + 1), cardinal, width, height, degree);	} /* end dualToCardinal2D */		/*------------------------------------------------------------------*/	private void extractColumn(final float[] array, final int width, int x, final double[] column)	{		for (int i = 0; (i < column.length); i++)		{			column[i] = array[x];			x += width;		}	} /* end extractColumn */		/*------------------------------------------------------------------*/	private void extractRow(final float[] array, int y, final double[] row)	{		y *= row.length;		for (int i = 0; (i < row.length); i++)		{			row[i] = array[y++];		}	} /* end extractRow */		/*------------------------------------------------------------------*/	private float[] getBasicFromCardinal2D()	{		final float[] basic = new float[this.width * this.height];		final double[] hLine = new double[this.width];		final double[] vLine = new double[this.height];		turboRegProgressBar.addWorkload(this.width + this.height);		for (int y = 0; (y < this.height); y++)		{			this.extractRow(this.image, y, hLine);			this.samplesToInterpolationCoefficient1D(hLine, 3, 0.0);			this.putRow(basic, y, hLine);			turboRegProgressBar.stepProgressBar();		}		for (int x = 0; (x < this.width); x++)		{			this.extractColumn(basic, this.width, x, vLine);			this.samplesToInterpolationCoefficient1D(vLine, 3, 0.0);			this.putColumn(basic, this.width, x, vLine);			turboRegProgressBar.stepProgressBar();		}		turboRegProgressBar.workloadDone(this.width + this.height);		return (basic);	} /* end getBasicFromCardinal2D */		/*------------------------------------------------------------------*/	private float[] getBasicFromCardinal2D(final float[] cardinal, final int width, final int height, final int degree)	{		final float[] basic = new float[width * height];		final double[] hLine = new double[width];		final double[] vLine = new double[height];		int workload = width + height;		turboRegProgressBar.addWorkload(workload);		for (int y = 0; ((y < height) && (!this.t.isInterrupted())); y++)		{			this.extractRow(cardinal, y, hLine);			this.samplesToInterpolationCoefficient1D(hLine, degree, 0.0);			this.putRow(basic, y, hLine);			turboRegProgressBar.stepProgressBar();			workload--;		}		for (int x = 0; ((x < width) && (!this.t.isInterrupted())); x++)		{			this.extractColumn(basic, width, x, vLine);			this.samplesToInterpolationCoefficient1D(vLine, degree, 0.0);			this.putColumn(basic, width, x, vLine);			turboRegProgressBar.stepProgressBar();			workload--;		}		turboRegProgressBar.skipProgressBar(workload);		turboRegProgressBar.workloadDone(width + height);		return (basic);	} /* end getBasicFromCardinal2D */		/*------------------------------------------------------------------*/	private float[] getHalfDual2D(final float[] fullDual, final int fullWidth, final int fullHeight)	{		final int halfWidth = fullWidth / 2;		final int halfHeight = fullHeight / 2;		final double[] hLine = new double[fullWidth];		final double[] hData = new double[halfWidth];		final double[] vLine = new double[fullHeight];		final double[] vData = new double[halfHeight];		final float[] demiDual = new float[halfWidth * fullHeight];		final float[] halfDual = new float[halfWidth * halfHeight];		int workload = halfWidth + fullHeight;		turboRegProgressBar.addWorkload(workload);		for (int y = 0; ((y < fullHeight) && (!this.t.isInterrupted())); y++)		{			this.extractRow(fullDual, y, hLine);			this.reduceDual1D(hLine, hData);			this.putRow(demiDual, y, hData);			turboRegProgressBar.stepProgressBar();			workload--;		}		for (int x = 0; ((x < halfWidth) && (!this.t.isInterrupted())); x++)		{			this.extractColumn(demiDual, halfWidth, x, vLine);			this.reduceDual1D(vLine, vData);			this.putColumn(halfDual, halfWidth, x, vData);			turboRegProgressBar.stepProgressBar();			workload--;		}		turboRegProgressBar.skipProgressBar(workload);		turboRegProgressBar.workloadDone(halfWidth + fullHeight);		return (halfDual);	} /* end getHalfDual2D */		/*------------------------------------------------------------------*/	private double getInitialAntiCausalCoefficientMirrorOffBounds(final double[] c, final double z, final double tolerance)	{		return (z * c[c.length - 1] / (z - 1.0));	} /* end getInitialAntiCausalCoefficientMirrorOffBounds */		/*------------------------------------------------------------------*/	private double getInitialCausalCoefficientMirrorOffBounds(final double[] c, final double z, final double tolerance)	{		double z1 = z;		double zn = Math.pow(z, c.length);		double sum = (1.0 + z) * (c[0] + zn * c[c.length - 1]);		int horizon = c.length;		if(0.0 < tolerance)		{			horizon = 2 + (int) (Math.log(tolerance) / Math.log(Math.abs(z)));			horizon = (horizon < c.length) ? (horizon) : (c.length);		}		zn = zn * zn;		for (int n = 1; (n < (horizon - 1)); n++)		{			z1 = z1 * z;			zn = zn / z;			sum = sum + (z1 + zn) * c[n];		}		return (sum / (1.0 - Math.pow(z, 2 * c.length)));	} /* end getInitialCausalCoefficientMirrorOffBounds */		/*------------------------------------------------------------------*/	private void imageToXYGradient2D()	{		final double[] hLine = new double[this.width];		final double[] vLine = new double[this.height];		this.xGradient = new float[this.width * this.height];		this.yGradient = new float[this.width * this.height];		int workload = this.width + this.height;		turboRegProgressBar.addWorkload(workload);		for (int y = 0; ((y < this.height) && (!this.t.isInterrupted())); y++)		{			this.extractRow(this.image, y, hLine);			this.samplesToInterpolationCoefficient1D(hLine, 3, 0.0);			this.coefficientToGradient1D(hLine);			this.putRow(this.xGradient, y, hLine);			turboRegProgressBar.stepProgressBar();			workload--;		}		for (int x = 0; ((x < this.width) && (!this.t.isInterrupted())); x++)		{			this.extractColumn(this.image, this.width, x, vLine);			this.samplesToInterpolationCoefficient1D(vLine, 3, 0.0);			this.coefficientToGradient1D(vLine);			this.putColumn(this.yGradient, this.width, x, vLine);			turboRegProgressBar.stepProgressBar();			workload--;		}		turboRegProgressBar.skipProgressBar(workload);		turboRegProgressBar.workloadDone(this.width + this.height);	} /* end imageToXYGradient2D */		/*------------------------------------------------------------------*/	private void putColumn(final float[] array, final int width, int x, final double[] column)	{		for (int i = 0; (i < column.length); i++)		{			array[x] = (float) column[i];			x += width;		}	} /* end putColumn */		/*------------------------------------------------------------------*/	private void putRow(final float[] array, int y, final double[] row)	{		y *= row.length;		for (int i = 0; (i < row.length); i++)		{			array[y++] = (float) row[i];		}	} /* end putRow */		/*------------------------------------------------------------------*/	private void reduceDual1D(final double[] c, final double[] s)	{		final double h[] = { 6.0 / 16.0, 4.0 / 16.0, 1.0 / 16.0 };		if(2 <= s.length)		{			s[0] = h[0] * c[0] + h[1] * (c[0] + c[1]) + h[2] * (c[1] + c[2]);			for (int i = 2, j = 1; (j < (s.length - 1)); i += 2, j++)			{				s[j] = h[0] * c[i] + h[1] * (c[i - 1] + c[i + 1]) + h[2] * (c[i - 2] + c[i + 2]);			}			if(c.length == (2 * s.length))			{				s[s.length - 1] = h[0] * c[c.length - 2] + h[1] * (c[c.length - 3] + c[c.length - 1]) + h[2] * (c[c.length - 4] + c[c.length - 1]);			}			else			{				s[s.length - 1] = h[0] * c[c.length - 3] + h[1] * (c[c.length - 4] + c[c.length - 2]) + h[2] * (c[c.length - 5] + c[c.length - 1]);			}		}		else		{			switch (c.length)			{				case 3:				{					s[0] = h[0] * c[0] + h[1] * (c[0] + c[1]) + h[2] * (c[1] + c[2]);					break;				}				case 2:				{					s[0] = h[0] * c[0] + h[1] * (c[0] + c[1]) + 2.0 * h[2] * c[1];					break;				}			}		}	} /* end reduceDual1D */		/*------------------------------------------------------------------*/	private void samplesToInterpolationCoefficient1D(final double[] c, final int degree, final double tolerance)	{		double[] z = new double[0];		double lambda = 1.0;		switch (degree)		{			case 3:			{				z = new double[1];				z[0] = Math.sqrt(3.0) - 2.0;				break;			}			case 7:			{				z = new double[3];				z[0] = -0.5352804307964381655424037816816460718339231523426924148812;				z[1] = -0.122554615192326690515272264359357343605486549427295558490763;				z[2] = -0.0091486948096082769285930216516478534156925639545994482648003;				break;			}		}		if(c.length == 1)		{			return;		}		for (int k = 0; (k < z.length); k++)		{			lambda *= (1.0 - z[k]) * (1.0 - 1.0 / z[k]);		}		for (int n = 0; (n < c.length); n++)		{			c[n] = c[n] * lambda;		}		for (int k = 0; (k < z.length); k++)		{			c[0] = this.getInitialCausalCoefficientMirrorOffBounds(c, z[k], tolerance);			for (int n = 1; (n < c.length); n++)			{				c[n] = c[n] + z[k] * c[n - 1];			}			c[c.length - 1] = this.getInitialAntiCausalCoefficientMirrorOffBounds(c, z[k], tolerance);			for (int n = c.length - 2; (0 <= n); n--)			{				c[n] = z[k] * (c[n + 1] - c[n]);			}		}	} /* end samplesToInterpolationCoefficient1D */		/*------------------------------------------------------------------*/	private void symmetricFirMirrorOffBounds1D(final double[] h, final double[] c, final double[] s)	{		switch (h.length)		{			case 2:			{				if(2 <= c.length)				{					s[0] = h[0] * c[0] + h[1] * (c[0] + c[1]);					for (int i = 1; (i < (s.length - 1)); i++)					{						s[i] = h[0] * c[i] + h[1] * (c[i - 1] + c[i + 1]);					}					s[s.length - 1] = h[0] * c[c.length - 1] + h[1] * (c[c.length - 2] + c[c.length - 1]);				}				else				{					s[0] = (h[0] + 2.0 * h[1]) * c[0];				}				break;			}			case 4:			{				if(6 <= c.length)				{					s[0] = h[0] * c[0] + h[1] * (c[0] + c[1]) + h[2] * (c[1] + c[2]) + h[3] * (c[2] + c[3]);					s[1] = h[0] * c[1] + h[1] * (c[0] + c[2]) + h[2] * (c[0] + c[3]) + h[3] * (c[1] + c[4]);					s[2] = h[0] * c[2] + h[1] * (c[1] + c[3]) + h[2] * (c[0] + c[4]) + h[3] * (c[0] + c[5]);					for (int i = 3; (i < (s.length - 3)); i++)					{						s[i] = h[0] * c[i] + h[1] * (c[i - 1] + c[i + 1]) + h[2] * (c[i - 2] + c[i + 2]) + h[3] * (c[i - 3] + c[i + 3]);					}					s[s.length - 3] = h[0] * c[c.length - 3] + h[1] * (c[c.length - 4] + c[c.length - 2]) + h[2] * (c[c.length - 5] + c[c.length - 1]) + h[3] * (c[c.length - 6] + c[c.length - 1]);					s[s.length - 2] = h[0] * c[c.length - 2] + h[1] * (c[c.length - 3] + c[c.length - 1]) + h[2] * (c[c.length - 4] + c[c.length - 1]) + h[3] * (c[c.length - 5] + c[c.length - 2]);					s[s.length - 1] = h[0] * c[c.length - 1] + h[1] * (c[c.length - 2] + c[c.length - 1]) + h[2] * (c[c.length - 3] + c[c.length - 2]) + h[3] * (c[c.length - 4] + c[c.length - 3]);				}				else				{					switch (c.length)					{						case 5:						{							s[0] = h[0] * c[0] + h[1] * (c[0] + c[1]) + h[2] * (c[1] + c[2]) + h[3] * (c[2] + c[3]);							s[1] = h[0] * c[1] + h[1] * (c[0] + c[2]) + h[2] * (c[0] + c[3]) + h[3] * (c[1] + c[4]);							s[2] = h[0] * c[2] + h[1] * (c[1] + c[3]) + (h[2] + h[3]) * (c[0] + c[4]);							s[3] = h[0] * c[3] + h[1] * (c[2] + c[4]) + h[2] * (c[1] + c[4]) + h[3] * (c[0] + c[3]);							s[4] = h[0] * c[4] + h[1] * (c[3] + c[4]) + h[2] * (c[2] + c[3]) + h[3] * (c[1] + c[2]);							break;						}						case 4:						{							s[0] = h[0] * c[0] + h[1] * (c[0] + c[1]) + h[2] * (c[1] + c[2]) + h[3] * (c[2] + c[3]);							s[1] = h[0] * c[1] + h[1] * (c[0] + c[2]) + h[2] * (c[0] + c[3]) + h[3] * (c[1] + c[3]);							s[2] = h[0] * c[2] + h[1] * (c[1] + c[3]) + h[2] * (c[0] + c[3]) + h[3] * (c[0] + c[2]);							s[3] = h[0] * c[3] + h[1] * (c[2] + c[3]) + h[2] * (c[1] + c[2]) + h[3] * (c[0] + c[1]);							break;						}						case 3:						{							s[0] = h[0] * c[0] + h[1] * (c[0] + c[1]) + h[2] * (c[1] + c[2]) + 2.0 * h[3] * c[2];							s[1] = h[0] * c[1] + (h[1] + h[2]) * (c[0] + c[2]) + 2.0 * h[3] * c[1];							s[2] = h[0] * c[2] + h[1] * (c[1] + c[2]) + h[2] * (c[0] + c[1]) + 2.0 * h[3] * c[0];							break;						}						case 2:						{							s[0] = (h[0] + h[1] + h[3]) * c[0] + (h[1] + 2.0 * h[2] + h[3]) * c[1];							s[1] = (h[0] + h[1] + h[3]) * c[1] + (h[1] + 2.0 * h[2] + h[3]) * c[0];							break;						}						case 1:						{							s[0] = (h[0] + 2.0 * (h[1] + h[2] + h[3])) * c[0];							break;						}					}				}				break;			}		}	} /* end symmetricFirMirrorOffBounds1D */	} /* end class turboRegImage *//* * ==================================================================== | turboRegMask \=================================================================== *//********************************************************************* * This class is responsible for the mask preprocessing that takes place concurrently with user-interface events. It contains methods to compute the mask pyramids. ********************************************************************/class turboRegMask implements Runnable{ /* begin class turboRegMask */		/*	 * .................................................................... Private variables ....................................................................	 */	private final Stack<float[]> pyramid = new Stack<float[]>();	private Thread t;	private float[] mask;	private int width;	private int height;	private int pyramidDepth;		/*	 * .................................................................... Public methods ....................................................................	 */		/*********************************************************************	 * Set to <code>true</code> every pixel of the full-size mask.	 ********************************************************************/	public void clearMask()	{		int k = 0;		turboRegProgressBar.addWorkload(this.height);		for (int y = 0; (y < this.height); y++)		{			for (int x = 0; (x < this.width); x++)			{				this.mask[k++] = 1.0F;			}			turboRegProgressBar.stepProgressBar();		}		turboRegProgressBar.workloadDone(this.height);	} /* end clearMask */		/*********************************************************************	 * Return the full-size mask array.	 ********************************************************************/	public float[] getMask()	{		return (this.mask);	} /* end getMask */		/*********************************************************************	 * Return the pyramid as a <code>Stack</code> object. A single pyramid level consists of	 * <p>	 * <table border="1">	 * <tr>	 * <th><code>isTarget</code></th>	 * <th>ML*</th>	 * <th>ML</th>	 * </tr>	 * <tr>	 * <td>true</td>	 * <td>mask samples</td>	 * <td>mask samples</td>	 * </tr>	 * <tr>	 * <td>false</td>	 * <td>mask samples</td>	 * <td>mask samples</td>	 * </tr>	 * </table>	 * 	 * @see turboRegImage#getPyramid()	 ********************************************************************/	public Stack<float[]> getPyramid()	{		return (this.pyramid);	} /* end getPyramid */		/*********************************************************************	 * Return the thread associated with this <code>turboRegMask</code> object.	 ********************************************************************/	public Thread getThread()	{		return (this.t);	} /* end getThread */		/*********************************************************************	 * Start the mask precomputations, which are interruptible.	 ********************************************************************/	@Override	public void run()	{		this.buildPyramid();	} /* end run */		/*********************************************************************	 * Set the depth up to which the pyramids should be computed.	 * 	 * @see turboRegMask#getPyramid()	 ********************************************************************/	public void setPyramidDepth(final int pyramidDepth)	{		this.pyramidDepth = pyramidDepth;	} /* end setPyramidDepth */		/*********************************************************************	 * Converts the pixel array of the incoming <code>ImagePlus</code> object into a local <code>boolean</code> array.	 * 	 * @param imp	 *            <code>ImagePlus</code> object to preprocess.	 ********************************************************************/	public turboRegMask(final ImagePlus imp)	{		this.t = new Thread(this);		this.t.setDaemon(true);		this.width = imp.getWidth();		this.height = imp.getHeight();		int k = 0;		turboRegProgressBar.addWorkload(this.height);		this.mask = new float[this.width * this.height];		if(imp.getType() == ImagePlus.GRAY8)		{			final byte[] pixels = (byte[]) imp.getProcessor().getPixels();			for (int y = 0; (y < this.height); y++)			{				for (int x = 0; (x < this.width); x++, k++)				{					this.mask[k] = pixels[k];				}				turboRegProgressBar.stepProgressBar();			}		}		else if(imp.getType() == ImagePlus.GRAY16)		{			final short[] pixels = (short[]) imp.getProcessor().getPixels();			for (int y = 0; (y < this.height); y++)			{				for (int x = 0; (x < this.width); x++, k++)				{					this.mask[k] = pixels[k];				}				turboRegProgressBar.stepProgressBar();			}		}		else if(imp.getType() == ImagePlus.GRAY32)		{			final float[] pixels = (float[]) imp.getProcessor().getPixels();			for (int y = 0; (y < this.height); y++)			{				for (int x = 0; (x < this.width); x++, k++)				{					this.mask[k] = pixels[k];				}				turboRegProgressBar.stepProgressBar();			}		}		turboRegProgressBar.workloadDone(this.height);	} /* end turboRegMask */		/*	 * .................................................................... Private methods ....................................................................	 */		/*------------------------------------------------------------------*/	private void buildPyramid()	{		int fullWidth;		int fullHeight;		float[] fullMask = this.mask;		int halfWidth = this.width;		int halfHeight = this.height;		for (int depth = 1; ((depth < this.pyramidDepth) && (!this.t.isInterrupted())); depth++)		{			fullWidth = halfWidth;			fullHeight = halfHeight;			halfWidth /= 2;			halfHeight /= 2;			final float[] halfMask = this.getHalfMask2D(fullMask, fullWidth, fullHeight);			this.pyramid.push(halfMask);			fullMask = halfMask;		}	} /* end buildPyramid */		/*------------------------------------------------------------------*/	private float[] getHalfMask2D(final float[] fullMask, final int fullWidth, final int fullHeight)	{		final int halfWidth = fullWidth / 2;		final int halfHeight = fullHeight / 2;		final boolean oddWidth = ((2 * halfWidth) != fullWidth);		int workload = 2 * halfHeight;		final float[] halfMask = new float[halfWidth * halfHeight];		int k = 0;		for (int y = 0; ((y < halfHeight) && (!this.t.isInterrupted())); y++)		{			for (int x = 0; (x < halfWidth); x++)			{				halfMask[k++] = 0.0F;			}			turboRegProgressBar.stepProgressBar();			workload--;		}		k = 0;		int n = 0;		for (int y = 0; ((y < (halfHeight - 1)) && (!this.t.isInterrupted())); y++)		{			for (int x = 0; (x < (halfWidth - 1)); x++)			{				halfMask[k] += Math.abs(fullMask[n++]);				halfMask[k] += Math.abs(fullMask[n]);				halfMask[++k] += Math.abs(fullMask[n++]);			}			halfMask[k] += Math.abs(fullMask[n++]);			halfMask[k++] += Math.abs(fullMask[n++]);			if(oddWidth)			{				n++;			}			for (int x = 0; (x < (halfWidth - 1)); x++)			{				halfMask[k - halfWidth] += Math.abs(fullMask[n]);				halfMask[k] += Math.abs(fullMask[n++]);				halfMask[k - halfWidth] += Math.abs(fullMask[n]);				halfMask[k - halfWidth + 1] += Math.abs(fullMask[n]);				halfMask[k] += Math.abs(fullMask[n]);				halfMask[++k] += Math.abs(fullMask[n++]);			}			halfMask[k - halfWidth] += Math.abs(fullMask[n]);			halfMask[k] += Math.abs(fullMask[n++]);			halfMask[k - halfWidth] += Math.abs(fullMask[n]);			halfMask[k++] += Math.abs(fullMask[n++]);			if(oddWidth)			{				n++;			}			k -= halfWidth;			turboRegProgressBar.stepProgressBar();			workload--;		}		for (int x = 0; (x < (halfWidth - 1)); x++)		{			halfMask[k] += Math.abs(fullMask[n++]);			halfMask[k] += Math.abs(fullMask[n]);			halfMask[++k] += Math.abs(fullMask[n++]);		}		halfMask[k] += Math.abs(fullMask[n++]);		halfMask[k++] += Math.abs(fullMask[n++]);		if(oddWidth)		{			n++;		}		k -= halfWidth;		for (int x = 0; (x < (halfWidth - 1)); x++)		{			halfMask[k] += Math.abs(fullMask[n++]);			halfMask[k] += Math.abs(fullMask[n]);			halfMask[++k] += Math.abs(fullMask[n++]);		}		halfMask[k] += Math.abs(fullMask[n++]);		halfMask[k] += Math.abs(fullMask[n]);		turboRegProgressBar.stepProgressBar();		workload--;		turboRegProgressBar.skipProgressBar(workload);		turboRegProgressBar.workloadDone(2 * halfHeight);		return (halfMask);	} /* end getHalfMask2D */	} /* end class turboRegMask *//* * ==================================================================== | turboRegPointAction \=================================================================== *//********************************************************************* * This class implements the various listeners that are in charge of user interactions when dealing with landmarks. It overrides the listeners of ImageJ, if any. Those are restored upon restitution of this <code>ImageCanvas</code> object to ImageJ. ********************************************************************/class turboRegPointAction extends ImageCanvas implements FocusListener, AdjustmentListener, KeyListener, MouseListener, MouseMotionListener{ /* begin class turboRegPointAction */		private static final long serialVersionUID = 1L;	/*	 * .................................................................... Private variables ....................................................................	 */		private ImagePlus mainImp;	private ImagePlus secondaryImp;	private turboRegPointHandler mainPh;	private turboRegPointHandler secondaryPh;	private turboRegPointToolbar tb;		/*	 * .................................................................... Public methods ....................................................................	 */		/*********************************************************************	 * Listen to <code>AdjustmentEvent</code> events.	 * 	 * @param e	 *            Ignored.	 ********************************************************************/	@Override	public synchronized void adjustmentValueChanged(AdjustmentEvent e)	{		this.updateAndDraw();	} /* adjustmentValueChanged */		/*********************************************************************	 * Listen to <code>focusGained</code> events.	 * 	 * @param e	 *            Ignored.	 ********************************************************************/	@Override	public void focusGained(final FocusEvent e)	{		this.updateAndDraw();	} /* end focusGained */		/*********************************************************************	 * Listen to <code>focusGained</code> events.	 * 	 * @param e	 *            Ignored.	 ********************************************************************/	@Override	public void focusLost(final FocusEvent e)	{		this.updateAndDraw();	} /* end focusLost */		/*********************************************************************	 * Listen to <code>keyPressed</code> events.	 * 	 * @param e	 *            The expected key codes are as follows:	 *            <ul>	 *            <li><code>KeyEvent.VK_COMMA</code>: display the previous slice, if any;</li>	 *            <li><code>KeyEvent.VK_DOWN</code>: move down the current landmark;</li>	 *            <li><code>KeyEvent.VK_LEFT</code>: move the current landmark to the left;</li>	 *            <li><code>KeyEvent.VK_PERIOD</code>: display the next slice, if any;</li>	 *            <li><code>KeyEvent.VK_SPACE</code>: select the current landmark;</li>	 *            <li><code>KeyEvent.VK_RIGHT</code>: move the current landmark to the right;</li>	 *            <li><code>KeyEvent.VK_UP</code>: move up the current landmark.</li>	 *            </ul>	 ********************************************************************/	@Override	public void keyPressed(final KeyEvent e)	{		switch (e.getKeyCode())		{			case KeyEvent.VK_COMMA:			{				if(1 < this.mainImp.getCurrentSlice())				{					this.mainImp.setSlice(this.mainImp.getCurrentSlice() - 1);					this.updateStatus();				}				return;			}			case KeyEvent.VK_PERIOD:			{				if(this.mainImp.getCurrentSlice() < this.mainImp.getStackSize())				{					this.mainImp.setSlice(this.mainImp.getCurrentSlice() + 1);					this.updateStatus();				}				return;			}		}		final int x = this.mainPh.getPoint().x;		final int y = this.mainPh.getPoint().y;		switch (e.getKeyCode())		{			case KeyEvent.VK_DOWN:			{				this.mainPh.movePoint(this.mainImp.getWindow().getCanvas().screenX(x), this.mainImp.getWindow().getCanvas().screenY(y + (int) Math.ceil(1.0 / this.mainImp.getWindow().getCanvas().getMagnification())));				this.mainImp.setRoi(this.mainPh);				break;			}			case KeyEvent.VK_LEFT:			{				this.mainPh.movePoint(this.mainImp.getWindow().getCanvas().screenX(x - (int) Math.ceil(1.0 / this.mainImp.getWindow().getCanvas().getMagnification())), this.mainImp.getWindow().getCanvas().screenY(y));				this.mainImp.setRoi(this.mainPh);				break;			}			case KeyEvent.VK_RIGHT:			{				this.mainPh.movePoint(this.mainImp.getWindow().getCanvas().screenX(x + (int) Math.ceil(1.0 / this.mainImp.getWindow().getCanvas().getMagnification())), this.mainImp.getWindow().getCanvas().screenY(y));				this.mainImp.setRoi(this.mainPh);				break;			}			case KeyEvent.VK_SPACE:			{				break;			}			case KeyEvent.VK_UP:			{				this.mainPh.movePoint(this.mainImp.getWindow().getCanvas().screenX(x), this.mainImp.getWindow().getCanvas().screenY(y - (int) Math.ceil(1.0 / this.mainImp.getWindow().getCanvas().getMagnification())));				this.mainImp.setRoi(this.mainPh);				break;			}		}		this.updateStatus();	} /* end keyPressed */		/*********************************************************************	 * Listen to <code>keyReleased</code> events.	 * 	 * @param e	 *            Ignored.	 ********************************************************************/	@Override	public void keyReleased(final KeyEvent e)	{} /* end keyReleased */		/*********************************************************************	 * Listen to <code>keyTyped</code> events.	 * 	 * @param e	 *            Ignored.	 ********************************************************************/	@Override	public void keyTyped(final KeyEvent e)	{} /* end keyTyped */		/*********************************************************************	 * Listen to <code>mouseClicked</code> events.	 * 	 * @param e	 *            Ignored.	 ********************************************************************/	@Override	public void mouseClicked(final MouseEvent e)	{} /* end mouseClicked */		/*********************************************************************	 * Listen to <code>mouseDragged</code> events. Move the position of the current point. Update the window's ROI. Update ImageJ's window.	 * 	 * @param e	 *            Event.	 * @see turboRegPointHandler#movePoint(int, int)	 * @see turboRegPointAction#mouseMoved(java.awt.event.MouseEvent)	 ********************************************************************/	@Override	public void mouseDragged(final MouseEvent e)	{		final int x = e.getX();		final int y = e.getY();		if(this.tb.getCurrentTool() == turboRegPointHandler.MOVE_CROSS)		{			this.mainPh.movePoint(x, y);			this.updateAndDraw();		}		this.mouseMoved(e);	} /* end mouseDragged */		/*********************************************************************	 * Listen to <code>mouseEntered</code> events. Change the cursor to a crosshair.	 * 	 * @param e	 *            Event.	 ********************************************************************/	@Override	public void mouseEntered(final MouseEvent e)	{		WindowManager.setCurrentWindow(this.mainImp.getWindow());		this.mainImp.getWindow().toFront();		this.mainImp.getWindow().getCanvas().setCursor(crosshairCursor);		this.updateAndDraw();	} /* end mouseEntered */		/*********************************************************************	 * Listen to <code>mouseExited</code> events. Change the cursor to the default cursor. Update the ImageJ status.	 * 	 * @param e	 *            Event.	 ********************************************************************/	@Override	public void mouseExited(final MouseEvent e)	{		this.mainImp.getWindow().getCanvas().setCursor(defaultCursor);		IJ.showStatus("");	} /* end mouseExited */		/*********************************************************************	 * Listen to <code>mouseMoved</code> events. Update the ImageJ status by displaying the value of the pixel under the cursor hot spot.	 * 	 * @param e	 *            Event.	 ********************************************************************/	@Override	public void mouseMoved(final MouseEvent e)	{		int x = e.getX();		int y = e.getY();		x = this.mainImp.getWindow().getCanvas().offScreenX(x);		y = this.mainImp.getWindow().getCanvas().offScreenY(y);		IJ.showStatus(this.mainImp.getLocationAsString(x, y) + this.getValueAsString(x, y));	} /* end mouseMoved */		/*********************************************************************	 * Listen to <code>mousePressed</code> events. Update the current point or call the ImageJ's zoom methods.	 * 	 * @param e	 *            Event.	 ********************************************************************/	@Override	public void mousePressed(final MouseEvent e)	{		final int x = e.getX();		final int y = e.getY();		switch (this.tb.getCurrentTool())		{			case turboRegPointHandler.MAGNIFIER:			{				int flags = e.getModifiers();				if((flags & (Event.ALT_MASK | Event.META_MASK | Event.CTRL_MASK)) != 0)				{					this.mainImp.getWindow().getCanvas().zoomOut(x, y);				}				else				{					this.mainImp.getWindow().getCanvas().zoomIn(x, y);				}				break;			}			case turboRegPointHandler.MOVE_CROSS:			{				final int currentPoint = this.mainPh.findClosest(x, y);				this.secondaryPh.setCurrentPoint(currentPoint);				this.updateAndDraw();				break;			}		}	} /* end mousePressed */		/*********************************************************************	 * Listen to <code>mouseReleased</code> events.	 * 	 * @param e	 *            Ignored.	 ********************************************************************/	@Override	public void mouseReleased(final MouseEvent e)	{} /* end mouseReleased */		/*********************************************************************	 * Set a reference to the <code>ImagePlus</code> and <code>turboRegPointHandler</code> objects of the other image.	 * 	 * @param secondaryImp	 *            <code>ImagePlus</code> object.	 * @param secondaryPh	 *            <code>turboRegPointHandler</code> object.	 ********************************************************************/	public void setSecondaryPointHandler(final ImagePlus secondaryImp, final turboRegPointHandler secondaryPh)	{		this.secondaryImp = secondaryImp;		this.secondaryPh = secondaryPh;	} /* end setSecondaryPointHandler */		/*********************************************************************	 * Keep a local copy of the <code>turboRegPointHandler</code> and <code>turboRegPointToolbar</code> objects.	 * 	 * @param imp	 *            <code>ImagePlus</code> object.	 * @param ph	 *            <code>turboRegPointHandler</code> object.	 * @param tb	 *            <code>turboRegPointToolbar</code> object.	 ********************************************************************/	public turboRegPointAction(final ImagePlus imp, final turboRegPointHandler ph, final turboRegPointToolbar tb)	{		super(imp);		this.mainImp = imp;		this.mainPh = ph;		this.tb = tb;	} /* end turboRegPointAction */		/*	 * .................................................................... Private methods ....................................................................	 */		/*------------------------------------------------------------------*/	private String getValueAsString(final int x, final int y)	{		final Calibration cal = this.imp.getCalibration();		final int[] v = this.imp.getPixel(x, y);		switch (this.imp.getType())		{			case ImagePlus.GRAY8:			case ImagePlus.GRAY16:			{				final double cValue = cal.getCValue(v[0]);				if(cValue == v[0])				{					return (", value=" + v[0]);				}				else				{					return (", value=" + IJ.d2s(cValue) + " (" + v[0] + ")");				}			}			case ImagePlus.GRAY32:			{				return (", value=" + Float.intBitsToFloat(v[0]));			}			case ImagePlus.COLOR_256:			{				return (", index=" + v[3] + ", value=" + v[0] + "," + v[1] + "," + v[2]);			}			case ImagePlus.COLOR_RGB:			{				return (", value=" + v[0] + "," + v[1] + "," + v[2]);			}			default:			{				return ("");			}		}	} /* end getValueAsString */		/*------------------------------------------------------------------*/	private void updateAndDraw()	{		this.mainImp.setRoi(this.mainPh);		this.secondaryImp.setRoi(this.secondaryPh);	} /* end updateAndDraw */		/*------------------------------------------------------------------*/	private void updateStatus()	{		final Point p = this.mainPh.getPoint();		if(p == null)		{			IJ.showStatus("");			return;		}		final int x = p.x;		final int y = p.y;		IJ.showStatus(this.imp.getLocationAsString(x, y) + this.getValueAsString(x, y));	} /* end updateStatus */	} /* end class turboRegPointAction *//* * ==================================================================== | turboRegPointHandler \=================================================================== *//********************************************************************* * This class implements the graphic interactions when dealing with landmarks. ********************************************************************/class turboRegPointHandler extends Roi {		private static final long serialVersionUID = 1L;		/* begin class turboRegPointHandler */		/*	 * .................................................................... Public variables ....................................................................	 */		/*********************************************************************	 * The magnifying tool is set in eleventh position to be coherent with ImageJ.	 ********************************************************************/	public static final int MAGNIFIER = 11;		/*********************************************************************	 * The moving tool is set in second position to be coherent with the <code>PointPicker_</code> plugin.	 ********************************************************************/	public static final int MOVE_CROSS = 1;		/*********************************************************************	 * The number of points we are willing to deal with is at most <code>4</code>.	 * 	 * @see turboRegDialog#transformation	 ********************************************************************/	public static final int NUM_POINTS = 4;		/*	 * .................................................................... Private variables ....................................................................	 */		/*********************************************************************	 * The drawn landmarks fit in a 11x11 matrix.	 ********************************************************************/	private static final int CROSS_HALFSIZE = 5;		/*********************************************************************	 * The golden ratio mathematical constant determines where to put the initial landmarks.	 ********************************************************************/	private static final double GOLDEN_RATIO = 0.5 * (Math.sqrt(5.0) - 1.0);		private final Point[] point = new Point[NUM_POINTS];	private final Color[] spectrum = new Color[NUM_POINTS];	private double[][] precisionPoint = new double[NUM_POINTS][2];	private int transformation;	private int currentPoint = 0;	private boolean interactive = true;	private boolean started = false;		/*	 * .................................................................... Public methods ....................................................................	 */		/*********************************************************************	 * Draw the landmarks. Outline the current point if the window has focus.	 * 	 * @param g	 *            Graphics environment.	 ********************************************************************/	@Override	public void draw(final Graphics g)	{		if(this.started)		{			final double mag = this.ic.getMagnification();			final int dx = (int) (mag / 2.0);			final int dy = (int) (mag / 2.0);			Point p;			if(this.transformation == turboRegDialog.RIGID_BODY)			{				if(this.currentPoint == 0)				{					for (int k = 1; (k < this.transformation); k++)					{						p = this.point[k];						g.setColor(this.spectrum[k]);						g.fillRect(this.ic.screenX(p.x) - 2 + dx, this.ic.screenY(p.y) - 2 + dy, 5, 5);					}					this.drawHorizon(g);					p = this.point[0];					g.setColor(this.spectrum[0]);					if(WindowManager.getCurrentImage() == this.imp)					{						g.drawLine(this.ic.screenX(p.x - CROSS_HALFSIZE - 1) + dx, this.ic.screenY(p.y - 1) + dy, this.ic.screenX(p.x - 1) + dx, this.ic.screenY(p.y - 1) + dy);						g.drawLine(this.ic.screenX(p.x - 1) + dx, this.ic.screenY(p.y - 1) + dy, this.ic.screenX(p.x - 1) + dx, this.ic.screenY(p.y - CROSS_HALFSIZE - 1) + dy);						g.drawLine(this.ic.screenX(p.x - 1) + dx, this.ic.screenY(p.y - CROSS_HALFSIZE - 1) + dy, this.ic.screenX(p.x + 1) + dx, this.ic.screenY(p.y - CROSS_HALFSIZE - 1) + dy);						g.drawLine(this.ic.screenX(p.x + 1) + dx, this.ic.screenY(p.y - CROSS_HALFSIZE - 1) + dy, this.ic.screenX(p.x + 1) + dx, this.ic.screenY(p.y - 1) + dy);						g.drawLine(this.ic.screenX(p.x + 1) + dx, this.ic.screenY(p.y - 1) + dy, this.ic.screenX(p.x + CROSS_HALFSIZE + 1) + dx, this.ic.screenY(p.y - 1) + dy);						g.drawLine(this.ic.screenX(p.x + CROSS_HALFSIZE + 1) + dx, this.ic.screenY(p.y - 1) + dy, this.ic.screenX(p.x + CROSS_HALFSIZE + 1) + dx, this.ic.screenY(p.y + 1) + dy);						g.drawLine(this.ic.screenX(p.x + CROSS_HALFSIZE + 1) + dx, this.ic.screenY(p.y + 1) + dy, this.ic.screenX(p.x + 1) + dx, this.ic.screenY(p.y + 1) + dy);						g.drawLine(this.ic.screenX(p.x + 1) + dx, this.ic.screenY(p.y + 1) + dy, this.ic.screenX(p.x + 1) + dx, this.ic.screenY(p.y + CROSS_HALFSIZE + 1) + dy);						g.drawLine(this.ic.screenX(p.x + 1) + dx, this.ic.screenY(p.y + CROSS_HALFSIZE + 1) + dy, this.ic.screenX(p.x - 1) + dx, this.ic.screenY(p.y + CROSS_HALFSIZE + 1) + dy);						g.drawLine(this.ic.screenX(p.x - 1) + dx, this.ic.screenY(p.y + CROSS_HALFSIZE + 1) + dy, this.ic.screenX(p.x - 1) + dx, this.ic.screenY(p.y + 1) + dy);						g.drawLine(this.ic.screenX(p.x - 1) + dx, this.ic.screenY(p.y + 1) + dy, this.ic.screenX(p.x - CROSS_HALFSIZE - 1) + dx, this.ic.screenY(p.y + 1) + dy);						g.drawLine(this.ic.screenX(p.x - CROSS_HALFSIZE - 1) + dx, this.ic.screenY(p.y + 1) + dy, this.ic.screenX(p.x - CROSS_HALFSIZE - 1) + dx, this.ic.screenY(p.y - 1) + dy);						if(1.0 < this.ic.getMagnification())						{							g.drawLine(this.ic.screenX(p.x - CROSS_HALFSIZE) + dx, this.ic.screenY(p.y) + dy, this.ic.screenX(p.x + CROSS_HALFSIZE) + dx, this.ic.screenY(p.y) + dy);							g.drawLine(this.ic.screenX(p.x) + dx, this.ic.screenY(p.y - CROSS_HALFSIZE) + dy, this.ic.screenX(p.x) + dx, this.ic.screenY(p.y + CROSS_HALFSIZE) + dy);						}					}					else					{						g.drawLine(this.ic.screenX(p.x - CROSS_HALFSIZE + 1) + dx, this.ic.screenY(p.y - CROSS_HALFSIZE + 1) + dy, this.ic.screenX(p.x + CROSS_HALFSIZE - 1) + dx, this.ic.screenY(p.y + CROSS_HALFSIZE - 1) + dy);						g.drawLine(this.ic.screenX(p.x - CROSS_HALFSIZE + 1) + dx, this.ic.screenY(p.y + CROSS_HALFSIZE - 1) + dy, this.ic.screenX(p.x + CROSS_HALFSIZE - 1) + dx, this.ic.screenY(p.y - CROSS_HALFSIZE + 1) + dy);					}				}				else				{					p = this.point[0];					g.setColor(this.spectrum[0]);					g.drawLine(this.ic.screenX(p.x - CROSS_HALFSIZE) + dx, this.ic.screenY(p.y) + dy, this.ic.screenX(p.x + CROSS_HALFSIZE) + dx, this.ic.screenY(p.y) + dy);					g.drawLine(this.ic.screenX(p.x) + dx, this.ic.screenY(p.y - CROSS_HALFSIZE) + dy, this.ic.screenX(p.x) + dx, this.ic.screenY(p.y + CROSS_HALFSIZE) + dy);					this.drawHorizon(g);					if(WindowManager.getCurrentImage() == this.imp)					{						this.drawArcs(g);						for (int k = 1; (k < this.transformation); k++)						{							p = this.point[k];							g.setColor(this.spectrum[k]);							if(k == this.currentPoint)							{								g.drawRect(this.ic.screenX(p.x) - 3 + dx, this.ic.screenY(p.y) - 3 + dy, 6, 6);							}							else							{								g.fillRect(this.ic.screenX(p.x) - 2 + dx, this.ic.screenY(p.y) - 2 + dy, 5, 5);							}						}					}					else					{						for (int k = 1; (k < this.transformation); k++)						{							p = this.point[k];							g.setColor(this.spectrum[k]);							if(k == this.currentPoint)							{								g.drawRect(this.ic.screenX(p.x) - 2 + dx, this.ic.screenY(p.y) - 2 + dy, 5, 5);							}							else							{								g.fillRect(this.ic.screenX(p.x) - 2 + dx, this.ic.screenY(p.y) - 2 + dy, 5, 5);							}						}					}				}			}			else			{				for (int k = 0; (k < (this.transformation / 2)); k++)				{					p = this.point[k];					g.setColor(this.spectrum[k]);					if(k == this.currentPoint)					{						if(WindowManager.getCurrentImage() == this.imp)						{							g.drawLine(this.ic.screenX(p.x - CROSS_HALFSIZE - 1) + dx, this.ic.screenY(p.y - 1) + dy, this.ic.screenX(p.x - 1) + dx, this.ic.screenY(p.y - 1) + dy);							g.drawLine(this.ic.screenX(p.x - 1) + dx, this.ic.screenY(p.y - 1) + dy, this.ic.screenX(p.x - 1) + dx, this.ic.screenY(p.y - CROSS_HALFSIZE - 1) + dy);							g.drawLine(this.ic.screenX(p.x - 1) + dx, this.ic.screenY(p.y - CROSS_HALFSIZE - 1) + dy, this.ic.screenX(p.x + 1) + dx, this.ic.screenY(p.y - CROSS_HALFSIZE - 1) + dy);							g.drawLine(this.ic.screenX(p.x + 1) + dx, this.ic.screenY(p.y - CROSS_HALFSIZE - 1) + dy, this.ic.screenX(p.x + 1) + dx, this.ic.screenY(p.y - 1) + dy);							g.drawLine(this.ic.screenX(p.x + 1) + dx, this.ic.screenY(p.y - 1) + dy, this.ic.screenX(p.x + CROSS_HALFSIZE + 1) + dx, this.ic.screenY(p.y - 1) + dy);							g.drawLine(this.ic.screenX(p.x + CROSS_HALFSIZE + 1) + dx, this.ic.screenY(p.y - 1) + dy, this.ic.screenX(p.x + CROSS_HALFSIZE + 1) + dx, this.ic.screenY(p.y + 1) + dy);							g.drawLine(this.ic.screenX(p.x + CROSS_HALFSIZE + 1) + dx, this.ic.screenY(p.y + 1) + dy, this.ic.screenX(p.x + 1) + dx, this.ic.screenY(p.y + 1) + dy);							g.drawLine(this.ic.screenX(p.x + 1) + dx, this.ic.screenY(p.y + 1) + dy, this.ic.screenX(p.x + 1) + dx, this.ic.screenY(p.y + CROSS_HALFSIZE + 1) + dy);							g.drawLine(this.ic.screenX(p.x + 1) + dx, this.ic.screenY(p.y + CROSS_HALFSIZE + 1) + dy, this.ic.screenX(p.x - 1) + dx, this.ic.screenY(p.y + CROSS_HALFSIZE + 1) + dy);							g.drawLine(this.ic.screenX(p.x - 1) + dx, this.ic.screenY(p.y + CROSS_HALFSIZE + 1) + dy, this.ic.screenX(p.x - 1) + dx, this.ic.screenY(p.y + 1) + dy);							g.drawLine(this.ic.screenX(p.x - 1) + dx, this.ic.screenY(p.y + 1) + dy, this.ic.screenX(p.x - CROSS_HALFSIZE - 1) + dx, this.ic.screenY(p.y + 1) + dy);							g.drawLine(this.ic.screenX(p.x - CROSS_HALFSIZE - 1) + dx, this.ic.screenY(p.y + 1) + dy, this.ic.screenX(p.x - CROSS_HALFSIZE - 1) + dx, this.ic.screenY(p.y - 1) + dy);							if(1.0 < this.ic.getMagnification())							{								g.drawLine(this.ic.screenX(p.x - CROSS_HALFSIZE) + dx, this.ic.screenY(p.y) + dy, this.ic.screenX(p.x + CROSS_HALFSIZE) + dx, this.ic.screenY(p.y) + dy);								g.drawLine(this.ic.screenX(p.x) + dx, this.ic.screenY(p.y - CROSS_HALFSIZE) + dy, this.ic.screenX(p.x) + dx, this.ic.screenY(p.y + CROSS_HALFSIZE) + dy);							}						}						else						{							g.drawLine(this.ic.screenX(p.x - CROSS_HALFSIZE + 1) + dx, this.ic.screenY(p.y - CROSS_HALFSIZE + 1) + dy, this.ic.screenX(p.x + CROSS_HALFSIZE - 1) + dx, this.ic.screenY(p.y + CROSS_HALFSIZE - 1) + dy);							g.drawLine(this.ic.screenX(p.x - CROSS_HALFSIZE + 1) + dx, this.ic.screenY(p.y + CROSS_HALFSIZE - 1) + dy, this.ic.screenX(p.x + CROSS_HALFSIZE - 1) + dx, this.ic.screenY(p.y - CROSS_HALFSIZE + 1) + dy);						}					}					else					{						g.drawLine(this.ic.screenX(p.x - CROSS_HALFSIZE) + dx, this.ic.screenY(p.y) + dy, this.ic.screenX(p.x + CROSS_HALFSIZE) + dx, this.ic.screenY(p.y) + dy);						g.drawLine(this.ic.screenX(p.x) + dx, this.ic.screenY(p.y - CROSS_HALFSIZE) + dy, this.ic.screenX(p.x) + dx, this.ic.screenY(p.y + CROSS_HALFSIZE) + dy);					}				}			}			if(this.updateFullWindow)			{				this.updateFullWindow = false;				this.imp.draw();			}		}	} /* end draw */		/*********************************************************************	 * Set the current point as that which is closest to (x, y).	 * 	 * @param x	 *            Horizontal coordinate in canvas units.	 * @param y	 *            Vertical coordinate in canvas units.	 ********************************************************************/	public int findClosest(int x, int y)	{		x = this.ic.offScreenX(x);		y = this.ic.offScreenY(y);		int closest = 0;		Point p = this.point[closest];		double distance = (double) (x - p.x) * (double) (x - p.x) + (double) (y - p.y) * (double) (y - p.y);		double candidate;		if(this.transformation == turboRegDialog.RIGID_BODY)		{			for (int k = 1; (k < this.transformation); k++)			{				p = this.point[k];				candidate = (double) (x - p.x) * (double) (x - p.x) + (double) (y - p.y) * (double) (y - p.y);				if(candidate < distance)				{					distance = candidate;					closest = k;				}			}		}		else		{			for (int k = 1; (k < (this.transformation / 2)); k++)			{				p = this.point[k];				candidate = (double) (x - p.x) * (double) (x - p.x) + (double) (y - p.y) * (double) (y - p.y);				if(candidate < distance)				{					distance = candidate;					closest = k;				}			}		}		this.currentPoint = closest;		return (this.currentPoint);	} /* end findClosest */		/*********************************************************************	 * Return the current point as a <code>Point</code> object.	 ********************************************************************/	public Point getPoint()	{		return (this.point[this.currentPoint]);	} /* end getPoint */		/*********************************************************************	 * Return all landmarks as an array <code>double[transformation / 2][2]</code>, except for a rigid-body transformation for which the array has size <code>double[3][2]</code>.	 ********************************************************************/	public double[][] getPoints()	{		if(this.interactive)		{			if(this.transformation == turboRegDialog.RIGID_BODY)			{				double[][] points = new double[this.transformation][2];				for (int k = 0; (k < this.transformation); k++)				{					points[k][0] = this.point[k].x;					points[k][1] = this.point[k].y;				}				return (points);			}			else			{				double[][] points = new double[this.transformation / 2][2];				for (int k = 0; (k < (this.transformation / 2)); k++)				{					points[k][0] = this.point[k].x;					points[k][1] = this.point[k].y;				}				return (points);			}		}		else		{			return (this.precisionPoint);		}	} /* end getPoints */		/*********************************************************************	 * Modify the location of the current point. Clip the admissible range to the image size.	 * 	 * @param x	 *            Desired new horizontal coordinate in canvas units.	 * @param y	 *            Desired new vertical coordinate in canvas units.	 ********************************************************************/	public void movePoint(int x, int y)	{		this.interactive = true;		x = this.ic.offScreenX(x);		y = this.ic.offScreenY(y);		x = (x < 0) ? (0) : (x);		x = (this.imp.getWidth() <= x) ? (this.imp.getWidth() - 1) : (x);		y = (y < 0) ? (0) : (y);		y = (this.imp.getHeight() <= y) ? (this.imp.getHeight() - 1) : (y);		if((this.transformation == turboRegDialog.RIGID_BODY) && (this.currentPoint != 0))		{			final Point p = new Point(x, y);			final Point q = this.point[3 - this.currentPoint];			final double radius = 0.5 * Math.sqrt((this.ic.screenX(p.x) - this.ic.screenX(q.x)) * (this.ic.screenX(p.x) - this.ic.screenX(q.x)) + (this.ic.screenY(p.y) - this.ic.screenY(q.y)) * (this.ic.screenY(p.y) - this.ic.screenY(q.y)));			if(CROSS_HALFSIZE < radius)			{				this.point[this.currentPoint].x = x;				this.point[this.currentPoint].y = y;			}		}		else		{			this.point[this.currentPoint].x = x;			this.point[this.currentPoint].y = y;		}	} /* end movePoint */		/*********************************************************************	 * Set a new current point.	 * 	 * @param currentPoint	 *            New current point index.	 ********************************************************************/	public void setCurrentPoint(final int currentPoint)	{		this.currentPoint = currentPoint;	} /* end setCurrentPoint */		/*********************************************************************	 * Set new position for all landmarks, without clipping.	 * 	 * @param precisionPoint	 *            New coordinates in canvas units.	 ********************************************************************/	public void setPoints(final double[][] precisionPoint)	{		this.interactive = false;		if(this.transformation == turboRegDialog.RIGID_BODY)		{			for (int k = 0; (k < this.transformation); k++)			{				this.point[k].x = (int) Math.round(precisionPoint[k][0]);				this.point[k].y = (int) Math.round(precisionPoint[k][1]);				this.precisionPoint[k][0] = precisionPoint[k][0];				this.precisionPoint[k][1] = precisionPoint[k][1];			}		}		else		{			for (int k = 0; (k < (this.transformation / 2)); k++)			{				this.point[k].x = (int) Math.round(precisionPoint[k][0]);				this.point[k].y = (int) Math.round(precisionPoint[k][1]);				this.precisionPoint[k][0] = precisionPoint[k][0];				this.precisionPoint[k][1] = precisionPoint[k][1];			}		}	} /* end setPoints */		/*********************************************************************	 * Reset the landmarks to their initial position for the given transformation.	 * 	 * @param transformation	 *            Transformation code.	 ********************************************************************/	public void setTransformation(final int transformation)	{		this.interactive = true;		this.transformation = transformation;		final int width = this.imp.getWidth();		final int height = this.imp.getHeight();		this.currentPoint = 0;		switch (transformation)		{			case turboRegDialog.TRANSLATION:			{				this.point[0] = new Point(Math.round((float) (Math.floor(0.5 * width))), Math.round((float) (Math.floor(0.5 * height))));				break;			}			case turboRegDialog.RIGID_BODY:			{				this.point[0] = new Point(Math.round((float) (Math.floor(0.5 * width))), Math.round((float) (Math.floor(0.5 * height))));				this.point[1] = new Point(Math.round((float) (Math.floor(0.5 * width))), Math.round((float) (Math.ceil(0.25 * GOLDEN_RATIO * height))));				this.point[2] = new Point(Math.round((float) (Math.floor(0.5 * width))), height - Math.round((float) (Math.ceil(0.25 * GOLDEN_RATIO * height))));				break;			}			case turboRegDialog.SCALED_ROTATION:			{				this.point[0] = new Point(Math.round((float) (Math.floor(0.25 * GOLDEN_RATIO * width))), Math.round((float) (Math.floor(0.5 * height))));				this.point[1] = new Point(width - Math.round((float) (Math.ceil(0.25 * GOLDEN_RATIO * width))), Math.round((float) (Math.floor(0.5 * height))));				break;			}			case turboRegDialog.AFFINE:			{				this.point[0] = new Point(Math.round((float) (Math.floor(0.5 * width))), Math.round((float) (Math.floor(0.25 * GOLDEN_RATIO * height))));				this.point[1] = new Point(Math.round((float) (Math.floor(0.25 * GOLDEN_RATIO * width))), height - Math.round((float) (Math.ceil(0.25 * GOLDEN_RATIO * height))));				this.point[2] = new Point(width - Math.round((float) (Math.ceil(0.25 * GOLDEN_RATIO * width))), height - Math.round((float) (Math.ceil(0.25 * GOLDEN_RATIO * height))));				break;			}			case turboRegDialog.BILINEAR:			{				this.point[0] = new Point(Math.round((float) (Math.floor(0.25 * GOLDEN_RATIO * width))), Math.round((float) (Math.floor(0.25 * GOLDEN_RATIO * height))));				this.point[1] = new Point(Math.round((float) (Math.floor(0.25 * GOLDEN_RATIO * width))), height - Math.round((float) (Math.ceil(0.25 * GOLDEN_RATIO * height))));				this.point[2] = new Point(width - Math.round((float) (Math.ceil(0.25 * GOLDEN_RATIO * width))), Math.round((float) (Math.floor(0.25 * GOLDEN_RATIO * height))));				this.point[3] = new Point(width - Math.round((float) (Math.ceil(0.25 * GOLDEN_RATIO * width))), height - Math.round((float) (Math.ceil(0.25 * GOLDEN_RATIO * height))));				break;			}		}		this.setSpectrum();		this.imp.updateAndDraw();	} /* end setTransformation */		/*********************************************************************	 * Keep a local copy of the points and of the transformation.	 ********************************************************************/	public turboRegPointHandler(final double[][] precisionPoint, final int transformation)	{		super(0, 0, 0, 0);		this.setImage(null);		this.transformation = transformation;		this.precisionPoint = precisionPoint;		this.interactive = false;	} /* end turboRegPointHandler */		/*********************************************************************	 * Keep a local copy of the <code>ImagePlus</code> object. Set the landmarks to their initial position for the given transformation.	 * 	 * @param imp	 *            <code>ImagePlus</code> object.	 * @param transformation	 *            Transformation code.	 * @see turboRegDialog#restoreAll()	 ********************************************************************/	public turboRegPointHandler(final ImagePlus imp, final int transformation)	{		super(0, 0, imp.getWidth(), imp.getHeight());		this.setImage(imp);		this.transformation = transformation;		this.setTransformation(transformation);		imp.setRoi(this);		this.started = true;	} /* end turboRegPointHandler */		/*	 * .................................................................... Private methods ....................................................................	 */		/*------------------------------------------------------------------*/	private void drawArcs(final Graphics g)	{		final double mag = this.ic.getMagnification();		final int dx = (int) (mag / 2.0);		final int dy = (int) (mag / 2.0);		final Point p = this.point[1];		final Point q = this.point[2];		final double x0 = this.ic.screenX(p.x) + this.ic.screenX(q.x);		final double y0 = this.ic.screenY(p.y) + this.ic.screenY(q.y);		final double dx0 = this.ic.screenX(p.x) - this.ic.screenX(q.x);		final double dy0 = this.ic.screenY(p.y) - this.ic.screenY(q.y);		final double radius = 0.5 * Math.sqrt(dx0 * dx0 + dy0 * dy0);		final double orientation = Math.atan2(dx0, dy0);		final double spacerAngle = Math.asin(CROSS_HALFSIZE / radius);		g.setColor(this.spectrum[1]);		g.drawArc((int) Math.round(0.5 * x0 - radius) + dx, (int) Math.round(0.5 * y0 - radius) + dy, (int) Math.round(2.0 * radius), (int) Math.round(2.0 * radius), (int) Math.round((orientation + spacerAngle + Math.PI) * 180.0 / Math.PI), (int) Math.round((Math.PI - 2.0 * spacerAngle) * 180.0 / Math.PI));		g.setColor(this.spectrum[2]);		g.drawArc((int) Math.round(0.5 * x0 - radius) + dx, (int) Math.round(0.5 * y0 - radius) + dy, (int) Math.round(2.0 * radius), (int) Math.round(2.0 * radius), (int) Math.round((orientation + spacerAngle) * 180.0 / Math.PI), (int) Math.round((Math.PI - 2.0 * spacerAngle) * 180.0 / Math.PI));	} /* end drawArcs */		/*------------------------------------------------------------------*/	private void drawHorizon(final Graphics g)	{		final double mag = this.ic.getMagnification();		final int dx = (int) (mag / 2.0);		final int dy = (int) (mag / 2.0);		final Point p = this.point[1];		final Point q = this.point[2];		final double x0 = this.ic.screenX(p.x) + this.ic.screenX(q.x);		final double y0 = this.ic.screenY(p.y) + this.ic.screenY(q.y);		final double dx0 = this.ic.screenX(p.x) - this.ic.screenX(q.x);		final double dy0 = this.ic.screenY(p.y) - this.ic.screenY(q.y);		final double radius = 0.5 * Math.sqrt(dx0 * dx0 + dy0 * dy0);		final double spacerAngle = Math.asin(CROSS_HALFSIZE / radius);		final double s0 = Math.sin(spacerAngle);		final double s = 0.5 * dx0 / radius;		final double c = 0.5 * dy0 / radius;		double u;		double v;		g.setColor(this.spectrum[1]);		u = 0.5 * (x0 + s0 * dx0);		v = 0.5 * (y0 + s0 * dy0);		if(Math.abs(s) < Math.abs(c))		{			g.drawLine(-dx, (int) Math.round(v + (u + 2.0 * dx) * s / c) + dy, (int) Math.round(mag * this.ic.getSrcRect().width - 1.0) + dx, (int) Math.round(v - (mag * this.ic.getSrcRect().width - 1.0 - u) * s / c) + dy);		}		else		{			g.drawLine((int) Math.round(u + (v + 2.0 * dy) * c / s) + dx, -dy, (int) Math.round(u - (mag * this.ic.getSrcRect().height - 1.0 - v) * c / s) + dx, (int) Math.round(mag * this.ic.getSrcRect().height - 1.0) + dy);		}		g.setColor(this.spectrum[2]);		u = 0.5 * (x0 - s0 * dx0);		v = 0.5 * (y0 - s0 * dy0);		if(Math.abs(s) < Math.abs(c))		{			g.drawLine(-dx, (int) Math.round(v + (u + 2.0 * dx) * s / c) + dy, (int) Math.round(mag * this.ic.getSrcRect().width - 1.0) + dx, (int) Math.round(v - (mag * this.ic.getSrcRect().width - 1.0 - u) * s / c) + dy);		}		else		{			g.drawLine((int) Math.round(u + (v + 2.0 * dy) * c / s) + dx, -dy, (int) Math.round(u - (mag * this.ic.getSrcRect().height - 1.0 - v) * c / s) + dx, (int) Math.round(mag * this.ic.getSrcRect().height - 1.0) + dy);		}	} /* end drawHorizon */		/*------------------------------------------------------------------*/	private void setSpectrum()	{		if(this.transformation == turboRegDialog.RIGID_BODY)		{			this.spectrum[0] = Color.green;			this.spectrum[1] = new Color(16, 119, 169);			this.spectrum[2] = new Color(119, 85, 51);		}		else		{			this.spectrum[0] = Color.green;			this.spectrum[1] = Color.yellow;			this.spectrum[2] = Color.magenta;			this.spectrum[3] = Color.cyan;		}	} /* end setSpectrum */	} /* end class turboRegPointHandler *//* * ==================================================================== | turboRegPointToolbar \=================================================================== *//********************************************************************* * This class implements the user interactions when dealing with the toolbar in the ImageJ's window. ********************************************************************/class turboRegPointToolbar extends Canvas implements MouseListener{ /* begin class turboRegPointToolbar */		private static final long serialVersionUID = 1L;		/*	 * .................................................................... Private variables ....................................................................	 */		/*********************************************************************	 * Same number of tools than in ImageJ version 1.22	 ********************************************************************/	private static final int NUM_TOOLS = 19;		/*********************************************************************	 * Same tool offset than in ImageJ version 1.22	 ********************************************************************/	private static final int OFFSET = 3;		/*********************************************************************	 * Same tool size than in ImageJ version 1.22	 ********************************************************************/	private static final int SIZE = 22;		private final Color gray = Color.lightGray;	private final Color brighter = this.gray.brighter();	private final Color darker = this.gray.darker();	private final Color evenDarker = this.darker.darker();	private final boolean[] down = new boolean[NUM_TOOLS];	private turboRegPointToolbar instance;	private Toolbar previousInstance;	private Graphics g;	private int currentTool = turboRegPointHandler.MOVE_CROSS;	private int x;	private int y;	private int xOffset;	private int yOffset;		/*	 * .................................................................... Public methods ....................................................................	 */		/*********************************************************************	 * Return the current tool index.	 ********************************************************************/	public int getCurrentTool()	{		return (this.currentTool);	} /* getCurrentTool */		/*********************************************************************	 * Listen to <code>mouseClicked</code> events.	 * 	 * @param e	 *            Ignored.	 ********************************************************************/	@Override	public void mouseClicked(final MouseEvent e)	{} /* end mouseClicked */		/*********************************************************************	 * Listen to <code>mouseEntered</code> events.	 * 	 * @param e	 *            Ignored.	 ********************************************************************/	@Override	public void mouseEntered(final MouseEvent e)	{} /* end mouseEntered */		/*********************************************************************	 * Listen to <code>mouseExited</code> events.	 * 	 * @param e	 *            Ignored.	 ********************************************************************/	@Override	public void mouseExited(final MouseEvent e)	{} /* end mouseExited */		/*********************************************************************	 * Listen to <code>mousePressed</code> events. Set the current tool index.	 * 	 * @param e	 *            Event.	 ********************************************************************/	@Override	public void mousePressed(final MouseEvent e)	{		final int x = e.getX();		// final int y = e.getY();		int newTool = 0;		for (int i = 0; (i < NUM_TOOLS); i++)		{			if(((i * SIZE) < x) && (x < (i * SIZE + SIZE)))			{				newTool = i;			}		}		this.setTool(newTool);	} /* mousePressed */		/*********************************************************************	 * Listen to <code>mouseReleased</code> events.	 * 	 * @param e	 *            Ignored.	 ********************************************************************/	@Override	public void mouseReleased(final MouseEvent e)	{} /* end mouseReleased */		/*********************************************************************	 * Draw the toolbar tools.	 * 	 * @param g	 *            Graphics environment.	 ********************************************************************/	@Override	public void paint(final Graphics g)	{		this.drawButtons(g);	} /* paint */		/*********************************************************************	 * Restore the ImageJ toolbar.	 ********************************************************************/	public void restorePreviousToolbar()	{		final Container container = this.instance.getParent();		final Component[] component = container.getComponents();		for (int i = 0; (i < component.length); i++)		{			if(component[i] == this.instance)			{				container.remove(this.instance);				container.add(this.previousInstance, i);				container.validate();				break;			}		}	} /* end restorePreviousToolbar */		/*********************************************************************	 * Set the current tool and update its appearance on the toolbar.	 * 	 * @param tool	 *            Tool index.	 ********************************************************************/	public void setTool(final int tool)	{		if(tool == this.currentTool)		{			return;		}		this.down[tool] = true;		this.down[this.currentTool] = false;		final Graphics g = this.getGraphics();		this.drawButton(g, this.currentTool);		this.drawButton(g, tool);		g.dispose();		this.showMessage(tool);		this.currentTool = tool;	} /* end setTool */		/*********************************************************************	 * Override the ImageJ toolbar by this <code>turboRegToolbar</code> object. Store a local copy of the ImageJ's toolbar for later restore.	 * 	 * @see turboRegPointToolbar#restorePreviousToolbar()	 ********************************************************************/	public turboRegPointToolbar(final Toolbar previousToolbar)	{		this.previousInstance = previousToolbar;		this.instance = this;		final Container container = previousToolbar.getParent();		final Component[] component = container.getComponents();		for (int i = 0; (i < component.length); i++)		{			if(component[i] == previousToolbar)			{				container.remove(previousToolbar);				container.add(this, i);				break;			}		}		this.resetButtons();		this.down[this.currentTool] = true;		this.setTool(this.currentTool);		this.setForeground(Color.black);		this.setBackground(this.gray);		this.addMouseListener(this);		container.validate();	} /* end turboRegPointToolbar */		/*	 * .................................................................... Private methods ....................................................................	 */		/*------------------------------------------------------------------*/	private void d(int x, int y)	{		x += this.xOffset;		y += this.yOffset;		this.g.drawLine(this.x, this.y, x, y);		this.x = x;		this.y = y;	} /* end d */		/*------------------------------------------------------------------*/	private void drawButton(final Graphics g, final int tool)	{		this.fill3DRect(g, tool * SIZE + 1, 1, SIZE, SIZE - 1, !this.down[tool]);		g.setColor(Color.black);		int x = tool * SIZE + OFFSET;		int y = OFFSET;		if(this.down[tool])		{			x++;			y++;		}		this.g = g;		switch (tool)		{			case turboRegPointHandler.MOVE_CROSS:			{				this.xOffset = x;				this.yOffset = y;				this.m(1, 1);				this.d(1, 10);				this.m(2, 2);				this.d(2, 9);				this.m(3, 3);				this.d(3, 8);				this.m(4, 4);				this.d(4, 7);				this.m(5, 5);				this.d(5, 7);				this.m(6, 6);				this.d(6, 7);				this.m(7, 7);				this.d(7, 7);				this.m(11, 5);				this.d(11, 6);				this.m(10, 7);				this.d(10, 8);				this.m(12, 7);				this.d(12, 8);				this.m(9, 9);				this.d(9, 11);				this.m(13, 9);				this.d(13, 11);				this.m(10, 12);				this.d(10, 15);				this.m(12, 12);				this.d(12, 15);				this.m(11, 9);				this.d(11, 10);				this.m(11, 13);				this.d(11, 15);				this.m(9, 13);				this.d(13, 13);				break;			}			case turboRegPointHandler.MAGNIFIER:			{				this.xOffset = x + 2;				this.yOffset = y + 2;				this.m(3, 0);				this.d(3, 0);				this.d(5, 0);				this.d(8, 3);				this.d(8, 5);				this.d(7, 6);				this.d(7, 7);				this.d(6, 7);				this.d(5, 8);				this.d(3, 8);				this.d(0, 5);				this.d(0, 3);				this.d(3, 0);				this.m(8, 8);				this.d(9, 8);				this.d(13, 12);				this.d(13, 13);				this.d(12, 13);				this.d(8, 9);				this.d(8, 8);				break;			}		}	} /* end drawButton */		/*------------------------------------------------------------------*/	private void drawButtons(final Graphics g)	{		for (int i = 0; (i < NUM_TOOLS); i++)		{			this.drawButton(g, i);		}	} /* end drawButtons */		/*------------------------------------------------------------------*/	private void fill3DRect(final Graphics g, final int x, final int y, final int width, final int height, final boolean raised)	{		if(raised)		{			g.setColor(this.gray);		}		else		{			g.setColor(this.darker);		}		g.fillRect(x + 1, y + 1, width - 2, height - 2);		g.setColor((raised) ? (this.brighter) : (this.evenDarker));		g.drawLine(x, y, x, y + height - 1);		g.drawLine(x + 1, y, x + width - 2, y);		g.setColor((raised) ? (this.evenDarker) : (this.brighter));		g.drawLine(x + 1, y + height - 1, x + width - 1, y + height - 1);		g.drawLine(x + width - 1, y, x + width - 1, y + height - 2);	} /* end fill3DRect */		/*------------------------------------------------------------------*/	private void m(final int x, final int y)	{		this.x = this.xOffset + x;		this.y = this.yOffset + y;	} /* end m */		/*------------------------------------------------------------------*/	private void resetButtons()	{		for (int i = 0; (i < NUM_TOOLS); i++)		{			this.down[i] = false;		}	} /* end resetButtons */		/*------------------------------------------------------------------*/	private void showMessage(final int tool)	{		switch (tool)		{			case turboRegPointHandler.MOVE_CROSS:			{				IJ.showStatus("Move crosses");				break;			}			case turboRegPointHandler.MAGNIFIER:			{				IJ.showStatus("Magnifying glass");				break;			}			default:			{				IJ.showStatus("Undefined operation");				break;			}		}	} /* end showMessage */	} /* end class turboRegPointToolbar *//* * ==================================================================== | turboRegProgressBar \=================================================================== *//********************************************************************* * This class implements the interactions when dealing with ImageJ's progress bar. ********************************************************************/class turboRegProgressBar{ /* begin class turboRegProgressBar */		/*	 * .................................................................... Private variables ....................................................................	 */		/*********************************************************************	 * Same time constant than in ImageJ version 1.22	 ********************************************************************/	private static final long TIME_QUANTUM = 50L;		private static volatile long lastTime = System.currentTimeMillis();	private static volatile int completed = 0;	private static volatile int workload = 0;		/*	 * .................................................................... Public methods ....................................................................	 */		/*********************************************************************	 * Extend the amount of work to perform by <code>batch</code>.	 * 	 * @param batch	 *            Additional amount of work that need be performed.	 ********************************************************************/	public static synchronized void addWorkload(final int batch)	{		workload += batch;	} /* end addWorkload */		/*********************************************************************	 * Erase the progress bar and cancel pending operations.	 ********************************************************************/	public static synchronized void resetProgressBar()	{		final long timeStamp = System.currentTimeMillis();		if((timeStamp - lastTime) < TIME_QUANTUM)		{			try			{				Thread.sleep(TIME_QUANTUM - timeStamp + lastTime);			}			catch (InterruptedException e)			{				IJ.log("Unexpected interruption exception " + e.getMessage());			}		}		lastTime = timeStamp;		completed = 0;		workload = 0;		IJ.showProgress(1.0);	} /* end resetProgressBar */		/*********************************************************************	 * Perform <code>stride</code> operations at once.	 * 	 * @param stride	 *            Amount of work that is skipped.	 ********************************************************************/	public static synchronized void skipProgressBar(final int stride)	{		completed += stride - 1;		stepProgressBar();	} /* end skipProgressBar */		/*********************************************************************	 * Perform <code>1</code> operation unit.	 ********************************************************************/	public static synchronized void stepProgressBar()	{		final long timeStamp = System.currentTimeMillis();		completed = completed + 1;		if((TIME_QUANTUM <= (timeStamp - lastTime)) | (completed == workload))		{			lastTime = timeStamp;			IJ.showProgress((double) completed / (double) workload);		}	} /* end stepProgressBar */		/*********************************************************************	 * Acknowledge that <code>batch</code> work has been performed.	 * 	 * @param batch	 *            Completed amount of work.	 ********************************************************************/	public static synchronized void workloadDone(final int batch)	{		workload -= batch;		completed -= batch;	} /* end workloadDone */	} /* end class turboRegProgressBar *//* * ==================================================================== | turboRegTransform \=================================================================== *//********************************************************************* * This class implements the algorithmic methods of the plugin. It refines the landmarks and computes the final images. ********************************************************************/class turboRegTransform{ /* begin class turboRegTransform */		/*	 * .................................................................... Private variables ....................................................................	 */		/*********************************************************************	 * Maximal number of registration iterations per level, when speed is requested at the expense of accuracy. This number must be corrected so that there are more iterations at the coarse levels of the pyramid than at the fine levels.	 * 	 * @see turboRegTransform#ITERATION_PROGRESSION	 ********************************************************************/	private static final int FEW_ITERATIONS = 5;		/*********************************************************************	 * Initial value of the Marquardt-Levenberg fudge factor.	 ********************************************************************/	private static final double FIRST_LAMBDA = 1.0;		/*********************************************************************	 * Update parameter of the Marquardt-Levenberg fudge factor.	 ********************************************************************/	private static final double LAMBDA_MAGSTEP = 4.0;		/*********************************************************************	 * Maximal number of registration iterations per level, when accuracy is requested at the expense of speed. This number must be corrected so that there are more iterations at the coarse levels of the pyramid than at the fine levels.	 * 	 * @see turboRegTransform#ITERATION_PROGRESSION	 ********************************************************************/	private static final int MANY_ITERATIONS = 10;		/*********************************************************************	 * Minimal update distance of the landmarks, in pixel units, when accuracy is requested at the expense of speed. This distance does not depend on the pyramid level.	 ********************************************************************/	private static final double PIXEL_HIGH_PRECISION = 0.001;		/*********************************************************************	 * Minimal update distance of the landmarks, in pixel units, when speed is requested at the expense of accuracy. This distance does not depend on the pyramid level.	 ********************************************************************/	private static final double PIXEL_LOW_PRECISION = 0.1;		/*********************************************************************	 * Multiplicative factor that determines how many more iterations are allowed for a pyramid level one unit coarser.	 ********************************************************************/	private static final int ITERATION_PROGRESSION = 2;		private final double[] dxWeight = new double[4];	private final double[] dyWeight = new double[4];	private final double[] xWeight = new double[4];	private final double[] yWeight = new double[4];	private final int[] xIndex = new int[4];	private final int[] yIndex = new int[4];	private turboRegImage sourceImg;	private turboRegImage targetImg;	private turboRegMask sourceMsk;	private turboRegMask targetMsk;	private turboRegPointHandler sourcePh;	// private turboRegPointHandler targetPh;	private double[][] sourcePoint;	private double[][] targetPoint;	private float[] inImg;	private float[] outImg;	private float[] xGradient;	private float[] yGradient;	private float[] inMsk;	private float[] outMsk;	private double targetJacobian;	private double s;	private double t;	private double x;	private double y;	private double c0;	private double c0u;	private double c0v;	private double c0uv;	private double c1;	private double c1u;	private double c1v;	private double c1uv;	private double c2;	private double c2u;	private double c2v;	private double c2uv;	private double c3;	private double c3u;	private double c3v;	private double c3uv;	private double pixelPrecision;	private int maxIterations;	private int p;	private int q;	private int inNx;	private int inNy;	private int outNx;	private int outNy;	private int twiceInNx;	private int twiceInNy;	private int transformation;	private int pyramidDepth;	private int iterationPower;	private int iterationCost;	private boolean accelerated;	private boolean interactive;		/*	 * .................................................................... Public methods ....................................................................	 */		/*********************************************************************	 * Append the current landmarks into a text file. Rigid format.	 * 	 * @param pathAndFilename	 *            Path and name of the file where batch results are being written.	 * @see turboRegDialog#loadLandmarks()	 ********************************************************************/	public void appendTransformation(final String pathAndFilename)	{		this.outNx = this.targetImg.getWidth();		this.outNy = this.targetImg.getHeight();		this.inNx = this.sourceImg.getWidth();		this.inNy = this.sourceImg.getHeight();		if(pathAndFilename == null)		{			return;		}		try		{			final FileWriter fw = new FileWriter(pathAndFilename, true);			fw.write("\n");			switch (this.transformation)			{				case turboRegDialog.TRANSLATION:				{					fw.write("TRANSLATION\n");					break;				}				case turboRegDialog.RIGID_BODY:				{					fw.write("RIGID_BODY\n");					break;				}				case turboRegDialog.SCALED_ROTATION:				{					fw.write("SCALED_ROTATION\n");					break;				}				case turboRegDialog.AFFINE:				{					fw.write("AFFINE\n");					break;				}				case turboRegDialog.BILINEAR:				{					fw.write("BILINEAR\n");					break;				}			}			fw.write("\n");			fw.write("Source size\n");			fw.write(this.inNx + "\t" + this.inNy + "\n");			fw.write("\n");			fw.write("Target size\n");			fw.write(this.outNx + "\t" + this.outNy + "\n");			fw.write("\n");			fw.write("Refined source landmarks\n");			if(this.transformation == turboRegDialog.RIGID_BODY)			{				for (int i = 0; (i < this.transformation); i++)				{					fw.write(this.sourcePoint[i][0] + "\t" + this.sourcePoint[i][1] + "\n");				}			}			else			{				for (int i = 0; (i < (this.transformation / 2)); i++)				{					fw.write(this.sourcePoint[i][0] + "\t" + this.sourcePoint[i][1] + "\n");				}			}			fw.write("\n");			fw.write("Target landmarks\n");			if(this.transformation == turboRegDialog.RIGID_BODY)			{				for (int i = 0; (i < this.transformation); i++)				{					fw.write(this.targetPoint[i][0] + "\t" + this.targetPoint[i][1] + "\n");				}			}			else			{				for (int i = 0; (i < (this.transformation / 2)); i++)				{					fw.write(this.targetPoint[i][0] + "\t" + this.targetPoint[i][1] + "\n");				}			}			fw.close();		}		catch (IOException e)		{			IJ.log("IOException exception " + e.getMessage());		}		catch (SecurityException e)		{			IJ.log("Security exception " + e.getMessage());		}	} /* end appendTransformation */		/*********************************************************************	 * Compute the final image.	 ********************************************************************/	public void doBatchFinalTransform(final float[] pixels)	{		if(this.accelerated)		{			this.inImg = this.sourceImg.getImage();		}		else		{			this.inImg = this.sourceImg.getCoefficient();		}		this.inNx = this.sourceImg.getWidth();		this.inNy = this.sourceImg.getHeight();		this.twiceInNx = 2 * this.inNx;		this.twiceInNy = 2 * this.inNy;		this.outImg = pixels;		this.outNx = this.targetImg.getWidth();		this.outNy = this.targetImg.getHeight();		final double[][] matrix = this.getTransformationMatrix(this.targetPoint, this.sourcePoint);		switch (this.transformation)		{			case turboRegDialog.TRANSLATION:			{				this.translationTransform(matrix);				break;			}			case turboRegDialog.RIGID_BODY:			case turboRegDialog.SCALED_ROTATION:			case turboRegDialog.AFFINE:			{				this.affineTransform(matrix);				break;			}			case turboRegDialog.BILINEAR:			{				this.bilinearTransform(matrix);				break;			}		}	} /* end doBatchFinalTransform */		/*********************************************************************	 * Compute the final image.	 ********************************************************************/	public ImagePlus doFinalTransform(final int width, final int height, final String filename)	{		if(this.accelerated)		{			this.inImg = this.sourceImg.getImage();		}		else		{			this.inImg = this.sourceImg.getCoefficient();		}		this.inMsk = this.sourceMsk.getMask();		this.inNx = this.sourceImg.getWidth();		this.inNy = this.sourceImg.getHeight();		this.twiceInNx = 2 * this.inNx;		this.twiceInNy = 2 * this.inNy;		final ImageStack is = new ImageStack(width, height);		final FloatProcessor dataFp = new FloatProcessor(width, height);		is.addSlice("Data", dataFp);		final FloatProcessor maskFp = new FloatProcessor(width, height);		is.addSlice("Mask", maskFp);		final ImagePlus imp = new ImagePlus("Output", is);		imp.setSlice(1);		this.outImg = (float[]) dataFp.getPixels();		imp.setSlice(2);		final float[] outMsk = (float[]) maskFp.getPixels();		this.outNx = imp.getWidth();		this.outNy = imp.getHeight();		final double[][] matrix = this.getTransformationMatrix(this.targetPoint, this.sourcePoint);		if(filename != null)		{			try			{				final FileWriter fw = new FileWriter(filename);				fw.write("Transformation\n");				switch (this.transformation)				{					case turboRegDialog.TRANSLATION:					{						fw.write("TRANSLATION\n");						break;					}					case turboRegDialog.RIGID_BODY:					{						fw.write("RIGID_BODY\n");						break;					}					case turboRegDialog.SCALED_ROTATION:					{						fw.write("SCALED_ROTATION\n");						break;					}					case turboRegDialog.AFFINE:					{						fw.write("AFFINE\n");						break;					}					case turboRegDialog.BILINEAR:					{						fw.write("BILINEAR\n");						break;					}				}								fw.write("\n");				fw.write("Matrix\n");				for (int i = 0; i < matrix[0].length; i++)				{					fw.write(matrix[0][i] + "\t" + matrix[1][i] + "\n");				}								fw.close();			}			catch (IOException e)			{				IJ.log("IOException exception " + e.getMessage());			}			catch (SecurityException e)			{				IJ.log("Security exception " + e.getMessage());			}		}		switch (this.transformation)		{			case turboRegDialog.TRANSLATION:			{				this.translationTransform(matrix, outMsk);				break;			}			case turboRegDialog.RIGID_BODY:			case turboRegDialog.SCALED_ROTATION:			case turboRegDialog.AFFINE:			{				this.affineTransform(matrix, outMsk);				break;			}			case turboRegDialog.BILINEAR:			{				this.bilinearTransform(matrix, outMsk);				break;			}		}		imp.setSlice(1);		imp.getProcessor().resetMinAndMax();		if(this.interactive)		{			imp.show();			imp.updateAndDraw();		}		return (imp);	} /* end doFinalTransform */		/*********************************************************************	 * Compute the final image.	 ********************************************************************/	public float[] doFinalTransform(final turboRegImage sourceImg, final turboRegPointHandler sourcePh, final turboRegImage targetImg, final turboRegPointHandler targetPh, final int transformation, final boolean accelerated, final String filename)	{		this.sourceImg = sourceImg;		this.targetImg = targetImg;		this.sourcePh = sourcePh;		// this.targetPh = targetPh;		this.transformation = transformation;		this.accelerated = accelerated;		this.sourcePoint = sourcePh.getPoints();		this.targetPoint = targetPh.getPoints();		if(accelerated)		{			this.inImg = sourceImg.getImage();		}		else		{			this.inImg = sourceImg.getCoefficient();		}		this.inNx = sourceImg.getWidth();		this.inNy = sourceImg.getHeight();		this.twiceInNx = 2 * this.inNx;		this.twiceInNy = 2 * this.inNy;		this.outNx = targetImg.getWidth();		this.outNy = targetImg.getHeight();		this.outImg = new float[this.outNx * this.outNy];		final double[][] matrix = this.getTransformationMatrix(this.targetPoint, this.sourcePoint);		try		{			final FileWriter fw = new FileWriter(filename);			fw.write("Transformation\n");			switch (this.transformation)			{				case turboRegDialog.TRANSLATION:				{					fw.write("TRANSLATION\n");					break;				}				case turboRegDialog.RIGID_BODY:				{					fw.write("RIGID_BODY\n");					break;				}				case turboRegDialog.SCALED_ROTATION:				{					fw.write("SCALED_ROTATION\n");					break;				}				case turboRegDialog.AFFINE:				{					fw.write("AFFINE\n");					break;				}				case turboRegDialog.BILINEAR:				{					fw.write("BILINEAR\n");					break;				}			}						fw.write("\n");			fw.write("Matrix\n");			for (int i = 0; i < matrix.length; i++)			{				fw.write(matrix[i][0] + "\t" + matrix[i][1] + "\n");			}						fw.close();		}		catch (IOException e)		{			IJ.log("IOException exception " + e.getMessage());		}		catch (SecurityException e)		{			IJ.log("Security exception " + e.getMessage());		}		switch (transformation)		{			case turboRegDialog.TRANSLATION:			{				this.translationTransform(matrix);				break;			}			case turboRegDialog.RIGID_BODY:			case turboRegDialog.SCALED_ROTATION:			case turboRegDialog.AFFINE:			{				this.affineTransform(matrix);				break;			}			case turboRegDialog.BILINEAR:			{				this.bilinearTransform(matrix);				break;			}		}		return (this.outImg);	} /* end doFinalTransform */		/*********************************************************************	 * Refine the landmarks.	 ********************************************************************/	@SuppressWarnings("unchecked")	public void doRegistration()	{		Stack<Object> sourceImgPyramid;		Stack<float[]> sourceMskPyramid;		Stack<Object> targetImgPyramid;		Stack<float[]> targetMskPyramid;		if(this.sourceMsk == null)		{			sourceImgPyramid = this.sourceImg.getPyramid();			sourceMskPyramid = null;			targetImgPyramid = (Stack<Object>) this.targetImg.getPyramid().clone();			targetMskPyramid = (Stack<float[]>) this.targetMsk.getPyramid().clone();		}		else		{			sourceImgPyramid = this.sourceImg.getPyramid();			sourceMskPyramid = this.sourceMsk.getPyramid();			targetImgPyramid = this.targetImg.getPyramid();			targetMskPyramid = this.targetMsk.getPyramid();		}		this.pyramidDepth = this.targetImg.getPyramidDepth();		this.iterationPower = (int) Math.pow(ITERATION_PROGRESSION, this.pyramidDepth);		turboRegProgressBar.addWorkload(this.pyramidDepth * this.maxIterations * this.iterationPower / ITERATION_PROGRESSION - (this.iterationPower - 1) / (ITERATION_PROGRESSION - 1));		this.iterationCost = 1;		this.scaleBottomDownLandmarks();		while (!targetImgPyramid.isEmpty())		{			this.iterationPower /= ITERATION_PROGRESSION;			if(this.transformation == turboRegDialog.BILINEAR)			{				this.inNx = ((Integer) sourceImgPyramid.pop()).intValue();				this.inNy = ((Integer) sourceImgPyramid.pop()).intValue();				this.inImg = (float[]) sourceImgPyramid.pop();				if(sourceMskPyramid == null)				{					this.inMsk = null;				}				else				{					this.inMsk = sourceMskPyramid.pop();				}				this.outNx = ((Integer) targetImgPyramid.pop()).intValue();				this.outNy = ((Integer) targetImgPyramid.pop()).intValue();				this.outImg = (float[]) targetImgPyramid.pop();				this.outMsk = targetMskPyramid.pop();			}			else			{				this.inNx = ((Integer) targetImgPyramid.pop()).intValue();				this.inNy = ((Integer) targetImgPyramid.pop()).intValue();				this.inImg = (float[]) targetImgPyramid.pop();				this.inMsk = targetMskPyramid.pop();				this.outNx = ((Integer) sourceImgPyramid.pop()).intValue();				this.outNy = ((Integer) sourceImgPyramid.pop()).intValue();				this.outImg = (float[]) sourceImgPyramid.pop();				this.xGradient = (float[]) sourceImgPyramid.pop();				this.yGradient = (float[]) sourceImgPyramid.pop();				if(sourceMskPyramid == null)				{					this.outMsk = null;				}				else				{					this.outMsk = sourceMskPyramid.pop();				}			}			this.twiceInNx = 2 * this.inNx;			this.twiceInNy = 2 * this.inNy;			switch (this.transformation)			{				case turboRegDialog.TRANSLATION:				{					this.targetJacobian = 1.0;					this.inverseMarquardtLevenbergOptimization(this.iterationPower * this.maxIterations - 1);					break;				}				case turboRegDialog.RIGID_BODY:				{					this.inverseMarquardtLevenbergRigidBodyOptimization(this.iterationPower * this.maxIterations - 1);					break;				}				case turboRegDialog.SCALED_ROTATION:				{					this.targetJacobian = (this.targetPoint[0][0] - this.targetPoint[1][0]) * (this.targetPoint[0][0] - this.targetPoint[1][0]) + (this.targetPoint[0][1] - this.targetPoint[1][1]) * (this.targetPoint[0][1] - this.targetPoint[1][1]);					this.inverseMarquardtLevenbergOptimization(this.iterationPower * this.maxIterations - 1);					break;				}				case turboRegDialog.AFFINE:				{					this.targetJacobian = (this.targetPoint[1][0] - this.targetPoint[2][0]) * this.targetPoint[0][1] + (this.targetPoint[2][0] - this.targetPoint[0][0]) * this.targetPoint[1][1] + (this.targetPoint[0][0] - this.targetPoint[1][0]) * this.targetPoint[2][1];					this.inverseMarquardtLevenbergOptimization(this.iterationPower * this.maxIterations - 1);					break;				}				case turboRegDialog.BILINEAR:				{					this.MarquardtLevenbergOptimization(this.iterationPower * this.maxIterations - 1);					break;				}			}			this.scaleUpLandmarks();			this.sourcePh.setPoints(this.sourcePoint);			this.iterationCost *= ITERATION_PROGRESSION;		}		this.iterationPower /= ITERATION_PROGRESSION;		if(this.transformation == turboRegDialog.BILINEAR)		{			this.inNx = this.sourceImg.getWidth();			this.inNy = this.sourceImg.getHeight();			this.inImg = this.sourceImg.getCoefficient();			if(this.sourceMsk == null)			{				this.inMsk = null;			}			else			{				this.inMsk = this.sourceMsk.getMask();			}			this.outNx = this.targetImg.getWidth();			this.outNy = this.targetImg.getHeight();			this.outImg = this.targetImg.getImage();			this.outMsk = this.targetMsk.getMask();		}		else		{			this.inNx = this.targetImg.getWidth();			this.inNy = this.targetImg.getHeight();			this.inImg = this.targetImg.getCoefficient();			this.inMsk = this.targetMsk.getMask();			this.outNx = this.sourceImg.getWidth();			this.outNy = this.sourceImg.getHeight();			this.outImg = this.sourceImg.getImage();			this.xGradient = this.sourceImg.getXGradient();			this.yGradient = this.sourceImg.getYGradient();			if(this.sourceMsk == null)			{				this.outMsk = null;			}			else			{				this.outMsk = this.sourceMsk.getMask();			}		}		this.twiceInNx = 2 * this.inNx;		this.twiceInNy = 2 * this.inNy;		if(this.accelerated)		{			turboRegProgressBar.skipProgressBar(this.iterationCost * (this.maxIterations - 1));		}		else		{			switch (this.transformation)			{				case turboRegDialog.RIGID_BODY:				{					this.inverseMarquardtLevenbergRigidBodyOptimization(this.maxIterations - 1);					break;				}				case turboRegDialog.TRANSLATION:				case turboRegDialog.SCALED_ROTATION:				case turboRegDialog.AFFINE:				{					this.inverseMarquardtLevenbergOptimization(this.maxIterations - 1);					break;				}				case turboRegDialog.BILINEAR:				{					this.MarquardtLevenbergOptimization(this.maxIterations - 1);					break;				}			}		}		this.sourcePh.setPoints(this.sourcePoint);		this.iterationPower = (int) Math.pow(ITERATION_PROGRESSION, this.pyramidDepth);		turboRegProgressBar.workloadDone(this.pyramidDepth * this.maxIterations * this.iterationPower / ITERATION_PROGRESSION - (this.iterationPower - 1) / (ITERATION_PROGRESSION - 1));	} /* end doRegistration */		/*********************************************************************	 * Save the current landmarks into a text file and return the path and name of the file. Rigid format.	 * 	 * @see turboRegDialog#loadLandmarks()	 ********************************************************************/	public String saveTransformation(String filename)	{		this.inNx = this.sourceImg.getWidth();		this.inNy = this.sourceImg.getHeight();//		this.outNx = this.targetImg.getWidth();//		this.outNy = this.targetImg.getHeight();		String path = "";		if(filename == null)		{			final Frame f = new Frame();			final FileDialog fd = new FileDialog(f, "Save landmarks", FileDialog.SAVE);			filename = "landmarks.txt";			fd.setFile(filename);			fd.setVisible(true);			path = fd.getDirectory();			filename = fd.getFile();			if((path == null) || (filename == null))			{				return ("");			}		}		try		{			final FileWriter fw = new FileWriter(path + filename);			fw.write("Transformation\n");			switch (this.transformation)			{				case turboRegDialog.TRANSLATION:				{					fw.write("TRANSLATION\n");					break;				}				case turboRegDialog.RIGID_BODY:				{					fw.write("RIGID_BODY\n");					break;				}				case turboRegDialog.SCALED_ROTATION:				{					fw.write("SCALED_ROTATION\n");					break;				}				case turboRegDialog.AFFINE:				{					fw.write("AFFINE\n");					break;				}				case turboRegDialog.BILINEAR:				{					fw.write("BILINEAR\n");					break;				}			}			fw.write("\n");			fw.write("Source size\n");			fw.write(this.inNx + "\t" + this.inNy + "\n");//			fw.write("\n");//			fw.write("Target size\n");//			fw.write(this.outNx + "\t" + this.outNy + "\n");			fw.write("\n");			fw.write("Refined source landmarks\n");			if(this.transformation == turboRegDialog.RIGID_BODY)			{				for (int i = 0; (i < this.transformation); i++)				{					fw.write(this.sourcePoint[i][0] + "\t" + this.sourcePoint[i][1] + "\n");				}			}			else			{				for (int i = 0; (i < (this.transformation / 2)); i++)				{					fw.write(this.sourcePoint[i][0] + "\t" + this.sourcePoint[i][1] + "\n");				}			}			fw.write("\n");//			fw.write("Target landmarks\n");//			if(this.transformation == turboRegDialog.RIGID_BODY)//			{//				for (int i = 0; (i < this.transformation); i++)//				{//					fw.write(this.targetPoint[i][0] + "\t" + this.targetPoint[i][1] + "\n");//				}//			}//			else//			{//				for (int i = 0; (i < (this.transformation / 2)); i++)//				{//					fw.write(this.targetPoint[i][0] + "\t" + this.targetPoint[i][1] + "\n");//				}//			}			final double[][] matrix = this.getTransformationMatrix(this.targetPoint, this.sourcePoint);						fw.write("\n");			fw.write("Matrix\n");			for (int i = 0; i < matrix.length; i++)			{				fw.write(matrix[i][0] + "\t" + matrix[i][1] + "\n");			}						fw.close();		}		catch (IOException e)		{			IJ.log("IOException exception " + e.getMessage());		}		catch (SecurityException e)		{			IJ.log("Security exception " + e.getMessage());		}		return (path + filename);	} /* end saveTransformation */		/*********************************************************************	 * Keep a local copy of most everything. Select among the pre-stored constants.	 * 	 * @param targetImg	 *            Target image pyramid.	 * @param targetMsk	 *            Target mask pyramid.	 * @param sourceImg	 *            Source image pyramid.	 * @param sourceMsk	 *            Source mask pyramid.	 * @param targetPh	 *            Target <code>turboRegPointHandler</code> object.	 * @param sourcePh	 *            Source <code>turboRegPointHandler</code> object.	 * @param transformation	 *            Transformation code.	 * @param accelerated	 *            Trade-off between speed and accuracy.	 * @param interactive	 *            Shows or hides the resulting image.	 ********************************************************************/	public turboRegTransform(final turboRegImage sourceImg, final turboRegMask sourceMsk, final turboRegPointHandler sourcePh, final turboRegImage targetImg, final turboRegMask targetMsk, final turboRegPointHandler targetPh, final int transformation, final boolean accelerated, final boolean interactive)	{		this.sourceImg = sourceImg;		this.sourceMsk = sourceMsk;		this.sourcePh = sourcePh;		this.targetImg = targetImg;		this.targetMsk = targetMsk;		// this.targetPh = targetPh;		this.transformation = transformation;		this.accelerated = accelerated;		this.interactive = interactive;		this.sourcePoint = sourcePh.getPoints();		this.targetPoint = targetPh.getPoints();		if(accelerated)		{			this.pixelPrecision = PIXEL_LOW_PRECISION;			this.maxIterations = FEW_ITERATIONS;		}		else		{			this.pixelPrecision = PIXEL_HIGH_PRECISION;			this.maxIterations = MANY_ITERATIONS;		}	} /* end turboRegTransform */		/*	 * .................................................................... Private methods ....................................................................	 */		/*------------------------------------------------------------------*/	private void affineTransform(final double[][] matrix)	{		double yx;		double yy;		double x0;		double y0;		int xMsk;		int yMsk;		int k = 0;		turboRegProgressBar.addWorkload(this.outNy);		yx = matrix[0][0];		yy = matrix[1][0];		for (int v = 0; (v < this.outNy); v++)		{			x0 = yx;			y0 = yy;			for (int u = 0; (u < this.outNx); u++)			{				this.x = x0;				this.y = y0;				xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));				yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));				if((0 <= xMsk) && (xMsk < this.inNx) && (0 <= yMsk) && (yMsk < this.inNy))				{					xMsk += yMsk * this.inNx;					if(this.accelerated)					{						this.outImg[k++] = this.inImg[xMsk];					}					else					{						this.xIndexes();						this.yIndexes();						this.x -= (0.0 <= this.x) ? ((int) this.x) : ((int) this.x - 1);						this.y -= (0.0 <= this.y) ? ((int) this.y) : ((int) this.y - 1);						this.xWeights();						this.yWeights();						this.outImg[k++] = (float) this.interpolate();					}				}				else				{					this.outImg[k++] = 0.0F;				}				x0 += matrix[0][1];				y0 += matrix[1][1];			}			yx += matrix[0][2];			yy += matrix[1][2];			turboRegProgressBar.stepProgressBar();		}		turboRegProgressBar.workloadDone(this.outNy);	} /* affineTransform */		/*------------------------------------------------------------------*/	private void affineTransform(final double[][] matrix, final float[] outMsk)	{		double yx;		double yy;		double x0;		double y0;		int xMsk;		int yMsk;		int k = 0;		turboRegProgressBar.addWorkload(this.outNy);		yx = matrix[0][0];		yy = matrix[1][0];		for (int v = 0; (v < this.outNy); v++)		{			x0 = yx;			y0 = yy;			for (int u = 0; (u < this.outNx); u++)			{				this.x = x0;				this.y = y0;				xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));				yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));				if((0 <= xMsk) && (xMsk < this.inNx) && (0 <= yMsk) && (yMsk < this.inNy))				{					xMsk += yMsk * this.inNx;					if(this.accelerated)					{						this.outImg[k] = this.inImg[xMsk];					}					else					{						this.xIndexes();						this.yIndexes();						this.x -= (0.0 <= this.x) ? ((int) this.x) : ((int) this.x - 1);						this.y -= (0.0 <= this.y) ? ((int) this.y) : ((int) this.y - 1);						this.xWeights();						this.yWeights();						this.outImg[k] = (float) this.interpolate();					}					outMsk[k++] = this.inMsk[xMsk];				}				else				{					this.outImg[k] = 0.0F;					outMsk[k++] = 0.0F;				}				x0 += matrix[0][1];				y0 += matrix[1][1];			}			yx += matrix[0][2];			yy += matrix[1][2];			turboRegProgressBar.stepProgressBar();		}		turboRegProgressBar.workloadDone(this.outNy);	} /* affineTransform */		/*------------------------------------------------------------------*/	private void bilinearTransform(final double[][] matrix)	{		double yx;		double yy;		double yxy;		double yyy;		double x0;		double y0;		int xMsk;		int yMsk;		int k = 0;		turboRegProgressBar.addWorkload(this.outNy);		yx = matrix[0][0];		yy = matrix[1][0];		yxy = 0.0;		yyy = 0.0;		for (int v = 0; (v < this.outNy); v++)		{			x0 = yx;			y0 = yy;			for (int u = 0; (u < this.outNx); u++)			{				this.x = x0;				this.y = y0;				xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));				yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));				if((0 <= xMsk) && (xMsk < this.inNx) && (0 <= yMsk) && (yMsk < this.inNy))				{					xMsk += yMsk * this.inNx;					if(this.accelerated)					{						this.outImg[k++] = this.inImg[xMsk];					}					else					{						this.xIndexes();						this.yIndexes();						this.x -= (0.0 <= this.x) ? ((int) this.x) : ((int) this.x - 1);						this.y -= (0.0 <= this.y) ? ((int) this.y) : ((int) this.y - 1);						this.xWeights();						this.yWeights();						this.outImg[k++] = (float) this.interpolate();					}				}				else				{					this.outImg[k++] = 0.0F;				}				x0 += matrix[0][1] + yxy;				y0 += matrix[1][1] + yyy;			}			yx += matrix[0][2];			yy += matrix[1][2];			yxy += matrix[0][3];			yyy += matrix[1][3];			turboRegProgressBar.stepProgressBar();		}		turboRegProgressBar.workloadDone(this.outNy);	} /* bilinearTransform */		/*------------------------------------------------------------------*/	private void bilinearTransform(final double[][] matrix, final float[] outMsk)	{		double yx;		double yy;		double yxy;		double yyy;		double x0;		double y0;		int xMsk;		int yMsk;		int k = 0;		turboRegProgressBar.addWorkload(this.outNy);		yx = matrix[0][0];		yy = matrix[1][0];		yxy = 0.0;		yyy = 0.0;		for (int v = 0; (v < this.outNy); v++)		{			x0 = yx;			y0 = yy;			for (int u = 0; (u < this.outNx); u++)			{				this.x = x0;				this.y = y0;				xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));				yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));				if((0 <= xMsk) && (xMsk < this.inNx) && (0 <= yMsk) && (yMsk < this.inNy))				{					xMsk += yMsk * this.inNx;					if(this.accelerated)					{						this.outImg[k] = this.inImg[xMsk];					}					else					{						this.xIndexes();						this.yIndexes();						this.x -= (0.0 <= this.x) ? ((int) this.x) : ((int) this.x - 1);						this.y -= (0.0 <= this.y) ? ((int) this.y) : ((int) this.y - 1);						this.xWeights();						this.yWeights();						this.outImg[k] = (float) this.interpolate();					}					outMsk[k++] = this.inMsk[xMsk];				}				else				{					this.outImg[k] = 0.0F;					outMsk[k++] = 0.0F;				}				x0 += matrix[0][1] + yxy;				y0 += matrix[1][1] + yyy;			}			yx += matrix[0][2];			yy += matrix[1][2];			yxy += matrix[0][3];			yyy += matrix[1][3];			turboRegProgressBar.stepProgressBar();		}		turboRegProgressBar.workloadDone(this.outNy);	} /* bilinearTransform */		/*------------------------------------------------------------------*/	private void computeBilinearGradientConstants()	{		final double u1 = this.targetPoint[0][0];		final double u2 = this.targetPoint[1][0];		final double u3 = this.targetPoint[2][0];		final double u4 = this.targetPoint[3][0];		final double v1 = this.targetPoint[0][1];		final double v2 = this.targetPoint[1][1];		final double v3 = this.targetPoint[2][1];		final double v4 = this.targetPoint[3][1];		// final double u12 = u1 - u2;		// final double u13 = u1 - u3;		// final double u14 = u1 - u4;		// final double u23 = u2 - u3;		// final double u24 = u2 - u4;		// final double u34 = u3 - u4;		final double v12 = v1 - v2;		final double v13 = v1 - v3;		final double v14 = v1 - v4;		final double v23 = v2 - v3;		final double v24 = v2 - v4;		final double v34 = v3 - v4;		final double uv12 = u1 * u2 * v12;		final double uv13 = u1 * u3 * v13;		final double uv14 = u1 * u4 * v14;		final double uv23 = u2 * u3 * v23;		final double uv24 = u2 * u4 * v24;		final double uv34 = u3 * u4 * v34;		final double det = uv12 * v34 - uv13 * v24 + uv14 * v23 + uv23 * v14 - uv24 * v13 + uv34 * v12;		this.c0 = (-uv34 * v2 + uv24 * v3 - uv23 * v4) / det;		this.c0u = (u3 * v3 * v24 - u2 * v2 * v34 - u4 * v4 * v23) / det;		this.c0v = (uv23 - uv24 + uv34) / det;		this.c0uv = (u4 * v23 - u3 * v24 + u2 * v34) / det;		this.c1 = (uv34 * v1 - uv14 * v3 + uv13 * v4) / det;		this.c1u = (-u3 * v3 * v14 + u1 * v1 * v34 + u4 * v4 * v13) / det;		this.c1v = (-uv13 + uv14 - uv34) / det;		this.c1uv = (-u4 * v13 + u3 * v14 - u1 * v34) / det;		this.c2 = (-uv24 * v1 + uv14 * v2 - uv12 * v4) / det;		this.c2u = (u2 * v2 * v14 - u1 * v1 * v24 - u4 * v4 * v12) / det;		this.c2v = (uv12 - uv14 + uv24) / det;		this.c2uv = (u4 * v12 - u2 * v14 + u1 * v24) / det;		this.c3 = (uv23 * v1 - uv13 * v2 + uv12 * v3) / det;		this.c3u = (-u2 * v2 * v13 + u1 * v1 * v23 + u3 * v3 * v12) / det;		this.c3v = (-uv12 + uv13 - uv23) / det;		this.c3uv = (-u3 * v1 + u2 * v13 + u3 * v2 - u1 * v23) / det;	} /* end computeBilinearGradientConstants */		/*------------------------------------------------------------------*/	private double getAffineMeanSquares(final double[][] sourcePoint, final double[][] matrix)	{		final double u1 = sourcePoint[0][0];		final double u2 = sourcePoint[1][0];		final double u3 = sourcePoint[2][0];		final double v1 = sourcePoint[0][1];		final double v2 = sourcePoint[1][1];		final double v3 = sourcePoint[2][1];		final double uv32 = u3 * v2 - u2 * v3;		final double uv21 = u2 * v1 - u1 * v2;		final double uv13 = u1 * v3 - u3 * v1;		final double det = uv32 + uv21 + uv13;		double yx;		double yy;		double x0;		double y0;		double difference;		double meanSquares = 0.0;		long area = 0L;		int xMsk;		int yMsk;		int k = 0;		if(this.outMsk == null)		{			yx = matrix[0][0];			yy = matrix[1][0];			for (int v = 0; (v < this.outNy); v++)			{				x0 = yx;				y0 = yy;				for (int u = 0; (u < this.outNx); u++, k++)				{					this.x = x0;					this.y = y0;					xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));					yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));					if((0 <= xMsk) && (xMsk < this.inNx) && (0 <= yMsk) && (yMsk < this.inNy))					{						if(this.inMsk[yMsk * this.inNx + xMsk] != 0.0F)						{							area++;							this.xIndexes();							this.yIndexes();							this.x -= (0.0 <= this.x) ? ((int) this.x) : ((int) this.x - 1);							this.y -= (0.0 <= this.y) ? ((int) this.y) : ((int) this.y - 1);							this.xWeights();							this.yWeights();							difference = this.outImg[k] - this.interpolate();							meanSquares += difference * difference;						}					}					x0 += matrix[0][1];					y0 += matrix[1][1];				}				yx += matrix[0][2];				yy += matrix[1][2];			}		}		else		{			yx = matrix[0][0];			yy = matrix[1][0];			for (int v = 0; (v < this.outNy); v++)			{				x0 = yx;				y0 = yy;				for (int u = 0; (u < this.outNx); u++, k++)				{					this.x = x0;					this.y = y0;					xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));					yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));					if((0 <= xMsk) && (xMsk < this.inNx) && (0 <= yMsk) && (yMsk < this.inNy))					{						if((this.outMsk[k] * this.inMsk[yMsk * this.inNx + xMsk]) != 0.0F)						{							area++;							this.xIndexes();							this.yIndexes();							this.x -= (0.0 <= this.x) ? ((int) this.x) : ((int) this.x - 1);							this.y -= (0.0 <= this.y) ? ((int) this.y) : ((int) this.y - 1);							this.xWeights();							this.yWeights();							difference = this.outImg[k] - this.interpolate();							meanSquares += difference * difference;						}					}					x0 += matrix[0][1];					y0 += matrix[1][1];				}				yx += matrix[0][2];				yy += matrix[1][2];			}		}		return (meanSquares / (area * Math.abs(det / this.targetJacobian)));	} /* getAffineMeanSquares */		/*------------------------------------------------------------------*/	private double getAffineMeanSquares(final double[][] sourcePoint, final double[][] matrix, final double[] gradient)	{		final double u1 = sourcePoint[0][0];		final double u2 = sourcePoint[1][0];		final double u3 = sourcePoint[2][0];		final double v1 = sourcePoint[0][1];		final double v2 = sourcePoint[1][1];		final double v3 = sourcePoint[2][1];		double uv32 = u3 * v2 - u2 * v3;		double uv21 = u2 * v1 - u1 * v2;		double uv13 = u1 * v3 - u3 * v1;		final double det = uv32 + uv21 + uv13;		final double u12 = (u1 - u2) / det;		final double u23 = (u2 - u3) / det;		final double u31 = (u3 - u1) / det;		final double v12 = (v1 - v2) / det;		final double v23 = (v2 - v3) / det;		final double v31 = (v3 - v1) / det;		double yx;		double yy;		double x0;		double y0;		double difference;		double meanSquares = 0.0;		double g0;		double g1;		double g2;		double dx0;		double dx1;		double dx2;		double dy0;		double dy1;		double dy2;		long area = 0L;		int xMsk;		int yMsk;		int k = 0;		uv32 /= det;		uv21 /= det;		uv13 /= det;		for (int i = 0; (i < this.transformation); i++)		{			gradient[i] = 0.0;		}		if(this.outMsk == null)		{			yx = matrix[0][0];			yy = matrix[1][0];			for (int v = 0; (v < this.outNy); v++)			{				x0 = yx;				y0 = yy;				for (int u = 0; (u < this.outNx); u++, k++)				{					this.x = x0;					this.y = y0;					xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));					yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));					if((0 <= xMsk) && (xMsk < this.inNx) && (0 <= yMsk) && (yMsk < this.inNy))					{						if(this.inMsk[yMsk * this.inNx + xMsk] != 0.0F)						{							area++;							this.xIndexes();							this.yIndexes();							this.x -= (0.0 <= this.x) ? ((int) this.x) : ((int) this.x - 1);							this.y -= (0.0 <= this.y) ? ((int) this.y) : ((int) this.y - 1);							this.xWeights();							this.yWeights();							difference = this.outImg[k] - this.interpolate();							meanSquares += difference * difference;							g0 = u23 * v - v23 * u + uv32;							g1 = u31 * v - v31 * u + uv13;							g2 = u12 * v - v12 * u + uv21;							dx0 = this.xGradient[k] * g0;							dy0 = this.yGradient[k] * g0;							dx1 = this.xGradient[k] * g1;							dy1 = this.yGradient[k] * g1;							dx2 = this.xGradient[k] * g2;							dy2 = this.yGradient[k] * g2;							gradient[0] += difference * dx0;							gradient[1] += difference * dy0;							gradient[2] += difference * dx1;							gradient[3] += difference * dy1;							gradient[4] += difference * dx2;							gradient[5] += difference * dy2;						}					}					x0 += matrix[0][1];					y0 += matrix[1][1];				}				yx += matrix[0][2];				yy += matrix[1][2];			}		}		else		{			yx = matrix[0][0];			yy = matrix[1][0];			for (int v = 0; (v < this.outNy); v++)			{				x0 = yx;				y0 = yy;				for (int u = 0; (u < this.outNx); u++, k++)				{					this.x = x0;					this.y = y0;					xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));					yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));					if((0 <= xMsk) && (xMsk < this.inNx) && (0 <= yMsk) && (yMsk < this.inNy))					{						if((this.outMsk[k] * this.inMsk[yMsk * this.inNx + xMsk]) != 0.0F)						{							area++;							this.xIndexes();							this.yIndexes();							this.x -= (0.0 <= this.x) ? ((int) this.x) : ((int) this.x - 1);							this.y -= (0.0 <= this.y) ? ((int) this.y) : ((int) this.y - 1);							this.xWeights();							this.yWeights();							difference = this.outImg[k] - this.interpolate();							meanSquares += difference * difference;							g0 = u23 * v - v23 * u + uv32;							g1 = u31 * v - v31 * u + uv13;							g2 = u12 * v - v12 * u + uv21;							dx0 = this.xGradient[k] * g0;							dy0 = this.yGradient[k] * g0;							dx1 = this.xGradient[k] * g1;							dy1 = this.yGradient[k] * g1;							dx2 = this.xGradient[k] * g2;							dy2 = this.yGradient[k] * g2;							gradient[0] += difference * dx0;							gradient[1] += difference * dy0;							gradient[2] += difference * dx1;							gradient[3] += difference * dy1;							gradient[4] += difference * dx2;							gradient[5] += difference * dy2;						}					}					x0 += matrix[0][1];					y0 += matrix[1][1];				}				yx += matrix[0][2];				yy += matrix[1][2];			}		}		return (meanSquares / (area * Math.abs(det / this.targetJacobian)));	} /* getAffineMeanSquares */		/*------------------------------------------------------------------*/	private double getAffineMeanSquares(final double[][] sourcePoint, final double[][] matrix, final double[][] hessian, final double[] gradient)	{		final double u1 = sourcePoint[0][0];		final double u2 = sourcePoint[1][0];		final double u3 = sourcePoint[2][0];		final double v1 = sourcePoint[0][1];		final double v2 = sourcePoint[1][1];		final double v3 = sourcePoint[2][1];		double uv32 = u3 * v2 - u2 * v3;		double uv21 = u2 * v1 - u1 * v2;		double uv13 = u1 * v3 - u3 * v1;		final double det = uv32 + uv21 + uv13;		final double u12 = (u1 - u2) / det;		final double u23 = (u2 - u3) / det;		final double u31 = (u3 - u1) / det;		final double v12 = (v1 - v2) / det;		final double v23 = (v2 - v3) / det;		final double v31 = (v3 - v1) / det;		double yx;		double yy;		double x0;		double y0;		double difference;		double meanSquares = 0.0;		double g0;		double g1;		double g2;		double dx0;		double dx1;		double dx2;		double dy0;		double dy1;		double dy2;		long area = 0L;		int xMsk;		int yMsk;		int k = 0;		uv32 /= det;		uv21 /= det;		uv13 /= det;		for (int i = 0; (i < this.transformation); i++)		{			gradient[i] = 0.0;			for (int j = 0; (j < this.transformation); j++)			{				hessian[i][j] = 0.0;			}		}		if(this.outMsk == null)		{			yx = matrix[0][0];			yy = matrix[1][0];			for (int v = 0; (v < this.outNy); v++)			{				x0 = yx;				y0 = yy;				for (int u = 0; (u < this.outNx); u++, k++)				{					this.x = x0;					this.y = y0;					xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));					yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));					if((0 <= xMsk) && (xMsk < this.inNx) && (0 <= yMsk) && (yMsk < this.inNy))					{						if(this.inMsk[yMsk * this.inNx + xMsk] != 0.0F)						{							area++;							this.xIndexes();							this.yIndexes();							this.x -= (0.0 <= this.x) ? ((int) this.x) : ((int) this.x - 1);							this.y -= (0.0 <= this.y) ? ((int) this.y) : ((int) this.y - 1);							this.xWeights();							this.yWeights();							difference = this.outImg[k] - this.interpolate();							meanSquares += difference * difference;							g0 = u23 * v - v23 * u + uv32;							g1 = u31 * v - v31 * u + uv13;							g2 = u12 * v - v12 * u + uv21;							dx0 = this.xGradient[k] * g0;							dy0 = this.yGradient[k] * g0;							dx1 = this.xGradient[k] * g1;							dy1 = this.yGradient[k] * g1;							dx2 = this.xGradient[k] * g2;							dy2 = this.yGradient[k] * g2;							gradient[0] += difference * dx0;							gradient[1] += difference * dy0;							gradient[2] += difference * dx1;							gradient[3] += difference * dy1;							gradient[4] += difference * dx2;							gradient[5] += difference * dy2;							hessian[0][0] += dx0 * dx0;							hessian[0][1] += dx0 * dy0;							hessian[0][2] += dx0 * dx1;							hessian[0][3] += dx0 * dy1;							hessian[0][4] += dx0 * dx2;							hessian[0][5] += dx0 * dy2;							hessian[1][1] += dy0 * dy0;							hessian[1][2] += dy0 * dx1;							hessian[1][3] += dy0 * dy1;							hessian[1][4] += dy0 * dx2;							hessian[1][5] += dy0 * dy2;							hessian[2][2] += dx1 * dx1;							hessian[2][3] += dx1 * dy1;							hessian[2][4] += dx1 * dx2;							hessian[2][5] += dx1 * dy2;							hessian[3][3] += dy1 * dy1;							hessian[3][4] += dy1 * dx2;							hessian[3][5] += dy1 * dy2;							hessian[4][4] += dx2 * dx2;							hessian[4][5] += dx2 * dy2;							hessian[5][5] += dy2 * dy2;						}					}					x0 += matrix[0][1];					y0 += matrix[1][1];				}				yx += matrix[0][2];				yy += matrix[1][2];			}		}		else		{			yx = matrix[0][0];			yy = matrix[1][0];			for (int v = 0; (v < this.outNy); v++)			{				x0 = yx;				y0 = yy;				for (int u = 0; (u < this.outNx); u++, k++)				{					this.x = x0;					this.y = y0;					xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));					yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));					if((0 <= xMsk) && (xMsk < this.inNx) && (0 <= yMsk) && (yMsk < this.inNy))					{						if((this.outMsk[k] * this.inMsk[yMsk * this.inNx + xMsk]) != 0.0F)						{							area++;							this.xIndexes();							this.yIndexes();							this.x -= (0.0 <= this.x) ? ((int) this.x) : ((int) this.x - 1);							this.y -= (0.0 <= this.y) ? ((int) this.y) : ((int) this.y - 1);							this.xWeights();							this.yWeights();							difference = this.outImg[k] - this.interpolate();							meanSquares += difference * difference;							g0 = u23 * v - v23 * u + uv32;							g1 = u31 * v - v31 * u + uv13;							g2 = u12 * v - v12 * u + uv21;							dx0 = this.xGradient[k] * g0;							dy0 = this.yGradient[k] * g0;							dx1 = this.xGradient[k] * g1;							dy1 = this.yGradient[k] * g1;							dx2 = this.xGradient[k] * g2;							dy2 = this.yGradient[k] * g2;							gradient[0] += difference * dx0;							gradient[1] += difference * dy0;							gradient[2] += difference * dx1;							gradient[3] += difference * dy1;							gradient[4] += difference * dx2;							gradient[5] += difference * dy2;							hessian[0][0] += dx0 * dx0;							hessian[0][1] += dx0 * dy0;							hessian[0][2] += dx0 * dx1;							hessian[0][3] += dx0 * dy1;							hessian[0][4] += dx0 * dx2;							hessian[0][5] += dx0 * dy2;							hessian[1][1] += dy0 * dy0;							hessian[1][2] += dy0 * dx1;							hessian[1][3] += dy0 * dy1;							hessian[1][4] += dy0 * dx2;							hessian[1][5] += dy0 * dy2;							hessian[2][2] += dx1 * dx1;							hessian[2][3] += dx1 * dy1;							hessian[2][4] += dx1 * dx2;							hessian[2][5] += dx1 * dy2;							hessian[3][3] += dy1 * dy1;							hessian[3][4] += dy1 * dx2;							hessian[3][5] += dy1 * dy2;							hessian[4][4] += dx2 * dx2;							hessian[4][5] += dx2 * dy2;							hessian[5][5] += dy2 * dy2;						}					}					x0 += matrix[0][1];					y0 += matrix[1][1];				}				yx += matrix[0][2];				yy += matrix[1][2];			}		}		for (int i = 1; (i < this.transformation); i++)		{			for (int j = 0; (j < i); j++)			{				hessian[i][j] = hessian[j][i];			}		}		return (meanSquares / (area * Math.abs(det / this.targetJacobian)));	} /* getAffineMeanSquares */		/*------------------------------------------------------------------*/	private double getBilinearMeanSquares(final double[][] matrix)	{		double yx;		double yy;		double yxy;		double yyy;		double x0;		double y0;		double difference;		double meanSquares = 0.0;		long area = 0L;		int xMsk;		int yMsk;		int k = 0;		if(this.inMsk == null)		{			yx = matrix[0][0];			yy = matrix[1][0];			yxy = 0.0;			yyy = 0.0;			for (int v = 0; (v < this.outNy); v++)			{				x0 = yx;				y0 = yy;				for (int u = 0; (u < this.outNx); u++, k++)				{					if(this.outMsk[k] != 0.0F)					{						this.x = x0;						this.y = y0;						xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));						yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));						if((0 <= xMsk) && (xMsk < this.inNx) && (0 <= yMsk) && (yMsk < this.inNy))						{							this.xIndexes();							this.yIndexes();							area++;							this.x -= (0.0 <= this.x) ? ((int) this.x) : ((int) this.x - 1);							this.y -= (0.0 <= this.y) ? ((int) this.y) : ((int) this.y - 1);							this.xWeights();							this.yWeights();							difference = this.interpolate() - this.outImg[k];							meanSquares += difference * difference;						}					}					x0 += matrix[0][1] + yxy;					y0 += matrix[1][1] + yyy;				}				yx += matrix[0][2];				yy += matrix[1][2];				yxy += matrix[0][3];				yyy += matrix[1][3];			}		}		else		{			yx = matrix[0][0];			yy = matrix[1][0];			yxy = 0.0;			yyy = 0.0;			for (int v = 0; (v < this.outNy); v++)			{				x0 = yx;				y0 = yy;				for (int u = 0; (u < this.outNx); u++, k++)				{					this.x = x0;					this.y = y0;					xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));					yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));					if((0 <= xMsk) && (xMsk < this.inNx) && (0 <= yMsk) && (yMsk < this.inNy))					{						xMsk += yMsk * this.inNx;						if((this.outMsk[k] * this.inMsk[xMsk]) != 0.0F)						{							this.xIndexes();							this.yIndexes();							area++;							this.x -= (0.0 <= this.x) ? ((int) this.x) : ((int) this.x - 1);							this.y -= (0.0 <= this.y) ? ((int) this.y) : ((int) this.y - 1);							this.xWeights();							this.yWeights();							difference = this.interpolate() - this.outImg[k];							meanSquares += difference * difference;						}					}					x0 += matrix[0][1] + yxy;					y0 += matrix[1][1] + yyy;				}				yx += matrix[0][2];				yy += matrix[1][2];				yxy += matrix[0][3];				yyy += matrix[1][3];			}		}		return (meanSquares / area);	} /* getBilinearMeanSquares */		/*------------------------------------------------------------------*/	private double getBilinearMeanSquares(final double[][] matrix, final double[][] hessian, final double[] gradient)	{		double yx;		double yy;		double yxy;		double yyy;		double x0;		double y0;		double uv;		double xGradient;		double yGradient;		double difference;		double meanSquares = 0.0;		double g0;		double g1;		double g2;		double g3;		double dx0;		double dx1;		double dx2;		double dx3;		double dy0;		double dy1;		double dy2;		double dy3;		long area = 0L;		int xMsk;		int yMsk;		int k = 0;		this.computeBilinearGradientConstants();		for (int i = 0; (i < this.transformation); i++)		{			gradient[i] = 0.0;			for (int j = 0; (j < this.transformation); j++)			{				hessian[i][j] = 0.0;			}		}		if(this.inMsk == null)		{			yx = matrix[0][0];			yy = matrix[1][0];			yxy = 0.0;			yyy = 0.0;			for (int v = 0; (v < this.outNy); v++)			{				x0 = yx;				y0 = yy;				for (int u = 0; (u < this.outNx); u++, k++)				{					if(this.outMsk[k] != 0.0F)					{						this.x = x0;						this.y = y0;						xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));						yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));						if((0 <= xMsk) && (xMsk < this.inNx) && (0 <= yMsk) && (yMsk < this.inNy))						{							area++;							this.xIndexes();							this.yIndexes();							this.x -= (0.0 <= this.x) ? ((int) this.x) : ((int) this.x - 1);							this.y -= (0.0 <= this.y) ? ((int) this.y) : ((int) this.y - 1);							this.xDxWeights();							this.yDyWeights();							difference = this.interpolate() - this.outImg[k];							meanSquares += difference * difference;							xGradient = this.interpolateDx();							yGradient = this.interpolateDy();							uv = (double) u * (double) v;							g0 = this.c0uv * uv + this.c0u * u + this.c0v * v + this.c0;							g1 = this.c1uv * uv + this.c1u * u + this.c1v * v + this.c1;							g2 = this.c2uv * uv + this.c2u * u + this.c2v * v + this.c2;							g3 = this.c3uv * uv + this.c3u * u + this.c3v * v + this.c3;							dx0 = xGradient * g0;							dy0 = yGradient * g0;							dx1 = xGradient * g1;							dy1 = yGradient * g1;							dx2 = xGradient * g2;							dy2 = yGradient * g2;							dx3 = xGradient * g3;							dy3 = yGradient * g3;							gradient[0] += difference * dx0;							gradient[1] += difference * dy0;							gradient[2] += difference * dx1;							gradient[3] += difference * dy1;							gradient[4] += difference * dx2;							gradient[5] += difference * dy2;							gradient[6] += difference * dx3;							gradient[7] += difference * dy3;							hessian[0][0] += dx0 * dx0;							hessian[0][1] += dx0 * dy0;							hessian[0][2] += dx0 * dx1;							hessian[0][3] += dx0 * dy1;							hessian[0][4] += dx0 * dx2;							hessian[0][5] += dx0 * dy2;							hessian[0][6] += dx0 * dx3;							hessian[0][7] += dx0 * dy3;							hessian[1][1] += dy0 * dy0;							hessian[1][2] += dy0 * dx1;							hessian[1][3] += dy0 * dy1;							hessian[1][4] += dy0 * dx2;							hessian[1][5] += dy0 * dy2;							hessian[1][6] += dy0 * dx3;							hessian[1][7] += dy0 * dy3;							hessian[2][2] += dx1 * dx1;							hessian[2][3] += dx1 * dy1;							hessian[2][4] += dx1 * dx2;							hessian[2][5] += dx1 * dy2;							hessian[2][6] += dx1 * dx3;							hessian[2][7] += dx1 * dy3;							hessian[3][3] += dy1 * dy1;							hessian[3][4] += dy1 * dx2;							hessian[3][5] += dy1 * dy2;							hessian[3][6] += dy1 * dx3;							hessian[3][7] += dy1 * dy3;							hessian[4][4] += dx2 * dx2;							hessian[4][5] += dx2 * dy2;							hessian[4][6] += dx2 * dx3;							hessian[4][7] += dx2 * dy3;							hessian[5][5] += dy2 * dy2;							hessian[5][6] += dy2 * dx3;							hessian[5][7] += dy2 * dy3;							hessian[6][6] += dx3 * dx3;							hessian[6][7] += dx3 * dy3;							hessian[7][7] += dy3 * dy3;						}					}					x0 += matrix[0][1] + yxy;					y0 += matrix[1][1] + yyy;				}				yx += matrix[0][2];				yy += matrix[1][2];				yxy += matrix[0][3];				yyy += matrix[1][3];			}		}		else		{			yx = matrix[0][0];			yy = matrix[1][0];			yxy = 0.0;			yyy = 0.0;			for (int v = 0; (v < this.outNy); v++)			{				x0 = yx;				y0 = yy;				for (int u = 0; (u < this.outNx); u++, k++)				{					this.x = x0;					this.y = y0;					xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));					yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));					if((0 <= xMsk) && (xMsk < this.inNx) && (0 <= yMsk) && (yMsk < this.inNy))					{						xMsk += yMsk * this.inNx;						if((this.outMsk[k] * this.inMsk[xMsk]) != 0.0F)						{							area++;							this.xIndexes();							this.yIndexes();							this.x -= (0.0 <= this.x) ? ((int) this.x) : ((int) this.x - 1);							this.y -= (0.0 <= this.y) ? ((int) this.y) : ((int) this.y - 1);							this.xDxWeights();							this.yDyWeights();							difference = this.interpolate() - this.outImg[k];							meanSquares += difference * difference;							xGradient = this.interpolateDx();							yGradient = this.interpolateDy();							uv = (double) u * (double) v;							g0 = this.c0uv * uv + this.c0u * u + this.c0v * v + this.c0;							g1 = this.c1uv * uv + this.c1u * u + this.c1v * v + this.c1;							g2 = this.c2uv * uv + this.c2u * u + this.c2v * v + this.c2;							g3 = this.c3uv * uv + this.c3u * u + this.c3v * v + this.c3;							dx0 = xGradient * g0;							dy0 = yGradient * g0;							dx1 = xGradient * g1;							dy1 = yGradient * g1;							dx2 = xGradient * g2;							dy2 = yGradient * g2;							dx3 = xGradient * g3;							dy3 = yGradient * g3;							gradient[0] += difference * dx0;							gradient[1] += difference * dy0;							gradient[2] += difference * dx1;							gradient[3] += difference * dy1;							gradient[4] += difference * dx2;							gradient[5] += difference * dy2;							gradient[6] += difference * dx3;							gradient[7] += difference * dy3;							hessian[0][0] += dx0 * dx0;							hessian[0][1] += dx0 * dy0;							hessian[0][2] += dx0 * dx1;							hessian[0][3] += dx0 * dy1;							hessian[0][4] += dx0 * dx2;							hessian[0][5] += dx0 * dy2;							hessian[0][6] += dx0 * dx3;							hessian[0][7] += dx0 * dy3;							hessian[1][1] += dy0 * dy0;							hessian[1][2] += dy0 * dx1;							hessian[1][3] += dy0 * dy1;							hessian[1][4] += dy0 * dx2;							hessian[1][5] += dy0 * dy2;							hessian[1][6] += dy0 * dx3;							hessian[1][7] += dy0 * dy3;							hessian[2][2] += dx1 * dx1;							hessian[2][3] += dx1 * dy1;							hessian[2][4] += dx1 * dx2;							hessian[2][5] += dx1 * dy2;							hessian[2][6] += dx1 * dx3;							hessian[2][7] += dx1 * dy3;							hessian[3][3] += dy1 * dy1;							hessian[3][4] += dy1 * dx2;							hessian[3][5] += dy1 * dy2;							hessian[3][6] += dy1 * dx3;							hessian[3][7] += dy1 * dy3;							hessian[4][4] += dx2 * dx2;							hessian[4][5] += dx2 * dy2;							hessian[4][6] += dx2 * dx3;							hessian[4][7] += dx2 * dy3;							hessian[5][5] += dy2 * dy2;							hessian[5][6] += dy2 * dx3;							hessian[5][7] += dy2 * dy3;							hessian[6][6] += dx3 * dx3;							hessian[6][7] += dx3 * dy3;							hessian[7][7] += dy3 * dy3;						}					}					x0 += matrix[0][1] + yxy;					y0 += matrix[1][1] + yyy;				}				yx += matrix[0][2];				yy += matrix[1][2];				yxy += matrix[0][3];				yyy += matrix[1][3];			}		}		for (int i = 1; (i < this.transformation); i++)		{			for (int j = 0; (j < i); j++)			{				hessian[i][j] = hessian[j][i];			}		}		return (meanSquares / area);	} /* getBilinearMeanSquares */		/*------------------------------------------------------------------*/	private double getRigidBodyMeanSquares(final double[][] matrix)	{		double yx;		double yy;		double x0;		double y0;		double difference;		double meanSquares = 0.0;		long area = 0L;		int xMsk;		int yMsk;		int k = 0;		if(this.outMsk == null)		{			yx = matrix[0][0];			yy = matrix[1][0];			for (int v = 0; (v < this.outNy); v++)			{				x0 = yx;				y0 = yy;				for (int u = 0; (u < this.outNx); u++, k++)				{					this.x = x0;					this.y = y0;					xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));					yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));					if((0 <= xMsk) && (xMsk < this.inNx) && (0 <= yMsk) && (yMsk < this.inNy))					{						if(this.inMsk[yMsk * this.inNx + xMsk] != 0.0F)						{							area++;							this.xIndexes();							this.yIndexes();							this.x -= (0.0 <= this.x) ? ((int) this.x) : ((int) this.x - 1);							this.y -= (0.0 <= this.y) ? ((int) this.y) : ((int) this.y - 1);							this.xWeights();							this.yWeights();							difference = this.outImg[k] - this.interpolate();							meanSquares += difference * difference;						}					}					x0 += matrix[0][1];					y0 += matrix[1][1];				}				yx += matrix[0][2];				yy += matrix[1][2];			}		}		else		{			yx = matrix[0][0];			yy = matrix[1][0];			for (int v = 0; (v < this.outNy); v++)			{				x0 = yx;				y0 = yy;				for (int u = 0; (u < this.outNx); u++, k++)				{					this.x = x0;					this.y = y0;					xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));					yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));					if((0 <= xMsk) && (xMsk < this.inNx) && (0 <= yMsk) && (yMsk < this.inNy))					{						if((this.outMsk[k] * this.inMsk[yMsk * this.inNx + xMsk]) != 0.0F)						{							area++;							this.xIndexes();							this.yIndexes();							this.x -= (0.0 <= this.x) ? ((int) this.x) : ((int) this.x - 1);							this.y -= (0.0 <= this.y) ? ((int) this.y) : ((int) this.y - 1);							this.xWeights();							this.yWeights();							difference = this.outImg[k] - this.interpolate();							meanSquares += difference * difference;						}					}					x0 += matrix[0][1];					y0 += matrix[1][1];				}				yx += matrix[0][2];				yy += matrix[1][2];			}		}		return (meanSquares / area);	} /* getRigidBodyMeanSquares */		/*------------------------------------------------------------------*/	private double getRigidBodyMeanSquares(final double[][] matrix, final double[] gradient		)	{		double yx;		double yy;		double x0;		double y0;		double difference;		double meanSquares = 0.0;		long area = 0L;		int xMsk;		int yMsk;		int k = 0;		for (int i = 0; (i < this.transformation); i++)		{			gradient[i] = 0.0;		}		if(this.outMsk == null)		{			yx = matrix[0][0];			yy = matrix[1][0];			for (int v = 0; (v < this.outNy); v++)			{				x0 = yx;				y0 = yy;				for (int u = 0; (u < this.outNx); u++, k++)				{					this.x = x0;					this.y = y0;					xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));					yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));					if((0 <= xMsk) && (xMsk < this.inNx) && (0 <= yMsk) && (yMsk < this.inNy))					{						if(this.inMsk[yMsk * this.inNx + xMsk] != 0.0F)						{							area++;							this.xIndexes();							this.yIndexes();							this.x -= (0.0 <= this.x) ? ((int) this.x) : ((int) this.x - 1);							this.y -= (0.0 <= this.y) ? ((int) this.y) : ((int) this.y - 1);							this.xWeights();							this.yWeights();							difference = this.outImg[k] - this.interpolate();							meanSquares += difference * difference;							gradient[0] += difference * (this.yGradient[k] * (double) u - this.xGradient[k] * (double) v);							gradient[1] += difference * this.xGradient[k];							gradient[2] += difference * this.yGradient[k];						}					}					x0 += matrix[0][1];					y0 += matrix[1][1];				}				yx += matrix[0][2];				yy += matrix[1][2];			}		}		else		{			yx = matrix[0][0];			yy = matrix[1][0];			for (int v = 0; (v < this.outNy); v++)			{				x0 = yx;				y0 = yy;				for (int u = 0; (u < this.outNx); u++, k++)				{					this.x = x0;					this.y = y0;					xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));					yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));					if((0 <= xMsk) && (xMsk < this.inNx) && (0 <= yMsk) && (yMsk < this.inNy))					{						if((this.outMsk[k] * this.inMsk[yMsk * this.inNx + xMsk]) != 0.0F)						{							area++;							this.xIndexes();							this.yIndexes();							this.x -= (0.0 <= this.x) ? ((int) this.x) : ((int) this.x - 1);							this.y -= (0.0 <= this.y) ? ((int) this.y) : ((int) this.y - 1);							this.xWeights();							this.yWeights();							difference = this.outImg[k] - this.interpolate();							meanSquares += difference * difference;							gradient[0] += difference * (this.yGradient[k] * (double) u - this.xGradient[k] * (double) v);							gradient[1] += difference * this.xGradient[k];							gradient[2] += difference * this.yGradient[k];						}					}					x0 += matrix[0][1];					y0 += matrix[1][1];				}				yx += matrix[0][2];				yy += matrix[1][2];			}		}		return (meanSquares / area);	} /* getRigidBodyMeanSquares */		/*------------------------------------------------------------------*/	private double getRigidBodyMeanSquares(final double[][] matrix, final double[][] hessian, final double[] gradient)	{		double yx;		double yy;		double x0;		double y0;		double dTheta;		double difference;		double meanSquares = 0.0;		long area = 0L;		int xMsk;		int yMsk;		int k = 0;		for (int i = 0; (i < this.transformation); i++)		{			gradient[i] = 0.0;			for (int j = 0; (j < this.transformation); j++)			{				hessian[i][j] = 0.0;			}		}		if(this.outMsk == null)		{			yx = matrix[0][0];			yy = matrix[1][0];			for (int v = 0; (v < this.outNy); v++)			{				x0 = yx;				y0 = yy;				for (int u = 0; (u < this.outNx); u++, k++)				{					this.x = x0;					this.y = y0;					xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));					yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));					if((0 <= xMsk) && (xMsk < this.inNx) && (0 <= yMsk) && (yMsk < this.inNy))					{						if(this.inMsk[yMsk * this.inNx + xMsk] != 0.0F)						{							area++;							this.xIndexes();							this.yIndexes();							this.x -= (0.0 <= this.x) ? ((int) this.x) : ((int) this.x - 1);							this.y -= (0.0 <= this.y) ? ((int) this.y) : ((int) this.y - 1);							this.xWeights();							this.yWeights();							difference = this.outImg[k] - this.interpolate();							meanSquares += difference * difference;							dTheta = this.yGradient[k] * (double) u - this.xGradient[k] * (double) v;							gradient[0] += difference * dTheta;							gradient[1] += difference * this.xGradient[k];							gradient[2] += difference * this.yGradient[k];							hessian[0][0] += dTheta * dTheta;							hessian[0][1] += dTheta * this.xGradient[k];							hessian[0][2] += dTheta * this.yGradient[k];							hessian[1][1] += this.xGradient[k] * this.xGradient[k];							hessian[1][2] += this.xGradient[k] * this.yGradient[k];							hessian[2][2] += this.yGradient[k] * this.yGradient[k];						}					}					x0 += matrix[0][1];					y0 += matrix[1][1];				}				yx += matrix[0][2];				yy += matrix[1][2];			}		}		else		{			yx = matrix[0][0];			yy = matrix[1][0];			for (int v = 0; (v < this.outNy); v++)			{				x0 = yx;				y0 = yy;				for (int u = 0; (u < this.outNx); u++, k++)				{					this.x = x0;					this.y = y0;					xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));					yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));					if((0 <= xMsk) && (xMsk < this.inNx) && (0 <= yMsk) && (yMsk < this.inNy))					{						if((this.outMsk[k] * this.inMsk[yMsk * this.inNx + xMsk]) != 0.0F)						{							area++;							this.xIndexes();							this.yIndexes();							this.x -= (0.0 <= this.x) ? ((int) this.x) : ((int) this.x - 1);							this.y -= (0.0 <= this.y) ? ((int) this.y) : ((int) this.y - 1);							this.xWeights();							this.yWeights();							difference = this.outImg[k] - this.interpolate();							meanSquares += difference * difference;							dTheta = this.yGradient[k] * (double) u - this.xGradient[k] * (double) v;							gradient[0] += difference * dTheta;							gradient[1] += difference * this.xGradient[k];							gradient[2] += difference * this.yGradient[k];							hessian[0][0] += dTheta * dTheta;							hessian[0][1] += dTheta * this.xGradient[k];							hessian[0][2] += dTheta * this.yGradient[k];							hessian[1][1] += this.xGradient[k] * this.xGradient[k];							hessian[1][2] += this.xGradient[k] * this.yGradient[k];							hessian[2][2] += this.yGradient[k] * this.yGradient[k];						}					}					x0 += matrix[0][1];					y0 += matrix[1][1];				}				yx += matrix[0][2];				yy += matrix[1][2];			}		}		for (int i = 1; (i < this.transformation); i++)		{			for (int j = 0; (j < i); j++)			{				hessian[i][j] = hessian[j][i];			}		}		return (meanSquares / area);	} /* getRigidBodyMeanSquares */		/*------------------------------------------------------------------*/	private double getScaledRotationMeanSquares(final double[][] sourcePoint, final double[][] matrix)	{		final double u1 = sourcePoint[0][0];		final double u2 = sourcePoint[1][0];		final double v1 = sourcePoint[0][1];		final double v2 = sourcePoint[1][1];		final double u12 = u1 - u2;		final double v12 = v1 - v2;		final double uv2 = u12 * u12 + v12 * v12;		double yx;		double yy;		double x0;		double y0;		double difference;		double meanSquares = 0.0;		long area = 0L;		int xMsk;		int yMsk;		int k = 0;		if(this.outMsk == null)		{			yx = matrix[0][0];			yy = matrix[1][0];			for (int v = 0; (v < this.outNy); v++)			{				x0 = yx;				y0 = yy;				for (int u = 0; (u < this.outNx); u++, k++)				{					this.x = x0;					this.y = y0;					xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));					yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));					if((0 <= xMsk) && (xMsk < this.inNx) && (0 <= yMsk) && (yMsk < this.inNy))					{						if(this.inMsk[yMsk * this.inNx + xMsk] != 0.0F)						{							area++;							this.xIndexes();							this.yIndexes();							this.x -= (0.0 <= this.x) ? ((int) this.x) : ((int) this.x - 1);							this.y -= (0.0 <= this.y) ? ((int) this.y) : ((int) this.y - 1);							this.xWeights();							this.yWeights();							difference = this.outImg[k] - this.interpolate();							meanSquares += difference * difference;						}					}					x0 += matrix[0][1];					y0 += matrix[1][1];				}				yx += matrix[0][2];				yy += matrix[1][2];			}		}		else		{			yx = matrix[0][0];			yy = matrix[1][0];			for (int v = 0; (v < this.outNy); v++)			{				x0 = yx;				y0 = yy;				for (int u = 0; (u < this.outNx); u++, k++)				{					this.x = x0;					this.y = y0;					xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));					yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));					if((0 <= xMsk) && (xMsk < this.inNx) && (0 <= yMsk) && (yMsk < this.inNy))					{						if((this.outMsk[k] * this.inMsk[yMsk * this.inNx + xMsk]) != 0.0F)						{							area++;							this.xIndexes();							this.yIndexes();							this.x -= (0.0 <= this.x) ? ((int) this.x) : ((int) this.x - 1);							this.y -= (0.0 <= this.y) ? ((int) this.y) : ((int) this.y - 1);							this.xWeights();							this.yWeights();							difference = this.outImg[k] - this.interpolate();							meanSquares += difference * difference;						}					}					x0 += matrix[0][1];					y0 += matrix[1][1];				}				yx += matrix[0][2];				yy += matrix[1][2];			}		}		return (meanSquares / (area * uv2 / this.targetJacobian));	} /* getScaledRotationMeanSquares */		/*------------------------------------------------------------------*/	private double getScaledRotationMeanSquares(final double[][] sourcePoint, final double[][] matrix, final double[] gradient)	{		final double u1 = sourcePoint[0][0];		final double u2 = sourcePoint[1][0];		final double v1 = sourcePoint[0][1];		final double v2 = sourcePoint[1][1];		final double u12 = u1 - u2;		final double v12 = v1 - v2;		final double uv2 = u12 * u12 + v12 * v12;		final double c = 0.5 * (u2 * v1 - u1 * v2) / uv2;		final double c1 = u12 / uv2;		final double c2 = v12 / uv2;		final double c3 = (uv2 - u12 * v12) / uv2;		final double c4 = (uv2 + u12 * v12) / uv2;		final double c5 = c + u1 * c1 + u2 * c2;		final double c6 = c * (u12 * u12 - v12 * v12) / uv2;		final double c7 = c1 * c4;		final double c8 = c1 - c2 - c1 * c2 * v12;		final double c9 = c1 + c2 - c1 * c2 * u12;		final double c0 = c2 * c3;		final double dgxx0 = c1 * u2 + c2 * v2;		final double dgyx0 = 2.0 * c;		final double dgxx1 = c5 + c6;		final double dgyy1 = c5 - c6;		double yx;		double yy;		double x0;		double y0;		double difference;		double meanSquares = 0.0;		double gxx0;		double gxx1;		double gxy0;		double gxy1;		double gyx0;		double gyx1;		double gyy0;		double gyy1;		double dx0;		double dx1;		double dy0;		double dy1;		long area = 0L;		int xMsk;		int yMsk;		int k = 0;		for (int i = 0; (i < this.transformation); i++)		{			gradient[i] = 0.0;		}		if(this.outMsk == null)		{			yx = matrix[0][0];			yy = matrix[1][0];			for (int v = 0; (v < this.outNy); v++)			{				x0 = yx;				y0 = yy;				for (int u = 0; (u < this.outNx); u++, k++)				{					this.x = x0;					this.y = y0;					xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));					yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));					if((0 <= xMsk) && (xMsk < this.inNx) && (0 <= yMsk) && (yMsk < this.inNy))					{						if(this.inMsk[yMsk * this.inNx + xMsk] != 0.0F)						{							area++;							this.xIndexes();							this.yIndexes();							this.x -= (0.0 <= this.x) ? ((int) this.x) : ((int) this.x - 1);							this.y -= (0.0 <= this.y) ? ((int) this.y) : ((int) this.y - 1);							this.xWeights();							this.yWeights();							difference = this.outImg[k] - this.interpolate();							meanSquares += difference * difference;							gxx0 = u * c1 + v * c2 - dgxx0;							gyx0 = v * c1 - u * c2 + dgyx0;							gxy0 = -gyx0;							gyy0 = gxx0;							gxx1 = v * c8 - u * c7 + dgxx1;							gyx1 = -c3 * gyx0;							gxy1 = c4 * gyx0;							gyy1 = dgyy1 - u * c9 - v * c0;							dx0 = this.xGradient[k] * gxx0 + this.yGradient[k] * gyx0;							dy0 = this.xGradient[k] * gxy0 + this.yGradient[k] * gyy0;							dx1 = this.xGradient[k] * gxx1 + this.yGradient[k] * gyx1;							dy1 = this.xGradient[k] * gxy1 + this.yGradient[k] * gyy1;							gradient[0] += difference * dx0;							gradient[1] += difference * dy0;							gradient[2] += difference * dx1;							gradient[3] += difference * dy1;						}					}					x0 += matrix[0][1];					y0 += matrix[1][1];				}				yx += matrix[0][2];				yy += matrix[1][2];			}		}		else		{			yx = matrix[0][0];			yy = matrix[1][0];			for (int v = 0; (v < this.outNy); v++)			{				x0 = yx;				y0 = yy;				for (int u = 0; (u < this.outNx); u++, k++)				{					this.x = x0;					this.y = y0;					xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));					yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));					if((0 <= xMsk) && (xMsk < this.inNx) && (0 <= yMsk) && (yMsk < this.inNy))					{						if((this.outMsk[k] * this.inMsk[yMsk * this.inNx + xMsk]) != 0.0F)						{							area++;							this.xIndexes();							this.yIndexes();							this.x -= (0.0 <= this.x) ? ((int) this.x) : ((int) this.x - 1);							this.y -= (0.0 <= this.y) ? ((int) this.y) : ((int) this.y - 1);							this.xWeights();							this.yWeights();							difference = this.outImg[k] - this.interpolate();							meanSquares += difference * difference;							gxx0 = u * c1 + v * c2 - dgxx0;							gyx0 = v * c1 - u * c2 + dgyx0;							gxy0 = -gyx0;							gyy0 = gxx0;							gxx1 = v * c8 - u * c7 + dgxx1;							gyx1 = -c3 * gyx0;							gxy1 = c4 * gyx0;							gyy1 = dgyy1 - u * c9 - v * c0;							dx0 = this.xGradient[k] * gxx0 + this.yGradient[k] * gyx0;							dy0 = this.xGradient[k] * gxy0 + this.yGradient[k] * gyy0;							dx1 = this.xGradient[k] * gxx1 + this.yGradient[k] * gyx1;							dy1 = this.xGradient[k] * gxy1 + this.yGradient[k] * gyy1;							gradient[0] += difference * dx0;							gradient[1] += difference * dy0;							gradient[2] += difference * dx1;							gradient[3] += difference * dy1;						}					}					x0 += matrix[0][1];					y0 += matrix[1][1];				}				yx += matrix[0][2];				yy += matrix[1][2];			}		}		return (meanSquares / (area * uv2 / this.targetJacobian));	} /* getScaledRotationMeanSquares */		/*------------------------------------------------------------------*/	private double getScaledRotationMeanSquares(final double[][] sourcePoint, final double[][] matrix, final double[][] hessian, final double[] gradient)	{		final double u1 = sourcePoint[0][0];		final double u2 = sourcePoint[1][0];		final double v1 = sourcePoint[0][1];		final double v2 = sourcePoint[1][1];		final double u12 = u1 - u2;		final double v12 = v1 - v2;		final double uv2 = u12 * u12 + v12 * v12;		final double c = 0.5 * (u2 * v1 - u1 * v2) / uv2;		final double c1 = u12 / uv2;		final double c2 = v12 / uv2;		final double c3 = (uv2 - u12 * v12) / uv2;		final double c4 = (uv2 + u12 * v12) / uv2;		final double c5 = c + u1 * c1 + u2 * c2;		final double c6 = c * (u12 * u12 - v12 * v12) / uv2;		final double c7 = c1 * c4;		final double c8 = c1 - c2 - c1 * c2 * v12;		final double c9 = c1 + c2 - c1 * c2 * u12;		final double c0 = c2 * c3;		final double dgxx0 = c1 * u2 + c2 * v2;		final double dgyx0 = 2.0 * c;		final double dgxx1 = c5 + c6;		final double dgyy1 = c5 - c6;		double yx;		double yy;		double x0;		double y0;		double difference;		double meanSquares = 0.0;		double gxx0;		double gxx1;		double gxy0;		double gxy1;		double gyx0;		double gyx1;		double gyy0;		double gyy1;		double dx0;		double dx1;		double dy0;		double dy1;		long area = 0L;		int xMsk;		int yMsk;		int k = 0;		for (int i = 0; (i < this.transformation); i++)		{			gradient[i] = 0.0;			for (int j = 0; (j < this.transformation); j++)			{				hessian[i][j] = 0.0;			}		}		if(this.outMsk == null)		{			yx = matrix[0][0];			yy = matrix[1][0];			for (int v = 0; (v < this.outNy); v++)			{				x0 = yx;				y0 = yy;				for (int u = 0; (u < this.outNx); u++, k++)				{					this.x = x0;					this.y = y0;					xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));					yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));					if((0 <= xMsk) && (xMsk < this.inNx) && (0 <= yMsk) && (yMsk < this.inNy))					{						if(this.inMsk[yMsk * this.inNx + xMsk] != 0.0F)						{							area++;							this.xIndexes();							this.yIndexes();							this.x -= (0.0 <= this.x) ? ((int) this.x) : ((int) this.x - 1);							this.y -= (0.0 <= this.y) ? ((int) this.y) : ((int) this.y - 1);							this.xWeights();							this.yWeights();							difference = this.outImg[k] - this.interpolate();							meanSquares += difference * difference;							gxx0 = u * c1 + v * c2 - dgxx0;							gyx0 = v * c1 - u * c2 + dgyx0;							gxy0 = -gyx0;							gyy0 = gxx0;							gxx1 = v * c8 - u * c7 + dgxx1;							gyx1 = -c3 * gyx0;							gxy1 = c4 * gyx0;							gyy1 = dgyy1 - u * c9 - v * c0;							dx0 = this.xGradient[k] * gxx0 + this.yGradient[k] * gyx0;							dy0 = this.xGradient[k] * gxy0 + this.yGradient[k] * gyy0;							dx1 = this.xGradient[k] * gxx1 + this.yGradient[k] * gyx1;							dy1 = this.xGradient[k] * gxy1 + this.yGradient[k] * gyy1;							gradient[0] += difference * dx0;							gradient[1] += difference * dy0;							gradient[2] += difference * dx1;							gradient[3] += difference * dy1;							hessian[0][0] += dx0 * dx0;							hessian[0][1] += dx0 * dy0;							hessian[0][2] += dx0 * dx1;							hessian[0][3] += dx0 * dy1;							hessian[1][1] += dy0 * dy0;							hessian[1][2] += dy0 * dx1;							hessian[1][3] += dy0 * dy1;							hessian[2][2] += dx1 * dx1;							hessian[2][3] += dx1 * dy1;							hessian[3][3] += dy1 * dy1;						}					}					x0 += matrix[0][1];					y0 += matrix[1][1];				}				yx += matrix[0][2];				yy += matrix[1][2];			}		}		else		{			yx = matrix[0][0];			yy = matrix[1][0];			for (int v = 0; (v < this.outNy); v++)			{				x0 = yx;				y0 = yy;				for (int u = 0; (u < this.outNx); u++, k++)				{					this.x = x0;					this.y = y0;					xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));					yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));					if((0 <= xMsk) && (xMsk < this.inNx) && (0 <= yMsk) && (yMsk < this.inNy))					{						if((this.outMsk[k] * this.inMsk[yMsk * this.inNx + xMsk]) != 0.0F)						{							area++;							this.xIndexes();							this.yIndexes();							this.x -= (0.0 <= this.x) ? ((int) this.x) : ((int) this.x - 1);							this.y -= (0.0 <= this.y) ? ((int) this.y) : ((int) this.y - 1);							this.xWeights();							this.yWeights();							difference = this.outImg[k] - this.interpolate();							meanSquares += difference * difference;							gxx0 = u * c1 + v * c2 - dgxx0;							gyx0 = v * c1 - u * c2 + dgyx0;							gxy0 = -gyx0;							gyy0 = gxx0;							gxx1 = v * c8 - u * c7 + dgxx1;							gyx1 = -c3 * gyx0;							gxy1 = c4 * gyx0;							gyy1 = dgyy1 - u * c9 - v * c0;							dx0 = this.xGradient[k] * gxx0 + this.yGradient[k] * gyx0;							dy0 = this.xGradient[k] * gxy0 + this.yGradient[k] * gyy0;							dx1 = this.xGradient[k] * gxx1 + this.yGradient[k] * gyx1;							dy1 = this.xGradient[k] * gxy1 + this.yGradient[k] * gyy1;							gradient[0] += difference * dx0;							gradient[1] += difference * dy0;							gradient[2] += difference * dx1;							gradient[3] += difference * dy1;							hessian[0][0] += dx0 * dx0;							hessian[0][1] += dx0 * dy0;							hessian[0][2] += dx0 * dx1;							hessian[0][3] += dx0 * dy1;							hessian[1][1] += dy0 * dy0;							hessian[1][2] += dy0 * dx1;							hessian[1][3] += dy0 * dy1;							hessian[2][2] += dx1 * dx1;							hessian[2][3] += dx1 * dy1;							hessian[3][3] += dy1 * dy1;						}					}					x0 += matrix[0][1];					y0 += matrix[1][1];				}				yx += matrix[0][2];				yy += matrix[1][2];			}		}		for (int i = 1; (i < this.transformation); i++)		{			for (int j = 0; (j < i); j++)			{				hessian[i][j] = hessian[j][i];			}		}		return (meanSquares / (area * uv2 / this.targetJacobian));	} /* getScaledRotationMeanSquares */		/*------------------------------------------------------------------*/	private double[][] getTransformationMatrix(final double[][] fromCoord, final double[][] toCoord)	{		double[][] matrix = null;		double[][] a = null;		double[] v = null;		switch (this.transformation)		{			case turboRegDialog.TRANSLATION:			{				matrix = new double[2][1];				matrix[0][0] = toCoord[0][0] - fromCoord[0][0];				matrix[1][0] = toCoord[0][1] - fromCoord[0][1];				break;			}			case turboRegDialog.RIGID_BODY:			{				final double angle = Math.atan2(fromCoord[2][0] - fromCoord[1][0], fromCoord[2][1] - fromCoord[1][1]) - Math.atan2(toCoord[2][0] - toCoord[1][0], toCoord[2][1] - toCoord[1][1]);				final double c = Math.cos(angle);				final double s = Math.sin(angle);				matrix = new double[2][3];				matrix[0][0] = toCoord[0][0] - c * fromCoord[0][0] + s * fromCoord[0][1];				matrix[0][1] = c;				matrix[0][2] = -s;				matrix[1][0] = toCoord[0][1] - s * fromCoord[0][0] - c * fromCoord[0][1];				matrix[1][1] = s;				matrix[1][2] = c;				break;			}			case turboRegDialog.SCALED_ROTATION:			{				matrix = new double[2][3];				a = new double[3][3];				v = new double[3];				a[0][0] = 1.0;				a[0][1] = fromCoord[0][0];				a[0][2] = fromCoord[0][1];				a[1][0] = 1.0;				a[1][1] = fromCoord[1][0];				a[1][2] = fromCoord[1][1];				a[2][0] = 1.0;				a[2][1] = fromCoord[0][1] - fromCoord[1][1] + fromCoord[1][0];				a[2][2] = fromCoord[1][0] + fromCoord[1][1] - fromCoord[0][0];				this.invertGauss(a);				v[0] = toCoord[0][0];				v[1] = toCoord[1][0];				v[2] = toCoord[0][1] - toCoord[1][1] + toCoord[1][0];				for (int i = 0; (i < 3); i++)				{					matrix[0][i] = 0.0;					for (int j = 0; (j < 3); j++)					{						matrix[0][i] += a[i][j] * v[j];					}				}				v[0] = toCoord[0][1];				v[1] = toCoord[1][1];				v[2] = toCoord[1][0] + toCoord[1][1] - toCoord[0][0];				for (int i = 0; (i < 3); i++)				{					matrix[1][i] = 0.0;					for (int j = 0; (j < 3); j++)					{						matrix[1][i] += a[i][j] * v[j];					}				}				break;			}			case turboRegDialog.AFFINE:			{				matrix = new double[2][3];				a = new double[3][3];				v = new double[3];				a[0][0] = 1.0;				a[0][1] = fromCoord[0][0];				a[0][2] = fromCoord[0][1];				a[1][0] = 1.0;				a[1][1] = fromCoord[1][0];				a[1][2] = fromCoord[1][1];				a[2][0] = 1.0;				a[2][1] = fromCoord[2][0];				a[2][2] = fromCoord[2][1];				this.invertGauss(a);				v[0] = toCoord[0][0];				v[1] = toCoord[1][0];				v[2] = toCoord[2][0];				for (int i = 0; (i < 3); i++)				{					matrix[0][i] = 0.0;					for (int j = 0; (j < 3); j++)					{						matrix[0][i] += a[i][j] * v[j];					}				}				v[0] = toCoord[0][1];				v[1] = toCoord[1][1];				v[2] = toCoord[2][1];				for (int i = 0; (i < 3); i++)				{					matrix[1][i] = 0.0;					for (int j = 0; (j < 3); j++)					{						matrix[1][i] += a[i][j] * v[j];					}				}				break;			}			case turboRegDialog.BILINEAR:			{				matrix = new double[2][4];				a = new double[4][4];				v = new double[4];				a[0][0] = 1.0;				a[0][1] = fromCoord[0][0];				a[0][2] = fromCoord[0][1];				a[0][3] = fromCoord[0][0] * fromCoord[0][1];				a[1][0] = 1.0;				a[1][1] = fromCoord[1][0];				a[1][2] = fromCoord[1][1];				a[1][3] = fromCoord[1][0] * fromCoord[1][1];				a[2][0] = 1.0;				a[2][1] = fromCoord[2][0];				a[2][2] = fromCoord[2][1];				a[2][3] = fromCoord[2][0] * fromCoord[2][1];				a[3][0] = 1.0;				a[3][1] = fromCoord[3][0];				a[3][2] = fromCoord[3][1];				a[3][3] = fromCoord[3][0] * fromCoord[3][1];				this.invertGauss(a);				v[0] = toCoord[0][0];				v[1] = toCoord[1][0];				v[2] = toCoord[2][0];				v[3] = toCoord[3][0];				for (int i = 0; (i < 4); i++)				{					matrix[0][i] = 0.0;					for (int j = 0; (j < 4); j++)					{						matrix[0][i] += a[i][j] * v[j];					}				}				v[0] = toCoord[0][1];				v[1] = toCoord[1][1];				v[2] = toCoord[2][1];				v[3] = toCoord[3][1];				for (int i = 0; (i < 4); i++)				{					matrix[1][i] = 0.0;					for (int j = 0; (j < 4); j++)					{						matrix[1][i] += a[i][j] * v[j];					}				}				break;			}		}		return (matrix);	} /* end getTransformationMatrix */		/*------------------------------------------------------------------*/	private double getTranslationMeanSquares(final double[][] matrix)	{		double dx = matrix[0][0];		double dy = matrix[1][0];		final double dx0 = dx;		double difference;		double meanSquares = 0.0;		long area = 0L;		int xMsk;		int yMsk;		int k = 0;		this.x = dx - Math.floor(dx);		this.y = dy - Math.floor(dy);		this.xWeights();		this.yWeights();		if(this.outMsk == null)		{			for (int v = 0; (v < this.outNy); v++)			{				this.y = dy++;				yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));				if((0 <= yMsk) && (yMsk < this.inNy))				{					yMsk *= this.inNx;					this.yIndexes();					dx = dx0;					for (int u = 0; (u < this.outNx); u++, k++)					{						this.x = dx++;						xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));						if((0 <= xMsk) && (xMsk < this.inNx))						{							if(this.inMsk[yMsk + xMsk] != 0.0F)							{								this.xIndexes();								area++;								difference = this.outImg[k] - this.interpolate();								meanSquares += difference * difference;							}						}					}				}				else				{					k += this.outNx;				}			}		}		else		{			for (int v = 0; (v < this.outNy); v++)			{				this.y = dy++;				yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));				if((0 <= yMsk) && (yMsk < this.inNy))				{					yMsk *= this.inNx;					this.yIndexes();					dx = dx0;					for (int u = 0; (u < this.outNx); u++, k++)					{						this.x = dx++;						xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));						if((0 <= xMsk) && (xMsk < this.inNx))						{							if((this.outMsk[k] * this.inMsk[yMsk + xMsk]) != 0.0F)							{								this.xIndexes();								area++;								difference = this.outImg[k] - this.interpolate();								meanSquares += difference * difference;							}						}					}				}				else				{					k += this.outNx;				}			}		}		return (meanSquares / area);	} /* end getTranslationMeanSquares */		/*------------------------------------------------------------------*/	private double getTranslationMeanSquares(final double[][] matrix, final double[] gradient)	{		double dx = matrix[0][0];		double dy = matrix[1][0];		final double dx0 = dx;		double difference;		double meanSquares = 0.0;		long area = 0L;		int xMsk;		int yMsk;		int k = 0;		for (int i = 0; (i < this.transformation); i++)		{			gradient[i] = 0.0;		}		this.x = dx - Math.floor(dx);		this.y = dy - Math.floor(dy);		this.xWeights();		this.yWeights();		if(this.outMsk == null)		{			for (int v = 0; (v < this.outNy); v++)			{				this.y = dy++;				yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));				if((0 <= yMsk) && (yMsk < this.inNy))				{					yMsk *= this.inNx;					this.yIndexes();					dx = dx0;					for (int u = 0; (u < this.outNx); u++, k++)					{						this.x = dx++;						xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));						if((0 <= xMsk) && (xMsk < this.inNx))						{							if(this.inMsk[yMsk + xMsk] != 0.0F)							{								area++;								this.xIndexes();								difference = this.outImg[k] - this.interpolate();								meanSquares += difference * difference;								gradient[0] += difference * this.xGradient[k];								gradient[1] += difference * this.yGradient[k];							}						}					}				}				else				{					k += this.outNx;				}			}		}		else		{			for (int v = 0; (v < this.outNy); v++)			{				this.y = dy++;				yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));				if((0 <= yMsk) && (yMsk < this.inNy))				{					yMsk *= this.inNx;					this.yIndexes();					dx = dx0;					for (int u = 0; (u < this.outNx); u++, k++)					{						this.x = dx++;						xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));						if((0 <= xMsk) && (xMsk < this.inNx))						{							if((this.outMsk[k] * this.inMsk[yMsk + xMsk]) != 0.0F)							{								area++;								this.xIndexes();								difference = this.outImg[k] - this.interpolate();								meanSquares += difference * difference;								gradient[0] += difference * this.xGradient[k];								gradient[1] += difference * this.yGradient[k];							}						}					}				}				else				{					k += this.outNx;				}			}		}		return (meanSquares / area);	} /* end getTranslationMeanSquares */		/*------------------------------------------------------------------*/	private double getTranslationMeanSquares(final double[][] matrix, final double[][] hessian, final double[] gradient)	{		double dx = matrix[0][0];		double dy = matrix[1][0];		final double dx0 = dx;		double difference;		double meanSquares = 0.0;		long area = 0L;		int xMsk;		int yMsk;		int k = 0;		for (int i = 0; (i < this.transformation); i++)		{			gradient[i] = 0.0;			for (int j = 0; (j < this.transformation); j++)			{				hessian[i][j] = 0.0;			}		}		this.x = dx - Math.floor(dx);		this.y = dy - Math.floor(dy);		this.xWeights();		this.yWeights();		if(this.outMsk == null)		{			for (int v = 0; (v < this.outNy); v++)			{				this.y = dy++;				yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));				if((0 <= yMsk) && (yMsk < this.inNy))				{					yMsk *= this.inNx;					this.yIndexes();					dx = dx0;					for (int u = 0; (u < this.outNx); u++, k++)					{						this.x = dx++;						xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));						if((0 <= xMsk) && (xMsk < this.inNx))						{							if(this.inMsk[yMsk + xMsk] != 0.0F)							{								area++;								this.xIndexes();								difference = this.outImg[k] - this.interpolate();								meanSquares += difference * difference;								gradient[0] += difference * this.xGradient[k];								gradient[1] += difference * this.yGradient[k];								hessian[0][0] += this.xGradient[k] * this.xGradient[k];								hessian[0][1] += this.xGradient[k] * this.yGradient[k];								hessian[1][1] += this.yGradient[k] * this.yGradient[k];							}						}					}				}				else				{					k += this.outNx;				}			}		}		else		{			for (int v = 0; (v < this.outNy); v++)			{				this.y = dy++;				yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));				if((0 <= yMsk) && (yMsk < this.inNy))				{					yMsk *= this.inNx;					this.yIndexes();					dx = dx0;					for (int u = 0; (u < this.outNx); u++, k++)					{						this.x = dx++;						xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));						if((0 <= xMsk) && (xMsk < this.inNx))						{							if((this.outMsk[k] * this.inMsk[yMsk + xMsk]) != 0.0F)							{								area++;								this.xIndexes();								difference = this.outImg[k] - this.interpolate();								meanSquares += difference * difference;								gradient[0] += difference * this.xGradient[k];								gradient[1] += difference * this.yGradient[k];								hessian[0][0] += this.xGradient[k] * this.xGradient[k];								hessian[0][1] += this.xGradient[k] * this.yGradient[k];								hessian[1][1] += this.yGradient[k] * this.yGradient[k];							}						}					}				}				else				{					k += this.outNx;				}			}		}		for (int i = 1; (i < this.transformation); i++)		{			for (int j = 0; (j < i); j++)			{				hessian[i][j] = hessian[j][i];			}		}		return (meanSquares / area);	} /* end getTranslationMeanSquares */		/*------------------------------------------------------------------*/	private double interpolate()	{		this.t = 0.0;		for (int j = 0; (j < 4); j++)		{			this.s = 0.0;			this.p = this.yIndex[j];			for (int i = 0; (i < 4); i++)			{				this.s += this.xWeight[i] * this.inImg[this.p + this.xIndex[i]];			}			this.t += this.yWeight[j] * this.s;		}		return (this.t);	} /* end interpolate */		/*------------------------------------------------------------------*/	private double interpolateDx()	{		this.t = 0.0;		for (int j = 0; (j < 4); j++)		{			this.s = 0.0;			this.p = this.yIndex[j];			for (int i = 0; (i < 4); i++)			{				this.s += this.dxWeight[i] * this.inImg[this.p + this.xIndex[i]];			}			this.t += this.yWeight[j] * this.s;		}		return (this.t);	} /* end interpolateDx */		/*------------------------------------------------------------------*/	private double interpolateDy()	{		this.t = 0.0;		for (int j = 0; (j < 4); j++)		{			this.s = 0.0;			this.p = this.yIndex[j];			for (int i = 0; (i < 4); i++)			{				this.s += this.xWeight[i] * this.inImg[this.p + this.xIndex[i]];			}			this.t += this.dyWeight[j] * this.s;		}		return (this.t);	} /* end interpolateDy */		/*------------------------------------------------------------------*/	private void inverseMarquardtLevenbergOptimization(int workload)	{		final double[][] attempt = new double[this.transformation / 2][2];		final double[][] hessian = new double[this.transformation][this.transformation];		final double[][] pseudoHessian = new double[this.transformation][this.transformation];		final double[] gradient = new double[this.transformation];		double[][] matrix = this.getTransformationMatrix(this.sourcePoint, this.targetPoint);		double[] update = new double[this.transformation];		double bestMeanSquares = 0.0;		double meanSquares = 0.0;		double lambda = FIRST_LAMBDA;		double displacement;		int iteration = 0;		switch (this.transformation)		{			case turboRegDialog.TRANSLATION:			{				bestMeanSquares = this.getTranslationMeanSquares(matrix, hessian, gradient);				break;			}			case turboRegDialog.SCALED_ROTATION:			{				bestMeanSquares = this.getScaledRotationMeanSquares(this.sourcePoint, matrix, hessian, gradient);				break;			}			case turboRegDialog.AFFINE:			{				bestMeanSquares = this.getAffineMeanSquares(this.sourcePoint, matrix, hessian, gradient);				break;			}		}		iteration++;		do		{			for (int k = 0; (k < this.transformation); k++)			{				pseudoHessian[k][k] = (1.0 + lambda) * hessian[k][k];			}			this.invertGauss(pseudoHessian);			update = this.matrixMultiply(pseudoHessian, gradient);			displacement = 0.0;			for (int k = 0; (k < (this.transformation / 2)); k++)			{				attempt[k][0] = this.sourcePoint[k][0] - update[2 * k];				attempt[k][1] = this.sourcePoint[k][1] - update[2 * k + 1];				displacement += Math.sqrt(update[2 * k] * update[2 * k] + update[2 * k + 1] * update[2 * k + 1]);			}			displacement /= 0.5 * this.transformation;			matrix = this.getTransformationMatrix(attempt, this.targetPoint);			switch (this.transformation)			{				case turboRegDialog.TRANSLATION:				{					if(this.accelerated)					{						meanSquares = this.getTranslationMeanSquares(matrix, gradient);					}					else					{						meanSquares = this.getTranslationMeanSquares(matrix, hessian, gradient);					}					break;				}				case turboRegDialog.SCALED_ROTATION:				{					if(this.accelerated)					{						meanSquares = this.getScaledRotationMeanSquares(attempt, matrix, gradient);					}					else					{						meanSquares = this.getScaledRotationMeanSquares(attempt, matrix, hessian, gradient);					}					break;				}				case turboRegDialog.AFFINE:				{					if(this.accelerated)					{						meanSquares = this.getAffineMeanSquares(attempt, matrix, gradient);					}					else					{						meanSquares = this.getAffineMeanSquares(attempt, matrix, hessian, gradient);					}					break;				}			}			iteration++;			if(meanSquares < bestMeanSquares)			{				bestMeanSquares = meanSquares;				for (int k = 0; (k < (this.transformation / 2)); k++)				{					this.sourcePoint[k][0] = attempt[k][0];					this.sourcePoint[k][1] = attempt[k][1];				}				lambda /= LAMBDA_MAGSTEP;			}			else			{				lambda *= LAMBDA_MAGSTEP;			}			turboRegProgressBar.skipProgressBar(this.iterationCost);			workload--;		}		while ((iteration < (this.maxIterations * this.iterationPower - 1)) && (this.pixelPrecision <= displacement));		this.invertGauss(hessian);		update = this.matrixMultiply(hessian, gradient);		for (int k = 0; (k < (this.transformation / 2)); k++)		{			attempt[k][0] = this.sourcePoint[k][0] - update[2 * k];			attempt[k][1] = this.sourcePoint[k][1] - update[2 * k + 1];		}		matrix = this.getTransformationMatrix(attempt, this.targetPoint);		switch (this.transformation)		{			case turboRegDialog.TRANSLATION:			{				meanSquares = this.getTranslationMeanSquares(matrix);				break;			}			case turboRegDialog.SCALED_ROTATION:			{				meanSquares = this.getScaledRotationMeanSquares(attempt, matrix);				break;			}			case turboRegDialog.AFFINE:			{				meanSquares = this.getAffineMeanSquares(attempt, matrix);				break;			}		}		iteration++;		if(meanSquares < bestMeanSquares)		{			for (int k = 0; (k < (this.transformation / 2)); k++)			{				this.sourcePoint[k][0] = attempt[k][0];				this.sourcePoint[k][1] = attempt[k][1];			}		}		turboRegProgressBar.skipProgressBar(workload * this.iterationCost);	} /* end inverseMarquardtLevenbergOptimization */		/*------------------------------------------------------------------*/	private void inverseMarquardtLevenbergRigidBodyOptimization(int workload)	{		final double[][] attempt = new double[2][3];		final double[][] hessian = new double[this.transformation][this.transformation];		final double[][] pseudoHessian = new double[this.transformation][this.transformation];		final double[] gradient = new double[this.transformation];		double[][] matrix = this.getTransformationMatrix(this.targetPoint, this.sourcePoint);		double[] update = new double[this.transformation];		double bestMeanSquares = 0.0;		double meanSquares = 0.0;		double lambda = FIRST_LAMBDA;		double angle;		double c;		double s;		double displacement;		int iteration = 0;		for (int k = 0; (k < this.transformation); k++)		{			this.sourcePoint[k][0] = matrix[0][0] + this.targetPoint[k][0] * matrix[0][1] + this.targetPoint[k][1] * matrix[0][2];			this.sourcePoint[k][1] = matrix[1][0] + this.targetPoint[k][0] * matrix[1][1] + this.targetPoint[k][1] * matrix[1][2];		}		matrix = this.getTransformationMatrix(this.sourcePoint, this.targetPoint);		bestMeanSquares = this.getRigidBodyMeanSquares(matrix, hessian, gradient);		iteration++;		do		{			for (int k = 0; (k < this.transformation); k++)			{				pseudoHessian[k][k] = (1.0 + lambda) * hessian[k][k];			}			this.invertGauss(pseudoHessian);			update = this.matrixMultiply(pseudoHessian, gradient);			angle = Math.atan2(matrix[0][2], matrix[0][1]) - update[0];			attempt[0][1] = Math.cos(angle);			attempt[0][2] = Math.sin(angle);			attempt[1][1] = -attempt[0][2];			attempt[1][2] = attempt[0][1];			c = Math.cos(update[0]);			s = Math.sin(update[0]);			attempt[0][0] = (matrix[0][0] + update[1]) * c - (matrix[1][0] + update[2]) * s;			attempt[1][0] = (matrix[0][0] + update[1]) * s + (matrix[1][0] + update[2]) * c;			displacement = Math.sqrt(update[1] * update[1] + update[2] * update[2]) + 0.25 * Math.sqrt((double) (this.inNx * this.inNx) + (double) (this.inNy * this.inNy)) * Math.abs(update[0]);			if(this.accelerated)			{				meanSquares = this.getRigidBodyMeanSquares(attempt, gradient);			}			else			{				meanSquares = this.getRigidBodyMeanSquares(attempt, hessian, gradient);			}			iteration++;			if(meanSquares < bestMeanSquares)			{				bestMeanSquares = meanSquares;				for (int i = 0; (i < 2); i++)				{					for (int j = 0; (j < 3); j++)					{						matrix[i][j] = attempt[i][j];					}				}				lambda /= LAMBDA_MAGSTEP;			}			else			{				lambda *= LAMBDA_MAGSTEP;			}			turboRegProgressBar.skipProgressBar(this.iterationCost);			workload--;		}		while ((iteration < (this.maxIterations * this.iterationPower - 1)) && (this.pixelPrecision <= displacement));		this.invertGauss(hessian);		update = this.matrixMultiply(hessian, gradient);		angle = Math.atan2(matrix[0][2], matrix[0][1]) - update[0];		attempt[0][1] = Math.cos(angle);		attempt[0][2] = Math.sin(angle);		attempt[1][1] = -attempt[0][2];		attempt[1][2] = attempt[0][1];		c = Math.cos(update[0]);		s = Math.sin(update[0]);		attempt[0][0] = (matrix[0][0] + update[1]) * c - (matrix[1][0] + update[2]) * s;		attempt[1][0] = (matrix[0][0] + update[1]) * s + (matrix[1][0] + update[2]) * c;		meanSquares = this.getRigidBodyMeanSquares(attempt);		iteration++;		if(meanSquares < bestMeanSquares)		{			for (int i = 0; (i < 2); i++)			{				for (int j = 0; (j < 3); j++)				{					matrix[i][j] = attempt[i][j];				}			}		}		for (int k = 0; (k < this.transformation); k++)		{			this.sourcePoint[k][0] = (this.targetPoint[k][0] - matrix[0][0]) * matrix[0][1] + (this.targetPoint[k][1] - matrix[1][0]) * matrix[1][1];			this.sourcePoint[k][1] = (this.targetPoint[k][0] - matrix[0][0]) * matrix[0][2] + (this.targetPoint[k][1] - matrix[1][0]) * matrix[1][2];		}		turboRegProgressBar.skipProgressBar(workload * this.iterationCost);	} /* end inverseMarquardtLevenbergRigidBodyOptimization */		/*------------------------------------------------------------------*/	private void invertGauss(final double[][] matrix)	{		final int n = matrix.length;		final double[][] inverse = new double[n][n];		for (int i = 0; (i < n); i++)		{			double max = matrix[i][0];			double absMax = Math.abs(max);			for (int j = 0; (j < n); j++)			{				inverse[i][j] = 0.0;				if(absMax < Math.abs(matrix[i][j]))				{					max = matrix[i][j];					absMax = Math.abs(max);				}			}			inverse[i][i] = 1.0 / max;			for (int j = 0; (j < n); j++)			{				matrix[i][j] /= max;			}		}		for (int j = 0; (j < n); j++)		{			double max = matrix[j][j];			double absMax = Math.abs(max);			int k = j;			for (int i = j + 1; (i < n); i++)			{				if(absMax < Math.abs(matrix[i][j]))				{					max = matrix[i][j];					absMax = Math.abs(max);					k = i;				}			}			if(k != j)			{				final double[] partialLine = new double[n - j];				final double[] fullLine = new double[n];				System.arraycopy(matrix[j], j, partialLine, 0, n - j);				System.arraycopy(matrix[k], j, matrix[j], j, n - j);				System.arraycopy(partialLine, 0, matrix[k], j, n - j);				System.arraycopy(inverse[j], 0, fullLine, 0, n);				System.arraycopy(inverse[k], 0, inverse[j], 0, n);				System.arraycopy(fullLine, 0, inverse[k], 0, n);			}			for (k = 0; (k <= j); k++)			{				inverse[j][k] /= max;			}			for (k = j + 1; (k < n); k++)			{				matrix[j][k] /= max;				inverse[j][k] /= max;			}			for (int i = j + 1; (i < n); i++)			{				for (k = 0; (k <= j); k++)				{					inverse[i][k] -= matrix[i][j] * inverse[j][k];				}				for (k = j + 1; (k < n); k++)				{					matrix[i][k] -= matrix[i][j] * matrix[j][k];					inverse[i][k] -= matrix[i][j] * inverse[j][k];				}			}		}		for (int j = n - 1; (1 <= j); j--)		{			for (int i = j - 1; (0 <= i); i--)			{				for (int k = 0; (k <= j); k++)				{					inverse[i][k] -= matrix[i][j] * inverse[j][k];				}				for (int k = j + 1; (k < n); k++)				{					matrix[i][k] -= matrix[i][j] * matrix[j][k];					inverse[i][k] -= matrix[i][j] * inverse[j][k];				}			}		}		for (int i = 0; (i < n); i++)		{			System.arraycopy(inverse[i], 0, matrix[i], 0, n);		}	} /* end invertGauss */		/*------------------------------------------------------------------*/	private void MarquardtLevenbergOptimization(int workload)	{		final double[][] attempt = new double[this.transformation / 2][2];		final double[][] hessian = new double[this.transformation][this.transformation];		final double[][] pseudoHessian = new double[this.transformation][this.transformation];		final double[] gradient = new double[this.transformation];		double[][] matrix = this.getTransformationMatrix(this.targetPoint, this.sourcePoint);		double[] update = new double[this.transformation];		double bestMeanSquares = 0.0;		double meanSquares = 0.0;		double lambda = FIRST_LAMBDA;		double displacement;		int iteration = 0;		bestMeanSquares = this.getBilinearMeanSquares(matrix, hessian, gradient);		iteration++;		do		{			for (int k = 0; (k < this.transformation); k++)			{				pseudoHessian[k][k] = (1.0 + lambda) * hessian[k][k];			}			this.invertGauss(pseudoHessian);			update = this.matrixMultiply(pseudoHessian, gradient);			displacement = 0.0;			for (int k = 0; (k < (this.transformation / 2)); k++)			{				attempt[k][0] = this.sourcePoint[k][0] - update[2 * k];				attempt[k][1] = this.sourcePoint[k][1] - update[2 * k + 1];				displacement += Math.sqrt(update[2 * k] * update[2 * k] + update[2 * k + 1] * update[2 * k + 1]);			}			displacement /= 0.5 * this.transformation;			matrix = this.getTransformationMatrix(this.targetPoint, attempt);			meanSquares = this.getBilinearMeanSquares(matrix, hessian, gradient);			iteration++;			if(meanSquares < bestMeanSquares)			{				bestMeanSquares = meanSquares;				for (int k = 0; (k < (this.transformation / 2)); k++)				{					this.sourcePoint[k][0] = attempt[k][0];					this.sourcePoint[k][1] = attempt[k][1];				}				lambda /= LAMBDA_MAGSTEP;			}			else			{				lambda *= LAMBDA_MAGSTEP;			}			turboRegProgressBar.skipProgressBar(this.iterationCost);			workload--;		}		while ((iteration < (this.maxIterations * this.iterationPower - 1)) && (this.pixelPrecision <= displacement));		this.invertGauss(hessian);		update = this.matrixMultiply(hessian, gradient);		for (int k = 0; (k < (this.transformation / 2)); k++)		{			attempt[k][0] = this.sourcePoint[k][0] - update[2 * k];			attempt[k][1] = this.sourcePoint[k][1] - update[2 * k + 1];		}		matrix = this.getTransformationMatrix(this.targetPoint, attempt);		meanSquares = this.getBilinearMeanSquares(matrix);		iteration++;		if(meanSquares < bestMeanSquares)		{			for (int k = 0; (k < (this.transformation / 2)); k++)			{				this.sourcePoint[k][0] = attempt[k][0];				this.sourcePoint[k][1] = attempt[k][1];			}		}		turboRegProgressBar.skipProgressBar(workload * this.iterationCost);	} /* end MarquardtLevenbergOptimization */		/*------------------------------------------------------------------*/	private double[] matrixMultiply(final double[][] matrix, final double[] vector)	{		final double[] result = new double[matrix.length];		for (int i = 0; (i < matrix.length); i++)		{			result[i] = 0.0;			for (int j = 0; (j < vector.length); j++)			{				result[i] += matrix[i][j] * vector[j];			}		}		return (result);	} /* end matrixMultiply */		/*------------------------------------------------------------------*/	private void scaleBottomDownLandmarks()	{		for (int depth = 1; (depth < this.pyramidDepth); depth++)		{			if(this.transformation == turboRegDialog.RIGID_BODY)			{				for (int n = 0; (n < this.transformation); n++)				{					this.sourcePoint[n][0] *= 0.5;					this.sourcePoint[n][1] *= 0.5;					this.targetPoint[n][0] *= 0.5;					this.targetPoint[n][1] *= 0.5;				}			}			else			{				for (int n = 0; (n < (this.transformation / 2)); n++)				{					this.sourcePoint[n][0] *= 0.5;					this.sourcePoint[n][1] *= 0.5;					this.targetPoint[n][0] *= 0.5;					this.targetPoint[n][1] *= 0.5;				}			}		}	} /* end scaleBottomDownLandmarks */		/*------------------------------------------------------------------*/	private void scaleUpLandmarks()	{		if(this.transformation == turboRegDialog.RIGID_BODY)		{			for (int n = 0; (n < this.transformation); n++)			{				this.sourcePoint[n][0] *= 2.0;				this.sourcePoint[n][1] *= 2.0;				this.targetPoint[n][0] *= 2.0;				this.targetPoint[n][1] *= 2.0;			}		}		else		{			for (int n = 0; (n < (this.transformation / 2)); n++)			{				this.sourcePoint[n][0] *= 2.0;				this.sourcePoint[n][1] *= 2.0;				this.targetPoint[n][0] *= 2.0;				this.targetPoint[n][1] *= 2.0;			}		}	} /* end scaleUpLandmarks */		/*------------------------------------------------------------------*/	private void translationTransform(final double[][] matrix)	{		double dx = matrix[0][0];		double dy = matrix[1][0];		final double dx0 = dx;		int xMsk;		int yMsk;		this.x = dx - Math.floor(dx);		this.y = dy - Math.floor(dy);		if(!this.accelerated)		{			this.xWeights();			this.yWeights();		}		int k = 0;		turboRegProgressBar.addWorkload(this.outNy);		for (int v = 0; (v < this.outNy); v++)		{			this.y = dy++;			yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));			if((0 <= yMsk) && (yMsk < this.inNy))			{				yMsk *= this.inNx;				if(!this.accelerated)				{					this.yIndexes();				}				dx = dx0;				for (int u = 0; (u < this.outNx); u++)				{					this.x = dx++;					xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));					if((0 <= xMsk) && (xMsk < this.inNx))					{						xMsk += yMsk;						if(this.accelerated)						{							this.outImg[k++] = this.inImg[xMsk];						}						else						{							this.xIndexes();							this.outImg[k++] = (float) this.interpolate();						}					}					else					{						this.outImg[k++] = 0.0F;					}				}			}			else			{				for (int u = 0; (u < this.outNx); u++)				{					this.outImg[k++] = 0.0F;				}			}			turboRegProgressBar.stepProgressBar();		}		turboRegProgressBar.workloadDone(this.outNy);	} /* translationTransform */		/*------------------------------------------------------------------*/	private void translationTransform(final double[][] matrix, final float[] outMsk)	{		double dx = matrix[0][0];		double dy = matrix[1][0];		final double dx0 = dx;		int xMsk;		int yMsk;		this.x = dx - Math.floor(dx);		this.y = dy - Math.floor(dy);		if(!this.accelerated)		{			this.xWeights();			this.yWeights();		}		int k = 0;		turboRegProgressBar.addWorkload(this.outNy);		for (int v = 0; (v < this.outNy); v++)		{			this.y = dy++;			yMsk = (0.0 <= this.y) ? ((int) (this.y + 0.5)) : ((int) (this.y - 0.5));			if((0 <= yMsk) && (yMsk < this.inNy))			{				yMsk *= this.inNx;				if(!this.accelerated)				{					this.yIndexes();				}				dx = dx0;				for (int u = 0; (u < this.outNx); u++, k++)				{					this.x = dx++;					xMsk = (0.0 <= this.x) ? ((int) (this.x + 0.5)) : ((int) (this.x - 0.5));					if((0 <= xMsk) && (xMsk < this.inNx))					{						xMsk += yMsk;						if(this.accelerated)						{							this.outImg[k] = this.inImg[xMsk];						}						else						{							this.xIndexes();							this.outImg[k] = (float) this.interpolate();						}						outMsk[k] = this.inMsk[xMsk];					}					else					{						this.outImg[k] = 0.0F;						outMsk[k] = 0.0F;					}				}			}			else			{				for (int u = 0; (u < this.outNx); u++, k++)				{					this.outImg[k] = 0.0F;					outMsk[k] = 0.0F;				}			}			turboRegProgressBar.stepProgressBar();		}		turboRegProgressBar.workloadDone(this.outNy);	} /* translationTransform */		/*------------------------------------------------------------------*/	private void xDxWeights()	{		this.s = 1.0 - this.x;		this.dxWeight[0] = 0.5 * this.x * this.x;		this.xWeight[0] = this.x * this.dxWeight[0] / 3.0;		this.dxWeight[3] = -0.5 * this.s * this.s;		this.xWeight[3] = this.s * this.dxWeight[3] / -3.0;		this.dxWeight[1] = 1.0 - 2.0 * this.dxWeight[0] + this.dxWeight[3];		this.xWeight[1] = 2.0 / 3.0 + (1.0 + this.x) * this.dxWeight[3];		this.dxWeight[2] = 1.5 * this.x * (this.x - 4.0 / 3.0);		this.xWeight[2] = 2.0 / 3.0 - (2.0 - this.x) * this.dxWeight[0];	} /* xDxWeights */		/*------------------------------------------------------------------*/	private void xIndexes()	{		this.p = (0.0 <= this.x) ? ((int) this.x + 2) : ((int) this.x + 1);		for (int k = 0; (k < 4); this.p--, k++)		{			this.q = (this.p < 0) ? (-1 - this.p) : (this.p);			if(this.twiceInNx <= this.q)			{				this.q -= this.twiceInNx * (this.q / this.twiceInNx);			}			this.xIndex[k] = (this.inNx <= this.q) ? (this.twiceInNx - 1 - this.q) : (this.q);		}	} /* xIndexes */		/*------------------------------------------------------------------*/	private void xWeights()	{		this.s = 1.0 - this.x;		this.xWeight[3] = this.s * this.s * this.s / 6.0;		this.s = this.x * this.x;		this.xWeight[2] = 2.0 / 3.0 - 0.5 * this.s * (2.0 - this.x);		this.xWeight[0] = this.s * this.x / 6.0;		this.xWeight[1] = 1.0 - this.xWeight[0] - this.xWeight[2] - this.xWeight[3];	} /* xWeights */		/*------------------------------------------------------------------*/	private void yDyWeights()	{		this.t = 1.0 - this.y;		this.dyWeight[0] = 0.5 * this.y * this.y;		this.yWeight[0] = this.y * this.dyWeight[0] / 3.0;		this.dyWeight[3] = -0.5 * this.t * this.t;		this.yWeight[3] = this.t * this.dyWeight[3] / -3.0;		this.dyWeight[1] = 1.0 - 2.0 * this.dyWeight[0] + this.dyWeight[3];		this.yWeight[1] = 2.0 / 3.0 + (1.0 + this.y) * this.dyWeight[3];		this.dyWeight[2] = 1.5 * this.y * (this.y - 4.0 / 3.0);		this.yWeight[2] = 2.0 / 3.0 - (2.0 - this.y) * this.dyWeight[0];	} /* yDyWeights */		/*------------------------------------------------------------------*/	private void yIndexes()	{		this.p = (0.0 <= this.y) ? ((int) this.y + 2) : ((int) this.y + 1);		for (int k = 0; (k < 4); this.p--, k++)		{			this.q = (this.p < 0) ? (-1 - this.p) : (this.p);			if(this.twiceInNy <= this.q)			{				this.q -= this.twiceInNy * (this.q / this.twiceInNy);			}			this.yIndex[k] = (this.inNy <= this.q) ? ((this.twiceInNy - 1 - this.q) * this.inNx) : (this.q * this.inNx);		}	} /* yIndexes */		/*------------------------------------------------------------------*/	private void yWeights()	{		this.t = 1.0 - this.y;		this.yWeight[3] = this.t * this.t * this.t / 6.0;		this.t = this.y * this.y;		this.yWeight[2] = 2.0 / 3.0 - 0.5 * this.t * (2.0 - this.y);		this.yWeight[0] = this.t * this.y / 6.0;		this.yWeight[1] = 1.0 - this.yWeight[0] - this.yWeight[2] - this.yWeight[3];	} /* yWeights */	} /* end class turboRegTransform */